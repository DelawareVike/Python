{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python Crash Course, Third Edition This is a collection of resources for Python Crash Course (3rd Ed.) , an introductory programming book from No Starch Press by Eric Matthes. The simplest way to download the source code files for the book is to click on the Download .zip button below. This will download the source code files for all chapters, as well as a number of data files and images you'll need for the projects. Download .zip View on GitHub The full set of resources for the third edition is still being developed. If you are an early reader of the third edition, some of the second edition's resources may still be useful, such as the Cheat Sheets and articles such as Finding Employment . If you have any questions about Python Crash Course, feel free to get in touch: Email: ehmatthes@gmail.com Twitter: @ehmatthes Mastodon: @ehmatthes@fosstodon.org Available from No Starch Press , Amazon , and Barnes & Noble . You can also find Python Crash Course in person at Barnes & Noble bookstores, and other fine booksellers worldwide.","title":"Home"},{"location":"#python-crash-course-third-edition","text":"This is a collection of resources for Python Crash Course (3rd Ed.) , an introductory programming book from No Starch Press by Eric Matthes. The simplest way to download the source code files for the book is to click on the Download .zip button below. This will download the source code files for all chapters, as well as a number of data files and images you'll need for the projects. Download .zip View on GitHub The full set of resources for the third edition is still being developed. If you are an early reader of the third edition, some of the second edition's resources may still be useful, such as the Cheat Sheets and articles such as Finding Employment . If you have any questions about Python Crash Course, feel free to get in touch: Email: ehmatthes@gmail.com Twitter: @ehmatthes Mastodon: @ehmatthes@fosstodon.org Available from No Starch Press , Amazon , and Barnes & Noble . You can also find Python Crash Course in person at Barnes & Noble bookstores, and other fine booksellers worldwide.","title":"Python Crash Course, Third Edition"},{"location":"contact/","text":"Contact If you have any questions about Python Crash Course, or any feedback about what you see here, please feel free to get in touch: Email: ehmatthes@gmail.com Twitter: @ehmatthes Mastodon: @ehmatthes@fosstodon.org If you're curious what I'm up to in the Python world, I write a weekly newsletter at Mostly Python .","title":"Contact"},{"location":"contact/#contact","text":"If you have any questions about Python Crash Course, or any feedback about what you see here, please feel free to get in touch: Email: ehmatthes@gmail.com Twitter: @ehmatthes Mastodon: @ehmatthes@fosstodon.org If you're curious what I'm up to in the Python world, I write a weekly newsletter at Mostly Python .","title":"Contact"},{"location":"new_in_3e/","text":"What's new in the third edition? Python is a mature language, but like every programming language it continues to evolve. The third edition incorporates the most important new features in Python, without becoming bloated by trying to include every new feature that's been introduced in recent years. The new edition uses the latest versions of all third-party libraries in the projects section. Overall changes Here's a summary of the changes that have been made to the book overall: The third edition uses Python 3.11. (The second edition was written using Python 3.7.) The new edition uses VS Code instead of Sublime Text. VS Code is fully open, and has seen widespread adoption in the Python world over the last several years. Code listings are less cluttered and easier to follow throughout the book. The new edition uses updated libraries throughout, and updated workflows for each library. Specific changes Chapter 1 In the setup section, VS Code is recommended as a text editor for readers who don't already have a preference. (You can use any editor that's properly configured to run Python code.) Chapter 2 This chapter introduces removeprefix() and removesuffix() , two new methods that are helpful when working with files and URLs. Chapter 2 also includes Python's newly-improved error messages, which provide much more specific information to help you troubleshoot your code when something goes wrong. Chapters 3-9 Many explanations have been clarified, and code listings have been simplified. (There were some annotations in shorter listings that weren't really necessary.) Chapter 10 Chapter 10 uses the pathlib module for working with files. This is a much simpler approach to reading from and writing to files. It's also in keeping with how most major libraries are working with files now. Chapter 11 pytest is now the main testing library in the Python world. It's accessible to beginners, but powerful enough to serve professional testing needs as well. Chapter 11 now uses pytest instead of the standard library's unittest . This chapter shows how to install third-party libraries, instead of introducing the topic in several different projects in the second half of the book. Alien Invasion (Chapters 12-14) The game uses an FPS (frames per second) setting, to make it run more consistently across all systems. The approach to building the alien fleet is simpler and easier to understand. The code listings throughout the project are presented in an order that's easier to follow. Data Visualization (Chapters 15-17) Matplotlib has changed some of its default style settings; all figures in the new edition match the current default styles. Plotly has introduced Plotly Express, a module that focuses on building an initial plot quickly, and then making styling choices. The third edition uses this new approach. The random walk project has a small improvement that increases the accuracy of the plots; you'll see a wider variety of patterns emerge each time you generate a new walk. The weather and earthquake projects use updated data sets. The GitHub data used in Chapter 17 is fully updated. Web Applications (Chapters 18-20) The Learning Log project is built using Django 4.1, and the project is styled using Bootstrap 5. Some parts of the project have been renamed to make it easier to understand the overall layout of a Django project. The deployment section has been updated. The project is now deployed to Platform.sh, a modern hosting service for Django projects. The deployment process is controlled by YAML configuration files, which give you a great deal of control over how your project is deployed. This approach is consistent with how professional programmers deploy modern Django projects. Appendices Appendix A includes updated supplementary installation and setup instructions, for readers who run into any issues installing Python. Appendix B discusses customizations you can make to VS Code to make it more useful for writing and maintaining Python code. It also includes a number of shortcuts you can use to work more efficiently in VS Code. Appendix C includes an updated set of resources for getting help online. Appendix D uses the new git restore command for rolling back changes in a project, and the git switch command for getting back to the main branch in a project. Appendix E, which is entirely new, expands on the deployment process for web applications. Deployment is a complex process when it doesn't go perfectly. This appendix provides some guidance on how to troubleshoot deployments when they don't work the first time you try them. Index The new edition has been entirely re-indexed, to help you find what you need quickly after you've worked through the book.","title":"What's new?"},{"location":"new_in_3e/#whats-new-in-the-third-edition","text":"Python is a mature language, but like every programming language it continues to evolve. The third edition incorporates the most important new features in Python, without becoming bloated by trying to include every new feature that's been introduced in recent years. The new edition uses the latest versions of all third-party libraries in the projects section.","title":"What's new in the third edition?"},{"location":"new_in_3e/#overall-changes","text":"Here's a summary of the changes that have been made to the book overall: The third edition uses Python 3.11. (The second edition was written using Python 3.7.) The new edition uses VS Code instead of Sublime Text. VS Code is fully open, and has seen widespread adoption in the Python world over the last several years. Code listings are less cluttered and easier to follow throughout the book. The new edition uses updated libraries throughout, and updated workflows for each library.","title":"Overall changes"},{"location":"new_in_3e/#specific-changes","text":"","title":"Specific changes"},{"location":"new_in_3e/#chapter-1","text":"In the setup section, VS Code is recommended as a text editor for readers who don't already have a preference. (You can use any editor that's properly configured to run Python code.)","title":"Chapter 1"},{"location":"new_in_3e/#chapter-2","text":"This chapter introduces removeprefix() and removesuffix() , two new methods that are helpful when working with files and URLs. Chapter 2 also includes Python's newly-improved error messages, which provide much more specific information to help you troubleshoot your code when something goes wrong.","title":"Chapter 2"},{"location":"new_in_3e/#chapters-3-9","text":"Many explanations have been clarified, and code listings have been simplified. (There were some annotations in shorter listings that weren't really necessary.)","title":"Chapters 3-9"},{"location":"new_in_3e/#chapter-10","text":"Chapter 10 uses the pathlib module for working with files. This is a much simpler approach to reading from and writing to files. It's also in keeping with how most major libraries are working with files now.","title":"Chapter 10"},{"location":"new_in_3e/#chapter-11","text":"pytest is now the main testing library in the Python world. It's accessible to beginners, but powerful enough to serve professional testing needs as well. Chapter 11 now uses pytest instead of the standard library's unittest . This chapter shows how to install third-party libraries, instead of introducing the topic in several different projects in the second half of the book.","title":"Chapter 11"},{"location":"new_in_3e/#alien-invasion-chapters-12-14","text":"The game uses an FPS (frames per second) setting, to make it run more consistently across all systems. The approach to building the alien fleet is simpler and easier to understand. The code listings throughout the project are presented in an order that's easier to follow.","title":"Alien Invasion (Chapters 12-14)"},{"location":"new_in_3e/#data-visualization-chapters-15-17","text":"Matplotlib has changed some of its default style settings; all figures in the new edition match the current default styles. Plotly has introduced Plotly Express, a module that focuses on building an initial plot quickly, and then making styling choices. The third edition uses this new approach. The random walk project has a small improvement that increases the accuracy of the plots; you'll see a wider variety of patterns emerge each time you generate a new walk. The weather and earthquake projects use updated data sets. The GitHub data used in Chapter 17 is fully updated.","title":"Data Visualization (Chapters 15-17)"},{"location":"new_in_3e/#web-applications-chapters-18-20","text":"The Learning Log project is built using Django 4.1, and the project is styled using Bootstrap 5. Some parts of the project have been renamed to make it easier to understand the overall layout of a Django project. The deployment section has been updated. The project is now deployed to Platform.sh, a modern hosting service for Django projects. The deployment process is controlled by YAML configuration files, which give you a great deal of control over how your project is deployed. This approach is consistent with how professional programmers deploy modern Django projects.","title":"Web Applications (Chapters 18-20)"},{"location":"new_in_3e/#appendices","text":"Appendix A includes updated supplementary installation and setup instructions, for readers who run into any issues installing Python. Appendix B discusses customizations you can make to VS Code to make it more useful for writing and maintaining Python code. It also includes a number of shortcuts you can use to work more efficiently in VS Code. Appendix C includes an updated set of resources for getting help online. Appendix D uses the new git restore command for rolling back changes in a project, and the git switch command for getting back to the main branch in a project. Appendix E, which is entirely new, expands on the deployment process for web applications. Deployment is a complex process when it doesn't go perfectly. This appendix provides some guidance on how to troubleshoot deployments when they don't work the first time you try them.","title":"Appendices"},{"location":"new_in_3e/#index","text":"The new edition has been entirely re-indexed, to help you find what you need quickly after you've worked through the book.","title":"Index"},{"location":"newsletter/","text":"Newsletter I write a weekly newsletter about (almost) all things Python at Mostly Python . There are paid subscriptions available to support this ongoing work, but you can also sign up for a free subscription with access to all the same content. (Paid subscribers see some posts before free subscribers, but all posts end up available to everyone within 6 weeks.) Most of what I write will be meaningful to anyone who has worked through a significant portion of Python Crash Course , and is interested in current takes on a variety of topics centered around Python. My goal is to help people transition out of the beginner mindset, and keep up with things that are happening in the Python world. If you're curious to read some posts, you might want to start with one of these: Why I'm still using Python This explains why I'm still doing most of my programming work in Python, 16 years after I was first introduced to the language. Python Lists: A closer look This is the first post in a series about lists, and how a focus on this simple data structure can help people develop a deeper understanding of Python as a whole. Improving medical students' lives with code I recently spoke with a reader who's working on a project that would make it easier for medical students to conduct research. This post focuses on how to think about a larger project, once you've developed some coding skills.","title":"Newsletter"},{"location":"newsletter/#newsletter","text":"I write a weekly newsletter about (almost) all things Python at Mostly Python . There are paid subscriptions available to support this ongoing work, but you can also sign up for a free subscription with access to all the same content. (Paid subscribers see some posts before free subscribers, but all posts end up available to everyone within 6 weeks.) Most of what I write will be meaningful to anyone who has worked through a significant portion of Python Crash Course , and is interested in current takes on a variety of topics centered around Python. My goal is to help people transition out of the beginner mindset, and keep up with things that are happening in the Python world. If you're curious to read some posts, you might want to start with one of these: Why I'm still using Python This explains why I'm still doing most of my programming work in Python, 16 years after I was first introduced to the language. Python Lists: A closer look This is the first post in a series about lists, and how a focus on this simple data structure can help people develop a deeper understanding of Python as a whole. Improving medical students' lives with code I recently spoke with a reader who's working on a project that would make it easier for medical students to conduct research. This post focuses on how to think about a larger project, once you've developed some coding skills.","title":"Newsletter"},{"location":"setup_instructions/","text":"Setup Instructions Setup instructions are included in the book, but sometimes it\u2019s easier to follow online instructions with active links. The sections here also include more screenshots than what can be shown in the book.","title":"Setup Instructions"},{"location":"setup_instructions/#setup-instructions","text":"Setup instructions are included in the book, but sometimes it\u2019s easier to follow online instructions with active links. The sections here also include more screenshots than what can be shown in the book.","title":"Setup Instructions"},{"location":"setup_instructions/configuring_vs_code/","text":"Configuring VS Code VS Code is a great text editor, with some features that you'd typically see in an IDE. There are some helpful recommendations for configuring VS Code and using it efficiently in Appendix B. This section shows some of those same configuration steps, with more screenshots. Simplifying output By default, VS Code displays output in an integrated terminal . This is a terminal window that's embedded within the VS Code application. It's nice because you don't have to have a separate terminal window open to see your output, but it can be confusing because it displays a lot more information than you might want to see when you're running your first programs. For example, here's what VS Code looks like when you run hello_world.py : The output we're really interested in is the single line Hello Python world! The rest of the output shows where the file is being saved, and the path to the Python interpreter that's being used to run the program. At this point you probably just want to see the output of your program. To see just the output, do the following: Close all open tabs in VS Code, and quit VS Code. Launch VS Code again and open the folder that contains the Python files you're working on. Click the Run/ Debug icon: Click Create a launch.json File , and select the Python File option: In the configurations section, change the console setting from integratedTerminal to internalConsole : launch.json { ... \"configurations\" : [ { \"name\" : \"Python: Current File\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"${file}\" , \"console\" : \"internalConsole\" } ] } Now, run your .py file again and click on the Debug Console tab in the bottom pane. You should see just your program's output: Running programs that use input() If you made the above change to display output in the Debug Console instead of the integrated terminal window, you won't be able to run programs that use the input() function. The Debug Console is read-only, which means it doesn't accept input. When you're running programs using the input() function, which is introduced in Chapter 7, you'll need to switch back to using the integrated terminal. To do this, open the launch.json file that you created earlier, and change internalConsole back to integratedTerminal : launch.json { ... \"configurations\" : [ { \"name\" : \"Python: Current File\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"${file}\" , \"console\" : \"integratedTerminal\" } ] } Switching between the editor and the terminal When you're running programs that use input() , you'll need to switch between the editor pane where you're typing code, and the terminal where you'll enter input. You can use a mouse or a trackpad, but there's a keyboard shortcut that's really helpful. When you're finished entering code in the editor pane, press Ctrl-F5 to run your program. You'll see a prompt in the terminal pane where you can enter the input for the program. Press Ctrl-` (Control-backtick) to switch from the editor pane to the terminal pane. When you're finished entering input, press Ctrl-` again to move the cursor back to the editor window.","title":"Configuring VS Code"},{"location":"setup_instructions/configuring_vs_code/#configuring-vs-code","text":"VS Code is a great text editor, with some features that you'd typically see in an IDE. There are some helpful recommendations for configuring VS Code and using it efficiently in Appendix B. This section shows some of those same configuration steps, with more screenshots.","title":"Configuring VS Code"},{"location":"setup_instructions/configuring_vs_code/#simplifying-output","text":"By default, VS Code displays output in an integrated terminal . This is a terminal window that's embedded within the VS Code application. It's nice because you don't have to have a separate terminal window open to see your output, but it can be confusing because it displays a lot more information than you might want to see when you're running your first programs. For example, here's what VS Code looks like when you run hello_world.py : The output we're really interested in is the single line Hello Python world! The rest of the output shows where the file is being saved, and the path to the Python interpreter that's being used to run the program. At this point you probably just want to see the output of your program. To see just the output, do the following: Close all open tabs in VS Code, and quit VS Code. Launch VS Code again and open the folder that contains the Python files you're working on. Click the Run/ Debug icon: Click Create a launch.json File , and select the Python File option: In the configurations section, change the console setting from integratedTerminal to internalConsole : launch.json { ... \"configurations\" : [ { \"name\" : \"Python: Current File\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"${file}\" , \"console\" : \"internalConsole\" } ] } Now, run your .py file again and click on the Debug Console tab in the bottom pane. You should see just your program's output:","title":"Simplifying output"},{"location":"setup_instructions/configuring_vs_code/#running-programs-that-use-input","text":"If you made the above change to display output in the Debug Console instead of the integrated terminal window, you won't be able to run programs that use the input() function. The Debug Console is read-only, which means it doesn't accept input. When you're running programs using the input() function, which is introduced in Chapter 7, you'll need to switch back to using the integrated terminal. To do this, open the launch.json file that you created earlier, and change internalConsole back to integratedTerminal : launch.json { ... \"configurations\" : [ { \"name\" : \"Python: Current File\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"${file}\" , \"console\" : \"integratedTerminal\" } ] }","title":"Running programs that use input()"},{"location":"setup_instructions/configuring_vs_code/#switching-between-the-editor-and-the-terminal","text":"When you're running programs that use input() , you'll need to switch between the editor pane where you're typing code, and the terminal where you'll enter input. You can use a mouse or a trackpad, but there's a keyboard shortcut that's really helpful. When you're finished entering code in the editor pane, press Ctrl-F5 to run your program. You'll see a prompt in the terminal pane where you can enter the input for the program. Press Ctrl-` (Control-backtick) to switch from the editor pane to the terminal pane. When you're finished entering input, press Ctrl-` again to move the cursor back to the editor window.","title":"Switching between the editor and the terminal"},{"location":"solutions/","text":"Solutions Solutions for selected exercises from each chapter can be found below. Be careful about looking at the solutions too quickly; make sure you've given yourself time to wrestle with the concepts you just learned before looking at a solution. Also, there are several ways to solve many of the exercises, and the solutions only show one possible way to complete each exercise. I haven't included solutions for Chapters 18-20, because the exercises for those chapters are really projects in themselves. If you're having trouble with an exercise from one of those chapters consider posting on Stack Overflow , r/learnpython , or get in touch. Chapter 2 Chapter 3 Chapter 4 Chapter 5 Chapter 6 Chapter 7 Chapter 8 Chapter 9 Chapter 10 Chapter 11 Chapter 15 Chapter 16 Chapter 17 Questions and Feedback If you're stuck on something and what you see here isn't helping, please feel free to get in touch. Also, if you think you've found a mistake in the book or in the online resources, I'd love to know about it! Email: ehmatthes@gmail.com Twitter: @ehmatthes Mastodon: @ehmatthes@fosstodon.org","title":"Solutions"},{"location":"solutions/#solutions","text":"Solutions for selected exercises from each chapter can be found below. Be careful about looking at the solutions too quickly; make sure you've given yourself time to wrestle with the concepts you just learned before looking at a solution. Also, there are several ways to solve many of the exercises, and the solutions only show one possible way to complete each exercise. I haven't included solutions for Chapters 18-20, because the exercises for those chapters are really projects in themselves. If you're having trouble with an exercise from one of those chapters consider posting on Stack Overflow , r/learnpython , or get in touch. Chapter 2 Chapter 3 Chapter 4 Chapter 5 Chapter 6 Chapter 7 Chapter 8 Chapter 9 Chapter 10 Chapter 11 Chapter 15 Chapter 16 Chapter 17","title":"Solutions"},{"location":"solutions/#questions-and-feedback","text":"If you're stuck on something and what you see here isn't helping, please feel free to get in touch. Also, if you think you've found a mistake in the book or in the online resources, I'd love to know about it! Email: ehmatthes@gmail.com Twitter: @ehmatthes Mastodon: @ehmatthes@fosstodon.org","title":"Questions and Feedback"},{"location":"solutions/chapter_10/","text":"Solutions - Chapter 10 10-1: Learning Python Open a blank file in your text editor and write a few lines summarizing what you've learned about Python so far. Start each line with the phrase In Python you can... Save the file as learning_python.txt in the same directory as your exercises from this chapter. Write a program that reads the file and prints what you wrote two times: print the contents once by reading in the entire file, and once by storing the lines in a list and then looping over each line. learning_python.txt In Python you can store as much information as you want. In Python you can connect pieces of information. In Python you can model real-world situations. learning_python.py from pathlib import Path print ( \"--- Reading in the entire file:\" ) path = Path ( 'learning_python.txt' ) contents = path . read_text () print ( contents ) print ( \" \\n --- Looping over the lines:\" ) lines = contents . splitlines () for line in lines : print ( line ) Output: --- Reading in the entire file: In Python you can store as much information as you want. In Python you can connect pieces of information. In Python you can model real-world situations. --- Looping over the lines: In Python you can store as much information as you want. In Python you can connect pieces of information. In Python you can model real-world situations. 10-2: Learning C You can use the replace() method to replace any word in a string with a different word. Here's a quick example showing how to replace 'dog' with 'cat' in a sentence: >>> message = \"I really like dogs.\" >>> message . replace ( 'dog' , 'cat' ) 'I really like cats.' Read in each line from the file you just created, learning_python.txt , and replace the word Python with the name of another language, such as C . Print each modified line to the screen. learning_c.py from pathlib import Path path = Path ( 'learning_python.txt' ) contents = path . read_text () lines = contents . splitlines () for line in lines : line = line . replace ( 'Python' , 'C' ) print ( line ) Output: In C you can store as much information as you want. In C you can connect pieces of information. In C you can model real-world situations. 10-3: Simpler Code The program file_reader.py in this section uses a temporary variable, lines , to show how splitlines() works. You can skip the temporary variable and loop directly over the list that splitlines() returns: for line in contents.splitlines(): Remove the temporary variable from each of the programs in this section, to make them more concise. simpler_code_file_reader.py from pathlib import Path path = Path ( 'pi_digits.txt' ) contents = path . read_text () for line in contents . splitlines (): print ( line ) Output: 3.1415926535 8979323846 2643383279 simpler_code_pi_string.py from pathlib import Path path = Path ( 'pi_million_digits.txt' ) contents = path . read_text () pi_string = '' for line in contents . splitlines (): pi_string += line . lstrip () print ( f \" { pi_string [: 52 ] } ...\" ) print ( len ( pi_string )) Output: 3.14159265358979323846264338327950288419716939937510... 1000002 simpler_code_pi_birthday.py from pathlib import Path path = Path ( 'pi_million_digits.txt' ) contents = path . read_text () pi_string = '' for line in contents . splitlines (): pi_string += line . lstrip () birthday = input ( \"Enter your birthday, in the form mmddyy: \" ) if birthday in pi_string : print ( \"Your birthday appears in the first million digits of pi!\" ) else : print ( \"Your birthday does not appear in the first million digits of pi.\" ) Output: Enter your birthday, in the form mmddyy: 040122 Your birthday appears in the first million digits of pi! 10-4: Guest Write a program that prompts the user for their name. When they respond, write their name to a file called guest.txt . guest.py from pathlib import Path path = Path ( 'guest.txt' ) name = input ( \"What's your name? \" ) path . write_text ( name ) Output: What's your name? eric guest.txt eric 10-5: Guest Book Write a while loop that prompts users for their name. Collect all the names that are entered, and then write these names to a file called guest_book.txt . Make sure each entry appears on a new line in the file. guest_book.py from pathlib import Path path = Path ( 'guest_book.txt' ) prompt = \" \\n Hi, what's your name? \" prompt += \" \\n Enter 'quit' if you're the last guest. \" guest_names = [] while True : name = input ( prompt ) if name == 'quit' : break print ( f \"Thanks { name } , we'll add you to the guest book.\" ) guest_names . append ( name ) # Build a string where \"\\n\" is added after each name. file_string = '' for name in guest_names : file_string += f \" { name } \\n \" path . write_text ( file_string ) Output: Hi, what's your name? Enter 'quit' if you're the last guest. eric Thanks eric, we'll add you to the guest book. Hi, what's your name? Enter 'quit' if you're the last guest. erin Thanks erin, we'll add you to the guest book. Hi, what's your name? Enter 'quit' if you're the last guest. ever Thanks ever, we'll add you to the guest book. Hi, what's your name? Enter 'quit' if you're the last guest. willie Thanks willie, we'll add you to the guest book. Hi, what's your name? Enter 'quit' if you're the last guest. quit guest_book.txt eric erin ever willie 10-6: Addition One common problem when prompting for numerical input occurs when people provide text instead of numbers. When you try to convert the input to an int , you'll get a ValueError . Write a program that prompts for two numbers. Add them together and print the result. Catch the ValueError if either input value is not a number, and print a friendly error message. Test your program by entering two numbers and then by entering some text instead of a number. addition.py try : x = input ( \"Give me a number: \" ) x = int ( x ) y = input ( \"Give me another number: \" ) y = int ( y ) except ValueError : print ( \"Sorry, I really needed a number.\" ) else : sum = x + y print ( f \"The sum of { x } and { y } is { sum } .\" ) Output with two integers: Give me a number: 23 Give me another number: 47 The sum of 23 and 47 is 70. Output with non-numerical input: Give me a number: 23 Give me another number: fred Sorry, I really needed a number. 10-7: Addition Calculator Wrap your code from Exercise 10-6 in a while loop so the user can continue entering numbers even if they make a mistake and enter text instead of a number. addition_calculator.py print ( \"Enter 'q' at any time to quit. \\n \" ) while True : try : x = input ( \" \\n Give me a number: \" ) if x == 'q' : break x = int ( x ) y = input ( \"Give me another number: \" ) if y == 'q' : break y = int ( y ) except ValueError : print ( \"Sorry, I really needed a number.\" ) else : sum = x + y print ( f \"The sum of { x } and { y } is { sum } .\" ) Output: Enter 'q' at any time to quit. Give me a number: 23 Give me another number: 47 The sum of 23 and 47 is 70. Give me a number: three Sorry, I really needed a number. Give me a number: 3 Give me another number: five Sorry, I really needed a number. Give me a number: -12 Give me another number: 20 The sum of -12 and 20 is 8. Give me a number: q 10-8: Cats and Dogs Make two files, cats.txt and dogs.txt . Store at least three names of cats in the first file and three names of dogs in the second file. Write a program that tries to read these files and print the contents of the file to the screen. Wrap your code in a try-except block to catch the FileNotFound error, and print a friendly message if a file is missing. Move one of the files to a different location on your system, and make sure the code in the except block executes properly. cats.txt henry clarence mildred dogs.txt willie annahootz summit cats_and_dogs.py from pathlib import Path filenames = [ 'cats.txt' , 'dogs.txt' ] for filename in filenames : print ( f \" \\n Reading file: { filename } \" ) path = Path ( filename ) try : contents = path . read_text () except FileNotFoundError : print ( \" Sorry, I can't find that file.\" ) else : print ( contents ) Output with both files: Reading file: cats.txt henry clarence mildred Reading file: dogs.txt willie annahootz summit Output after moving cats.txt: Reading file: cats.txt Sorry, I can't find that file. Reading file: dogs.txt willie annahootz summit 10-9: Silent Cats and Dogs Modify your except block in Exercise 10-8 to fail silently if either file is missing. silent_cats_and_dogs.py from pathlib import Path filenames = [ 'cats.txt' , 'dogs.txt' ] for filename in filenames : path = Path ( filename ) try : contents = path . read_text () except FileNotFoundError : pass else : print ( f \" \\n Reading file: { filename } \" ) print ( contents ) Output when both files exist: Reading file: cats.txt henry clarence mildred Reading file: dogs.txt willie annahootz summit Output when cats.txt has been moved: Reading file: dogs.txt willie annahootz summit 10-10: Common Words Visit Project Gutenberg and find a few texts you'd like to analyze. Download the text files for these works, or copy the raw text from your browser into a text file on your computer. You can use the count() method to find out how many times a word or phrase appears in a string. For example, the following code counts the number of times 'row' appers in a string: >>> line = \"Row, row, row your boat\" >>> line.count('row') 2 >>> line.lower().count('row') 3 Notice that converting the string to lowercase using lower() catches all appearances of the word you're looking for, regardless of how it's formatted. Write a program that reads the files you found at Project Gutenberg and determines how many times the word 'the' appears in each text. This will be an approximation because it will also count words such as 'then' and 'there'. Try counting 'the ', with a space in the string, and see how much lower your count is. common_words.py from pathlib import Path def count_common_words ( filename , word ): \"\"\"Count how many times word appears in the text.\"\"\" # Note: This is a really simple approximation, and the number returned # will be higher than the actual count. path = Path ( filename ) try : contents = path . read_text () except FileNotFoundError : pass else : word_count = contents . lower () . count ( word ) msg = f \"' { word } ' appears in { filename } about { word_count } times.\" print ( msg ) filename = 'alice.txt' count_common_words ( filename , 'the' ) Output: 'the' appears in alice.txt about 2528 times. This solution only examines one text, but the function can be applied to any number of texts. 10-11: Favorite Number Write a program that prompts for the user's favorite number. Use json.dumps() to store this number in a file. Write a separate program that reads in this value and prints the message, \"I know your favorite number! It's _____.\" favorite_number_writer.py from pathlib import Path import json number = input ( \"What's your favorite number? \" ) path = Path ( 'favorite_number.json' ) contents = json . dumps ( number ) path . write_text ( contents ) print ( \"Thanks! I'll remember that number.\" ) Output: What's your favorite number? 42 Thanks! I'll remember that number. favorite_number_reader.py from pathlib import Path import json path = Path ( 'favorite_number.json' ) contents = path . read_text () number = json . loads ( contents ) print ( f \"I know your favorite number! It's { number } .\" ) Output: I know your favorite number! It's 42. 10-12: Favorite Number Remembered Combine the two programs from Exercise 10-11 into one file. If the number is already stored, report the favorite number to the user. If not, prompt for the user's favorite number and store it in a file. Run the program twice to see that it works. favorite_number_remembered.py from pathlib import Path import json path = Path ( 'favorite_number.json' ) try : contents = path . read_text () except FileNotFoundError : number = input ( \"What's your favorite number? \" ) contents = json . dumps ( number ) path . write_text ( contents ) print ( \"Thanks, I'll remember that.\" ) else : number = json . loads ( contents ) print ( f \"I know your favorite number! It's { number } .\" ) Output, first run: What's your favorite number? 42 Thanks, I'll remember that. Output, second run: I know your favorite number! It's 42. 10-13: User Dictionary The remember_me.py example only stores one piece of information, the username. Expand this example by asking for two more pieces of information about the user, then store all the information you collect in a dictionary. Write this dictionary to a file using json.dumps() , and read it back in using json.loads() . Print a summary showing exactly what your program remembers about the user. user_dictionary.py from pathlib import Path import json def get_stored_user_info ( path ): \"\"\"Get stored user info if available.\"\"\" if path . exists (): contents = path . read_text () user_dict = json . loads ( contents ) return user_dict else : return None def get_new_user_info ( path ): \"\"\"Get information from a new user.\"\"\" username = input ( \"What is your name? \" ) game = input ( \"What's your favorite game? \" ) animal = input ( \"What's your favorite animal? \" ) user_dict = { 'username' : username , 'game' : game , 'animal' : animal , } contents = json . dumps ( user_dict ) path . write_text ( contents ) return user_dict def greet_user (): \"\"\"Greet the user by name, and state what we know about them.\"\"\" path = Path ( 'user_info.json' ) user_dict = get_stored_user_info ( path ) if user_dict : print ( f \"Welcome back, { user_dict [ 'username' ] } !\" ) print ( f \"Hope you've been playing some { user_dict [ 'game' ] } . \" ) print ( f \"Have you seen a { user_dict [ 'animal' ] } recently?\" ) else : user_dict = get_new_user_info ( path ) msg = f \"We'll remember you when you return, { user_dict [ 'username' ] } !\" print ( msg ) greet_user () Output, first run: What is your name? eric What's your favorite game? chess What's your favorite animal? mountain goat We'll remember you when you return, eric! Output, second run: Welcome back, eric! Hope you've been playing some chess. Have you seen a mountain goat recently? 10-14: Verify User The final listing for remember_me.py assumes either that the user has already entered their username or that the program is running for the first time. We should modify it in case the current user is not the person who last used the program. Before printing a welcome back message in greet_user() , ask the user if this is the correct username. If it's not, call get_new_username() to get the correct username. verify_user.py from pathlib import Path import json def get_stored_username ( path ): \"\"\"Get stored username if available.\"\"\" if path . exists (): contents = path . read_text () username = json . loads ( contents ) return username else : return None def get_new_username ( path ): \"\"\"Prompt for a new username.\"\"\" username = input ( \"What is your name? \" ) contents = json . dumps ( username ) path . write_text ( contents ) return username def greet_user (): \"\"\"Greet the user by name.\"\"\" path = Path ( 'username.json' ) username = get_stored_username ( path ) if username : correct = input ( f \"Are you { username } ? (y/n) \" ) if correct == 'y' : print ( f \"Welcome back, { username } !\" ) else : username = get_new_username ( path ) print ( f \"We'll remember you when you come back, { username } !\" ) else : username = get_new_username ( path ) print ( f \"We'll remember you when you come back, { username } !\" ) greet_user () Output: > python verify_user.py What is your name? eric We'll remember you when you come back, eric! > python verify_user.py Are you eric? (y/n) y Welcome back, eric! > python verify_user.py Are you eric? (y/n) n What is your name? ever We'll remember you when you come back, ever! > python verify_user.py Are you ever? (y/n) y Welcome back, ever! You might notice the identical else blocks in this version of greet_user() . One way to clean this function up is to use an empty return statement. An empty return statement tells Python to leave the function without running any more code in the function. Here's a cleaner version of greet_user() : verify_user_clean.py def greet_user (): \"\"\"Greet the user by name.\"\"\" path = Path ( 'username.json' ) username = get_stored_username ( path ) if username : correct = input ( f \"Are you { username } ? (y/n) \" ) if correct == 'y' : print ( f \"Welcome back, { username } !\" ) return # We got a username, but it's not correct. # Prompt for a new username. username = get_new_username ( path ) print ( f \"We'll remember you when you come back, { username } !\" ) The return statement means the code in the function stops running after printing the welcome back message. When the username doesn't exist, or the username is incorrect, the return statement is never reached. The second part of the function will only run when the if statements fail, so we don't need an else block. Now the function prompts for a new username when either if statement fails. The only thing left to address is the nested if statements. This can be cleaned up by moving the code that checks whether the username is correct to a separate function. If you're enjoying this exercise, you might try making a new function called check_username() and see if you can remove the nested if statement from greet_user() .","title":"Chapter 10"},{"location":"solutions/chapter_10/#solutions-chapter-10","text":"","title":"Solutions - Chapter 10"},{"location":"solutions/chapter_10/#10-1-learning-python","text":"Open a blank file in your text editor and write a few lines summarizing what you've learned about Python so far. Start each line with the phrase In Python you can... Save the file as learning_python.txt in the same directory as your exercises from this chapter. Write a program that reads the file and prints what you wrote two times: print the contents once by reading in the entire file, and once by storing the lines in a list and then looping over each line. learning_python.txt In Python you can store as much information as you want. In Python you can connect pieces of information. In Python you can model real-world situations. learning_python.py from pathlib import Path print ( \"--- Reading in the entire file:\" ) path = Path ( 'learning_python.txt' ) contents = path . read_text () print ( contents ) print ( \" \\n --- Looping over the lines:\" ) lines = contents . splitlines () for line in lines : print ( line ) Output: --- Reading in the entire file: In Python you can store as much information as you want. In Python you can connect pieces of information. In Python you can model real-world situations. --- Looping over the lines: In Python you can store as much information as you want. In Python you can connect pieces of information. In Python you can model real-world situations.","title":"10-1: Learning Python"},{"location":"solutions/chapter_10/#10-2-learning-c","text":"You can use the replace() method to replace any word in a string with a different word. Here's a quick example showing how to replace 'dog' with 'cat' in a sentence: >>> message = \"I really like dogs.\" >>> message . replace ( 'dog' , 'cat' ) 'I really like cats.' Read in each line from the file you just created, learning_python.txt , and replace the word Python with the name of another language, such as C . Print each modified line to the screen. learning_c.py from pathlib import Path path = Path ( 'learning_python.txt' ) contents = path . read_text () lines = contents . splitlines () for line in lines : line = line . replace ( 'Python' , 'C' ) print ( line ) Output: In C you can store as much information as you want. In C you can connect pieces of information. In C you can model real-world situations.","title":"10-2: Learning C"},{"location":"solutions/chapter_10/#10-3-simpler-code","text":"The program file_reader.py in this section uses a temporary variable, lines , to show how splitlines() works. You can skip the temporary variable and loop directly over the list that splitlines() returns: for line in contents.splitlines(): Remove the temporary variable from each of the programs in this section, to make them more concise. simpler_code_file_reader.py from pathlib import Path path = Path ( 'pi_digits.txt' ) contents = path . read_text () for line in contents . splitlines (): print ( line ) Output: 3.1415926535 8979323846 2643383279 simpler_code_pi_string.py from pathlib import Path path = Path ( 'pi_million_digits.txt' ) contents = path . read_text () pi_string = '' for line in contents . splitlines (): pi_string += line . lstrip () print ( f \" { pi_string [: 52 ] } ...\" ) print ( len ( pi_string )) Output: 3.14159265358979323846264338327950288419716939937510... 1000002 simpler_code_pi_birthday.py from pathlib import Path path = Path ( 'pi_million_digits.txt' ) contents = path . read_text () pi_string = '' for line in contents . splitlines (): pi_string += line . lstrip () birthday = input ( \"Enter your birthday, in the form mmddyy: \" ) if birthday in pi_string : print ( \"Your birthday appears in the first million digits of pi!\" ) else : print ( \"Your birthday does not appear in the first million digits of pi.\" ) Output: Enter your birthday, in the form mmddyy: 040122 Your birthday appears in the first million digits of pi!","title":"10-3: Simpler Code"},{"location":"solutions/chapter_10/#10-4-guest","text":"Write a program that prompts the user for their name. When they respond, write their name to a file called guest.txt . guest.py from pathlib import Path path = Path ( 'guest.txt' ) name = input ( \"What's your name? \" ) path . write_text ( name ) Output: What's your name? eric guest.txt eric","title":"10-4: Guest"},{"location":"solutions/chapter_10/#10-5-guest-book","text":"Write a while loop that prompts users for their name. Collect all the names that are entered, and then write these names to a file called guest_book.txt . Make sure each entry appears on a new line in the file. guest_book.py from pathlib import Path path = Path ( 'guest_book.txt' ) prompt = \" \\n Hi, what's your name? \" prompt += \" \\n Enter 'quit' if you're the last guest. \" guest_names = [] while True : name = input ( prompt ) if name == 'quit' : break print ( f \"Thanks { name } , we'll add you to the guest book.\" ) guest_names . append ( name ) # Build a string where \"\\n\" is added after each name. file_string = '' for name in guest_names : file_string += f \" { name } \\n \" path . write_text ( file_string ) Output: Hi, what's your name? Enter 'quit' if you're the last guest. eric Thanks eric, we'll add you to the guest book. Hi, what's your name? Enter 'quit' if you're the last guest. erin Thanks erin, we'll add you to the guest book. Hi, what's your name? Enter 'quit' if you're the last guest. ever Thanks ever, we'll add you to the guest book. Hi, what's your name? Enter 'quit' if you're the last guest. willie Thanks willie, we'll add you to the guest book. Hi, what's your name? Enter 'quit' if you're the last guest. quit guest_book.txt eric erin ever willie","title":"10-5: Guest Book"},{"location":"solutions/chapter_10/#10-6-addition","text":"One common problem when prompting for numerical input occurs when people provide text instead of numbers. When you try to convert the input to an int , you'll get a ValueError . Write a program that prompts for two numbers. Add them together and print the result. Catch the ValueError if either input value is not a number, and print a friendly error message. Test your program by entering two numbers and then by entering some text instead of a number. addition.py try : x = input ( \"Give me a number: \" ) x = int ( x ) y = input ( \"Give me another number: \" ) y = int ( y ) except ValueError : print ( \"Sorry, I really needed a number.\" ) else : sum = x + y print ( f \"The sum of { x } and { y } is { sum } .\" ) Output with two integers: Give me a number: 23 Give me another number: 47 The sum of 23 and 47 is 70. Output with non-numerical input: Give me a number: 23 Give me another number: fred Sorry, I really needed a number.","title":"10-6: Addition"},{"location":"solutions/chapter_10/#10-7-addition-calculator","text":"Wrap your code from Exercise 10-6 in a while loop so the user can continue entering numbers even if they make a mistake and enter text instead of a number. addition_calculator.py print ( \"Enter 'q' at any time to quit. \\n \" ) while True : try : x = input ( \" \\n Give me a number: \" ) if x == 'q' : break x = int ( x ) y = input ( \"Give me another number: \" ) if y == 'q' : break y = int ( y ) except ValueError : print ( \"Sorry, I really needed a number.\" ) else : sum = x + y print ( f \"The sum of { x } and { y } is { sum } .\" ) Output: Enter 'q' at any time to quit. Give me a number: 23 Give me another number: 47 The sum of 23 and 47 is 70. Give me a number: three Sorry, I really needed a number. Give me a number: 3 Give me another number: five Sorry, I really needed a number. Give me a number: -12 Give me another number: 20 The sum of -12 and 20 is 8. Give me a number: q","title":"10-7: Addition Calculator"},{"location":"solutions/chapter_10/#10-8-cats-and-dogs","text":"Make two files, cats.txt and dogs.txt . Store at least three names of cats in the first file and three names of dogs in the second file. Write a program that tries to read these files and print the contents of the file to the screen. Wrap your code in a try-except block to catch the FileNotFound error, and print a friendly message if a file is missing. Move one of the files to a different location on your system, and make sure the code in the except block executes properly. cats.txt henry clarence mildred dogs.txt willie annahootz summit cats_and_dogs.py from pathlib import Path filenames = [ 'cats.txt' , 'dogs.txt' ] for filename in filenames : print ( f \" \\n Reading file: { filename } \" ) path = Path ( filename ) try : contents = path . read_text () except FileNotFoundError : print ( \" Sorry, I can't find that file.\" ) else : print ( contents ) Output with both files: Reading file: cats.txt henry clarence mildred Reading file: dogs.txt willie annahootz summit Output after moving cats.txt: Reading file: cats.txt Sorry, I can't find that file. Reading file: dogs.txt willie annahootz summit","title":"10-8: Cats and Dogs"},{"location":"solutions/chapter_10/#10-9-silent-cats-and-dogs","text":"Modify your except block in Exercise 10-8 to fail silently if either file is missing. silent_cats_and_dogs.py from pathlib import Path filenames = [ 'cats.txt' , 'dogs.txt' ] for filename in filenames : path = Path ( filename ) try : contents = path . read_text () except FileNotFoundError : pass else : print ( f \" \\n Reading file: { filename } \" ) print ( contents ) Output when both files exist: Reading file: cats.txt henry clarence mildred Reading file: dogs.txt willie annahootz summit Output when cats.txt has been moved: Reading file: dogs.txt willie annahootz summit","title":"10-9: Silent Cats and Dogs"},{"location":"solutions/chapter_10/#10-10-common-words","text":"Visit Project Gutenberg and find a few texts you'd like to analyze. Download the text files for these works, or copy the raw text from your browser into a text file on your computer. You can use the count() method to find out how many times a word or phrase appears in a string. For example, the following code counts the number of times 'row' appers in a string: >>> line = \"Row, row, row your boat\" >>> line.count('row') 2 >>> line.lower().count('row') 3 Notice that converting the string to lowercase using lower() catches all appearances of the word you're looking for, regardless of how it's formatted. Write a program that reads the files you found at Project Gutenberg and determines how many times the word 'the' appears in each text. This will be an approximation because it will also count words such as 'then' and 'there'. Try counting 'the ', with a space in the string, and see how much lower your count is. common_words.py from pathlib import Path def count_common_words ( filename , word ): \"\"\"Count how many times word appears in the text.\"\"\" # Note: This is a really simple approximation, and the number returned # will be higher than the actual count. path = Path ( filename ) try : contents = path . read_text () except FileNotFoundError : pass else : word_count = contents . lower () . count ( word ) msg = f \"' { word } ' appears in { filename } about { word_count } times.\" print ( msg ) filename = 'alice.txt' count_common_words ( filename , 'the' ) Output: 'the' appears in alice.txt about 2528 times. This solution only examines one text, but the function can be applied to any number of texts.","title":"10-10: Common Words"},{"location":"solutions/chapter_10/#10-11-favorite-number","text":"Write a program that prompts for the user's favorite number. Use json.dumps() to store this number in a file. Write a separate program that reads in this value and prints the message, \"I know your favorite number! It's _____.\" favorite_number_writer.py from pathlib import Path import json number = input ( \"What's your favorite number? \" ) path = Path ( 'favorite_number.json' ) contents = json . dumps ( number ) path . write_text ( contents ) print ( \"Thanks! I'll remember that number.\" ) Output: What's your favorite number? 42 Thanks! I'll remember that number. favorite_number_reader.py from pathlib import Path import json path = Path ( 'favorite_number.json' ) contents = path . read_text () number = json . loads ( contents ) print ( f \"I know your favorite number! It's { number } .\" ) Output: I know your favorite number! It's 42.","title":"10-11: Favorite Number"},{"location":"solutions/chapter_10/#10-12-favorite-number-remembered","text":"Combine the two programs from Exercise 10-11 into one file. If the number is already stored, report the favorite number to the user. If not, prompt for the user's favorite number and store it in a file. Run the program twice to see that it works. favorite_number_remembered.py from pathlib import Path import json path = Path ( 'favorite_number.json' ) try : contents = path . read_text () except FileNotFoundError : number = input ( \"What's your favorite number? \" ) contents = json . dumps ( number ) path . write_text ( contents ) print ( \"Thanks, I'll remember that.\" ) else : number = json . loads ( contents ) print ( f \"I know your favorite number! It's { number } .\" ) Output, first run: What's your favorite number? 42 Thanks, I'll remember that. Output, second run: I know your favorite number! It's 42.","title":"10-12: Favorite Number Remembered"},{"location":"solutions/chapter_10/#10-13-user-dictionary","text":"The remember_me.py example only stores one piece of information, the username. Expand this example by asking for two more pieces of information about the user, then store all the information you collect in a dictionary. Write this dictionary to a file using json.dumps() , and read it back in using json.loads() . Print a summary showing exactly what your program remembers about the user. user_dictionary.py from pathlib import Path import json def get_stored_user_info ( path ): \"\"\"Get stored user info if available.\"\"\" if path . exists (): contents = path . read_text () user_dict = json . loads ( contents ) return user_dict else : return None def get_new_user_info ( path ): \"\"\"Get information from a new user.\"\"\" username = input ( \"What is your name? \" ) game = input ( \"What's your favorite game? \" ) animal = input ( \"What's your favorite animal? \" ) user_dict = { 'username' : username , 'game' : game , 'animal' : animal , } contents = json . dumps ( user_dict ) path . write_text ( contents ) return user_dict def greet_user (): \"\"\"Greet the user by name, and state what we know about them.\"\"\" path = Path ( 'user_info.json' ) user_dict = get_stored_user_info ( path ) if user_dict : print ( f \"Welcome back, { user_dict [ 'username' ] } !\" ) print ( f \"Hope you've been playing some { user_dict [ 'game' ] } . \" ) print ( f \"Have you seen a { user_dict [ 'animal' ] } recently?\" ) else : user_dict = get_new_user_info ( path ) msg = f \"We'll remember you when you return, { user_dict [ 'username' ] } !\" print ( msg ) greet_user () Output, first run: What is your name? eric What's your favorite game? chess What's your favorite animal? mountain goat We'll remember you when you return, eric! Output, second run: Welcome back, eric! Hope you've been playing some chess. Have you seen a mountain goat recently?","title":"10-13: User Dictionary"},{"location":"solutions/chapter_10/#10-14-verify-user","text":"The final listing for remember_me.py assumes either that the user has already entered their username or that the program is running for the first time. We should modify it in case the current user is not the person who last used the program. Before printing a welcome back message in greet_user() , ask the user if this is the correct username. If it's not, call get_new_username() to get the correct username. verify_user.py from pathlib import Path import json def get_stored_username ( path ): \"\"\"Get stored username if available.\"\"\" if path . exists (): contents = path . read_text () username = json . loads ( contents ) return username else : return None def get_new_username ( path ): \"\"\"Prompt for a new username.\"\"\" username = input ( \"What is your name? \" ) contents = json . dumps ( username ) path . write_text ( contents ) return username def greet_user (): \"\"\"Greet the user by name.\"\"\" path = Path ( 'username.json' ) username = get_stored_username ( path ) if username : correct = input ( f \"Are you { username } ? (y/n) \" ) if correct == 'y' : print ( f \"Welcome back, { username } !\" ) else : username = get_new_username ( path ) print ( f \"We'll remember you when you come back, { username } !\" ) else : username = get_new_username ( path ) print ( f \"We'll remember you when you come back, { username } !\" ) greet_user () Output: > python verify_user.py What is your name? eric We'll remember you when you come back, eric! > python verify_user.py Are you eric? (y/n) y Welcome back, eric! > python verify_user.py Are you eric? (y/n) n What is your name? ever We'll remember you when you come back, ever! > python verify_user.py Are you ever? (y/n) y Welcome back, ever! You might notice the identical else blocks in this version of greet_user() . One way to clean this function up is to use an empty return statement. An empty return statement tells Python to leave the function without running any more code in the function. Here's a cleaner version of greet_user() : verify_user_clean.py def greet_user (): \"\"\"Greet the user by name.\"\"\" path = Path ( 'username.json' ) username = get_stored_username ( path ) if username : correct = input ( f \"Are you { username } ? (y/n) \" ) if correct == 'y' : print ( f \"Welcome back, { username } !\" ) return # We got a username, but it's not correct. # Prompt for a new username. username = get_new_username ( path ) print ( f \"We'll remember you when you come back, { username } !\" ) The return statement means the code in the function stops running after printing the welcome back message. When the username doesn't exist, or the username is incorrect, the return statement is never reached. The second part of the function will only run when the if statements fail, so we don't need an else block. Now the function prompts for a new username when either if statement fails. The only thing left to address is the nested if statements. This can be cleaned up by moving the code that checks whether the username is correct to a separate function. If you're enjoying this exercise, you might try making a new function called check_username() and see if you can remove the nested if statement from greet_user() .","title":"10-14: Verify User"},{"location":"solutions/chapter_11/","text":"Solutions - Chapter 11 11-1: City, Country Write a function that accepts two parameters: a city name and a country name. The function should return a single string of the form City, Country , such as Santiago, Chile . Store the function in a module called city_functions.py , and save this file in a new folder so pytest won\u2019t try to run the tests we\u2019ve already written. Create a file called test_cities.py that tests the function you just wrote. Write a function called test_city_country() to verify that calling your function with values such as 'santiago' and 'chile' results in the correct string. Run the test, and make sure test_city_country() passes. city_country/city_functions.py \"\"\"A collection of functions for working with cities.\"\"\" def city_country ( city , country ): \"\"\"Return a string like 'Santiago, Chile'.\"\"\" return f \" { city . title () } , { country . title () } \" Note: This is the same function we wrote in Exercise 8-6 . city_country/test_cities.py from city_functions import city_country def test_city_country (): \"\"\"Does a simple city and country pair work?\"\"\" santiago_chile = city_country ( 'santiago' , 'chile' ) assert santiago_chile == 'Santiago, Chile' Output: city_country $ pytest ============================ test session starts ============================= platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /.../solution_files/chapter_11/city_country collected 1 item test_cities.py . [100%] ============================= 1 passed in 0.01s ============================== 11-2: Population Modify your function so it requires a third parameter, population . It should now return a single string of the form City, Country - population xxx , such as Santiago, Chile - population 5000000 . Run test_cities.py again. Make sure test_city_country() fails this time. Modify the function so the population parameter is optional. Run the test, and make sure test_city_country() passes again. Write a second test called test_city_country_population() that verifies you can call your function with the values 'santiago' , 'chile' , and 'population=5000000' . Run the tests one more time, and make sure this new test passes. population/city_functions.py \"\"\"A collection of functions for working with cities.\"\"\" def city_country ( city , country , population ): \"\"\"Return a string like 'Santiago, Chile - population 5000000'.\"\"\" output_string = f \" { city . title () } , { country . title () } \" output_string += f \" -population { population } \" return output_string Output: population $ pytest ============================ test session starts ============================= platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /.../solution_files/chapter_11/population collected 1 item test_cities.py F [100%] ================================== FAILURES ================================== _____________________________ test_city_country ______________________________ def test_city_country(): \"\"\"Does a simple city and country pair work?\"\"\" > santiago_chile = city_country('santiago', 'chile') E TypeError: city_country() missing 1 required positional argument: 'population' test_cities.py:5: TypeError ========================== short test summary info =========================== FAILED test_cities.py::test_city_country - TypeError: city_country() missin... ============================= 1 failed in 0.09s ============================== population/city_functions_optional.py \"\"\"A collection of functions for working with cities.\"\"\" def city_country ( city , country , population = 0 ): \"\"\"Return a string representing a city-country pair.\"\"\" output_string = f \" { city . title () } , { country . title () } \" if population : output_string += f \" - population { population } \" return output_string Output: population $ pytest ============================ test session starts ============================= platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /.../solution_files/chapter_11/population collected 1 item test_cities.py . [100%] ============================= 1 passed in 0.01s ============================== population/test_cities.py from city_functions_pop_optional import city_country def test_city_country (): \"\"\"Does a simple city and country pair work?\"\"\" santiago_chile = city_country ( 'santiago' , 'chile' ) assert santiago_chile == 'Santiago, Chile' def test_city_country_population (): \"\"\"Can I include a population argument?\"\"\" santiago_chile = city_country ( 'santiago' , 'chile' , population = 5_000_000 ) assert santiago_chile == 'Santiago, Chile - population 5000000' Note: I have two versions of the city_functions.py module saved in the solution files, so the import statement here has changed to use the updated version of the function. Output: population $ pytest ============================ test session starts ============================= platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /.../solution_files/chapter_11/population collected 2 items test_cities.py .. [100%] ============================= 2 passed in 0.01s ============================== 11-3: Employee Write a class called Employee . The __init__() method should take in a first name, a last name, and an annual salary, and store each of these as attributes. Write a method called give_raise() that adds $5000 to the annual salary by default but also accepts a different raise amount. Write a test file for Employee with two test functions, test_give_default_raise() and test_give_custom_raise() . Write your tests once without using a fixture, and make sure they both pass. Then write a fixture so you don\u2019t have to create a new employee instance in each test function. Run the tests again, and make sure both tests still pass. employee/employee.py class Employee : \"\"\"A class to represent an employee.\"\"\" def __init__ ( self , f_name , l_name , salary ): \"\"\"Initialize the employee.\"\"\" self . first = f_name . title () self . last = l_name . title () self . salary = salary def give_raise ( self , amount = 5000 ): \"\"\"Give the employee a raise.\"\"\" self . salary += amount employee/test_employee.py from employee import Employee def test_give_default_raise (): \"\"\"Test that a default raise works correctly.\"\"\" employee = Employee ( 'eric' , 'matthes' , 65_000 ) employee . give_raise () assert employee . salary == 70_000 def test_give_custom_raise (): \"\"\"Test that a custom raise works correctly.\"\"\" employee = Employee ( 'eric' , 'matthes' , 65_000 ) employee . give_raise ( 10000 ) assert employee . salary == 75_000 Output: employee $ pytest ============================ test session starts ============================= platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /.../solution_files/chapter_11/employee collected 2 items test_employee.py .. [100%] ============================= 2 passed in 0.01s ============================== employee_with_fixture/employee.py class Employee : \"\"\"A class to represent an employee.\"\"\" def __init__ ( self , f_name , l_name , salary ): \"\"\"Initialize the employee.\"\"\" self . first = f_name . title () self . last = l_name . title () self . salary = salary def give_raise ( self , amount = 5000 ): \"\"\"Give the employee a raise.\"\"\" self . salary += amount employee_with_fixture/test_employee.py import pytest from employee import Employee @pytest . fixture def employee (): \"\"\"An Employee object that will be available to all test functions.\"\"\" employee = Employee ( 'eric' , 'matthes' , 65_000 ) return employee def test_give_default_raise ( employee ): \"\"\"Test that a default raise works correctly.\"\"\" employee . give_raise () assert employee . salary == 70_000 def test_give_custom_raise ( employee ): \"\"\"Test that a custom raise works correctly.\"\"\" employee . give_raise ( 10000 ) assert employee . salary == 75_000 Output: employee_with_fixture $ pytest ============================ test session starts ============================= platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /.../solution_files/chapter_11/employee_with_fixture collected 2 items test_employee.py .. [100%] ============================= 2 passed in 0.01s ==============================","title":"Chapter 11"},{"location":"solutions/chapter_11/#solutions-chapter-11","text":"","title":"Solutions - Chapter 11"},{"location":"solutions/chapter_11/#11-1-city-country","text":"Write a function that accepts two parameters: a city name and a country name. The function should return a single string of the form City, Country , such as Santiago, Chile . Store the function in a module called city_functions.py , and save this file in a new folder so pytest won\u2019t try to run the tests we\u2019ve already written. Create a file called test_cities.py that tests the function you just wrote. Write a function called test_city_country() to verify that calling your function with values such as 'santiago' and 'chile' results in the correct string. Run the test, and make sure test_city_country() passes. city_country/city_functions.py \"\"\"A collection of functions for working with cities.\"\"\" def city_country ( city , country ): \"\"\"Return a string like 'Santiago, Chile'.\"\"\" return f \" { city . title () } , { country . title () } \" Note: This is the same function we wrote in Exercise 8-6 . city_country/test_cities.py from city_functions import city_country def test_city_country (): \"\"\"Does a simple city and country pair work?\"\"\" santiago_chile = city_country ( 'santiago' , 'chile' ) assert santiago_chile == 'Santiago, Chile' Output: city_country $ pytest ============================ test session starts ============================= platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /.../solution_files/chapter_11/city_country collected 1 item test_cities.py . [100%] ============================= 1 passed in 0.01s ==============================","title":"11-1: City, Country"},{"location":"solutions/chapter_11/#11-2-population","text":"Modify your function so it requires a third parameter, population . It should now return a single string of the form City, Country - population xxx , such as Santiago, Chile - population 5000000 . Run test_cities.py again. Make sure test_city_country() fails this time. Modify the function so the population parameter is optional. Run the test, and make sure test_city_country() passes again. Write a second test called test_city_country_population() that verifies you can call your function with the values 'santiago' , 'chile' , and 'population=5000000' . Run the tests one more time, and make sure this new test passes. population/city_functions.py \"\"\"A collection of functions for working with cities.\"\"\" def city_country ( city , country , population ): \"\"\"Return a string like 'Santiago, Chile - population 5000000'.\"\"\" output_string = f \" { city . title () } , { country . title () } \" output_string += f \" -population { population } \" return output_string Output: population $ pytest ============================ test session starts ============================= platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /.../solution_files/chapter_11/population collected 1 item test_cities.py F [100%] ================================== FAILURES ================================== _____________________________ test_city_country ______________________________ def test_city_country(): \"\"\"Does a simple city and country pair work?\"\"\" > santiago_chile = city_country('santiago', 'chile') E TypeError: city_country() missing 1 required positional argument: 'population' test_cities.py:5: TypeError ========================== short test summary info =========================== FAILED test_cities.py::test_city_country - TypeError: city_country() missin... ============================= 1 failed in 0.09s ============================== population/city_functions_optional.py \"\"\"A collection of functions for working with cities.\"\"\" def city_country ( city , country , population = 0 ): \"\"\"Return a string representing a city-country pair.\"\"\" output_string = f \" { city . title () } , { country . title () } \" if population : output_string += f \" - population { population } \" return output_string Output: population $ pytest ============================ test session starts ============================= platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /.../solution_files/chapter_11/population collected 1 item test_cities.py . [100%] ============================= 1 passed in 0.01s ============================== population/test_cities.py from city_functions_pop_optional import city_country def test_city_country (): \"\"\"Does a simple city and country pair work?\"\"\" santiago_chile = city_country ( 'santiago' , 'chile' ) assert santiago_chile == 'Santiago, Chile' def test_city_country_population (): \"\"\"Can I include a population argument?\"\"\" santiago_chile = city_country ( 'santiago' , 'chile' , population = 5_000_000 ) assert santiago_chile == 'Santiago, Chile - population 5000000' Note: I have two versions of the city_functions.py module saved in the solution files, so the import statement here has changed to use the updated version of the function. Output: population $ pytest ============================ test session starts ============================= platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /.../solution_files/chapter_11/population collected 2 items test_cities.py .. [100%] ============================= 2 passed in 0.01s ==============================","title":"11-2: Population"},{"location":"solutions/chapter_11/#11-3-employee","text":"Write a class called Employee . The __init__() method should take in a first name, a last name, and an annual salary, and store each of these as attributes. Write a method called give_raise() that adds $5000 to the annual salary by default but also accepts a different raise amount. Write a test file for Employee with two test functions, test_give_default_raise() and test_give_custom_raise() . Write your tests once without using a fixture, and make sure they both pass. Then write a fixture so you don\u2019t have to create a new employee instance in each test function. Run the tests again, and make sure both tests still pass. employee/employee.py class Employee : \"\"\"A class to represent an employee.\"\"\" def __init__ ( self , f_name , l_name , salary ): \"\"\"Initialize the employee.\"\"\" self . first = f_name . title () self . last = l_name . title () self . salary = salary def give_raise ( self , amount = 5000 ): \"\"\"Give the employee a raise.\"\"\" self . salary += amount employee/test_employee.py from employee import Employee def test_give_default_raise (): \"\"\"Test that a default raise works correctly.\"\"\" employee = Employee ( 'eric' , 'matthes' , 65_000 ) employee . give_raise () assert employee . salary == 70_000 def test_give_custom_raise (): \"\"\"Test that a custom raise works correctly.\"\"\" employee = Employee ( 'eric' , 'matthes' , 65_000 ) employee . give_raise ( 10000 ) assert employee . salary == 75_000 Output: employee $ pytest ============================ test session starts ============================= platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /.../solution_files/chapter_11/employee collected 2 items test_employee.py .. [100%] ============================= 2 passed in 0.01s ============================== employee_with_fixture/employee.py class Employee : \"\"\"A class to represent an employee.\"\"\" def __init__ ( self , f_name , l_name , salary ): \"\"\"Initialize the employee.\"\"\" self . first = f_name . title () self . last = l_name . title () self . salary = salary def give_raise ( self , amount = 5000 ): \"\"\"Give the employee a raise.\"\"\" self . salary += amount employee_with_fixture/test_employee.py import pytest from employee import Employee @pytest . fixture def employee (): \"\"\"An Employee object that will be available to all test functions.\"\"\" employee = Employee ( 'eric' , 'matthes' , 65_000 ) return employee def test_give_default_raise ( employee ): \"\"\"Test that a default raise works correctly.\"\"\" employee . give_raise () assert employee . salary == 70_000 def test_give_custom_raise ( employee ): \"\"\"Test that a custom raise works correctly.\"\"\" employee . give_raise ( 10000 ) assert employee . salary == 75_000 Output: employee_with_fixture $ pytest ============================ test session starts ============================= platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /.../solution_files/chapter_11/employee_with_fixture collected 2 items test_employee.py .. [100%] ============================= 2 passed in 0.01s ==============================","title":"11-3: Employee"},{"location":"solutions/chapter_15/","text":"Solutions - Chapter 15 15-1: Cubes A number raised to the third power is a cube . Plot the first five cubic numbers, and then plot the first 5,000 cubic numbers. cubes_5.py import matplotlib.pyplot as plt # Define data. x_values = [ 1 , 2 , 3 , 4 , 5 ] cubes = [ 1 , 8 , 27 , 64 , 125 ] # Make plot. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . scatter ( x_values , cubes , s = 40 ) # Set chart title and label axes. ax . set_title ( \"Cubes\" , fontsize = 24 ) ax . set_xlabel ( 'Value' , fontsize = 14 ) ax . set_ylabel ( 'Cube of Value' , fontsize = 14 ) # Set size of tick labels. ax . tick_params ( axis = 'both' , labelsize = 14 ) # Show plot. plt . show () Output: Plotting 5000 cubes: cubes_5000.py import matplotlib.pyplot as plt # Define data. x_values = range ( 1 , 5001 ) y_values = [ x ** 3 for x in x_values ] # Make plot. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . scatter ( x_values , y_values , c = y_values , cmap = plt . cm . Blues , s = 10 ) # Set chart title and label axes. ax . set_title ( \"Cubes\" , fontsize = 24 ) ax . set_xlabel ( 'Value' , fontsize = 14 ) ax . set_ylabel ( 'Cube of Value' , fontsize = 14 ) # Set size of tick labels. ax . tick_params ( axis = 'both' , labelsize = 14 ) # Show plot. plt . show () Output: 15-2: Colored Cubes Apply a colormap to your cubes plot. colored_cubes.py import matplotlib.pyplot as plt # Define data. x_values = range ( 1 , 5001 ) y_values = [ x ** 3 for x in x_values ] # Make plot. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . scatter ( x_values , y_values , c = y_values , cmap = plt . cm . Blues , s = 10 ) # Set chart title and label axes. ax . set_title ( \"Cubes\" , fontsize = 24 ) ax . set_xlabel ( 'Value' , fontsize = 14 ) ax . set_ylabel ( 'Cube of Value' , fontsize = 14 ) # Set size of tick labels. ax . tick_params ( axis = 'both' , labelsize = 14 ) # Show plot. plt . show () Output: 15-3: Molecular Motion Modify rw_visual.py by replacing ax.scatter() with ax.plot() . To simulate the path of a pollen grain on the surface of a drop of water, pass in the rw.x_values and rw.y_values , and include a linewidth argument. Use 5,000 instead of 50,000 points to keep the plot from being too busy. molecular_motion.py import matplotlib.pyplot as plt from random_walk import RandomWalk # Make a random walk. rw = RandomWalk ( 5_000 ) rw . fill_walk () # Plot the points in the walk. plt . style . use ( 'classic' ) fig , ax = plt . subplots () point_numbers = range ( rw . num_points ) ax . plot ( rw . x_values , rw . y_values , linewidth = 1 ) ax . set_aspect ( 'equal' ) # Emphasize the first and last points. ax . scatter ( 0 , 0 , c = 'green' , edgecolors = 'none' , s = 100 ) ax . scatter ( rw . x_values [ - 1 ], rw . y_values [ - 1 ], c = 'red' , edgecolors = 'none' , s = 100 ) # Remove the axes. ax . get_xaxis () . set_visible ( False ) ax . get_yaxis () . set_visible ( False ) plt . show () Output: 15-5: Refactoring The fill_walk() method is lengthy. Create a new method called get_step() to determine the direction and distance for each step, and then calculate the step. You should end up with two calls to get_step() in fill_walk() : x_step = self . get_step () y_step = self . get_step () This refactoring should reduce the size of fill_walk() and make the method easier to read and understand. random_walk_refactored.py from random import choice class RandomWalk : \"\"\"A class to generate random walks.\"\"\" def __init__ ( self , num_points = 5000 ): \"\"\"Initialize attributes of a walk.\"\"\" self . num_points = num_points # All walks start at (0, 0). self . x_values = [ 0 ] self . y_values = [ 0 ] def fill_walk ( self ): \"\"\"Calculate all the points in the walk.\"\"\" # Keep taking steps until the walk reaches the desired length. while len ( self . x_values ) < self . num_points : # Decide which direction to go, and how far to go. x_step = self . get_step () y_step = self . get_step () # Reject moves that go nowhere. if x_step == 0 and y_step == 0 : continue # Calculate the new position. x = self . x_values [ - 1 ] + x_step y = self . y_values [ - 1 ] + y_step self . x_values . append ( x ) self . y_values . append ( y ) def get_step ( self ): \"\"\"Calculate a single step in the walk.\"\"\" direction = choice ([ 1 , - 1 ]) distance = choice ([ 0 , 1 , 2 , 3 , 4 ]) step = direction * distance return step 15-6: Two D8s Create a simulation showing what happens when you roll two eight-sided dice 1,000 times. Try to picture what you think the visualization will look like before you run the simulation, then see if your intuition was correct. Gradually increase the number of rolls until you start to see the limits of your system\u2019s capabilities. two_d8.py import plotly.express as px from die import Die # Create two D8s. die_1 = Die ( 8 ) die_2 = Die ( 8 ) # Make some rolls, and store results in a list. results = [] for roll_num in range ( 50_000 ): result = die_1 . roll () + die_2 . roll () results . append ( result ) # Analyze the results. frequencies = [] max_result = die_1 . num_sides + die_2 . num_sides poss_results = range ( 2 , max_result + 1 ) for value in poss_results : frequency = results . count ( value ) frequencies . append ( frequency ) # Visualize the results. title = \"Results of Rolling two D8s 50,000 Times\" labels = { 'x' : 'Result' , 'y' : 'Frequency of Result' } fig = px . bar ( x = poss_results , y = frequencies , title = title , labels = labels ) # Further customize chart. fig . update_layout ( xaxis_dtick = 1 ) fig . show () Output: 15-7: Three Dice When you roll three D6 dice, the smallest number you can roll is 3 and the largest number is 18. Create a visualization that shows what happens when you roll three D6 dice. three_dice.py import plotly.express as px from die import Die # Create three D6s. die_1 = Die () die_2 = Die () die_3 = Die () # Make some rolls, and store results in a list. results = [] for roll_num in range ( 50_000 ): result = die_1 . roll () + die_2 . roll () + die_3 . roll () results . append ( result ) # Analyze the results. frequencies = [] max_result = die_1 . num_sides + die_2 . num_sides + die_3 . num_sides poss_results = range ( 3 , max_result + 1 ) for value in poss_results : frequency = results . count ( value ) frequencies . append ( frequency ) # Visualize the results. title = \"Results of Rolling three D6s 50,000 Times\" labels = { 'x' : 'Result' , 'y' : 'Frequency of Result' } fig = px . bar ( x = poss_results , y = frequencies , title = title , labels = labels ) # Further customize chart. fig . update_layout ( xaxis_dtick = 1 ) fig . show () Output: 15-8: Multiplication When you roll two dice, you usually add the two numbers together to get the result. Create a visualization that shows what happens if you multiply these numbers by each other instead. multiplication.py import plotly.express as px from die import Die # Create two D6s. die_1 = Die () die_2 = Die () # Make some rolls, and store results in a list. results = [] for roll_num in range ( 50_000 ): result = die_1 . roll () * die_2 . roll () results . append ( result ) # Analyze the results. frequencies = [] max_result = die_1 . num_sides * die_2 . num_sides poss_results = range ( 1 , max_result + 1 ) for value in poss_results : frequency = results . count ( value ) frequencies . append ( frequency ) # Visualize the results. title = \"Results of Multiplying Two D8s 50,000 Times\" labels = { 'x' : 'Result' , 'y' : 'Frequency of Result' } fig = px . bar ( x = poss_results , y = frequencies , title = title , labels = labels ) # Further customize chart. fig . update_layout ( xaxis_dtick = 1 ) fig . show () Output: 15-9: Die Comprehensions For clarity, the listings in this section use the long form of for loops. If you\u2019re comfortable using list comprehensions, try writing a comprehension for one or both of the loops in each of these programs. die_comprehension.py import plotly.express as px from die import Die # Create a D6 and a D10. die_1 = Die () die_2 = Die ( 10 ) # Make some rolls, and store results in a list. results = [ die_1 . roll () + die_2 . roll () for roll_num in range ( 50_000 )] # Analyze the results. max_result = die_1 . num_sides + die_2 . num_sides poss_results = range ( 2 , max_result + 1 ) frequencies = [ results . count ( value ) for value in poss_results ] # Visualize the results. title = \"Results of Rolling a D6 and a D10 50,000 Times\" labels = { 'x' : 'Result' , 'y' : 'Frequency of Result' } fig = px . bar ( x = poss_results , y = frequencies , title = title , labels = labels ) # Further customize chart. fig . update_layout ( xaxis_dtick = 1 ) fig . show () Output:","title":"Chapter 15"},{"location":"solutions/chapter_15/#solutions-chapter-15","text":"","title":"Solutions - Chapter 15"},{"location":"solutions/chapter_15/#15-1-cubes","text":"A number raised to the third power is a cube . Plot the first five cubic numbers, and then plot the first 5,000 cubic numbers. cubes_5.py import matplotlib.pyplot as plt # Define data. x_values = [ 1 , 2 , 3 , 4 , 5 ] cubes = [ 1 , 8 , 27 , 64 , 125 ] # Make plot. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . scatter ( x_values , cubes , s = 40 ) # Set chart title and label axes. ax . set_title ( \"Cubes\" , fontsize = 24 ) ax . set_xlabel ( 'Value' , fontsize = 14 ) ax . set_ylabel ( 'Cube of Value' , fontsize = 14 ) # Set size of tick labels. ax . tick_params ( axis = 'both' , labelsize = 14 ) # Show plot. plt . show () Output: Plotting 5000 cubes: cubes_5000.py import matplotlib.pyplot as plt # Define data. x_values = range ( 1 , 5001 ) y_values = [ x ** 3 for x in x_values ] # Make plot. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . scatter ( x_values , y_values , c = y_values , cmap = plt . cm . Blues , s = 10 ) # Set chart title and label axes. ax . set_title ( \"Cubes\" , fontsize = 24 ) ax . set_xlabel ( 'Value' , fontsize = 14 ) ax . set_ylabel ( 'Cube of Value' , fontsize = 14 ) # Set size of tick labels. ax . tick_params ( axis = 'both' , labelsize = 14 ) # Show plot. plt . show () Output:","title":"15-1: Cubes"},{"location":"solutions/chapter_15/#15-2-colored-cubes","text":"Apply a colormap to your cubes plot. colored_cubes.py import matplotlib.pyplot as plt # Define data. x_values = range ( 1 , 5001 ) y_values = [ x ** 3 for x in x_values ] # Make plot. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . scatter ( x_values , y_values , c = y_values , cmap = plt . cm . Blues , s = 10 ) # Set chart title and label axes. ax . set_title ( \"Cubes\" , fontsize = 24 ) ax . set_xlabel ( 'Value' , fontsize = 14 ) ax . set_ylabel ( 'Cube of Value' , fontsize = 14 ) # Set size of tick labels. ax . tick_params ( axis = 'both' , labelsize = 14 ) # Show plot. plt . show () Output:","title":"15-2: Colored Cubes"},{"location":"solutions/chapter_15/#15-3-molecular-motion","text":"Modify rw_visual.py by replacing ax.scatter() with ax.plot() . To simulate the path of a pollen grain on the surface of a drop of water, pass in the rw.x_values and rw.y_values , and include a linewidth argument. Use 5,000 instead of 50,000 points to keep the plot from being too busy. molecular_motion.py import matplotlib.pyplot as plt from random_walk import RandomWalk # Make a random walk. rw = RandomWalk ( 5_000 ) rw . fill_walk () # Plot the points in the walk. plt . style . use ( 'classic' ) fig , ax = plt . subplots () point_numbers = range ( rw . num_points ) ax . plot ( rw . x_values , rw . y_values , linewidth = 1 ) ax . set_aspect ( 'equal' ) # Emphasize the first and last points. ax . scatter ( 0 , 0 , c = 'green' , edgecolors = 'none' , s = 100 ) ax . scatter ( rw . x_values [ - 1 ], rw . y_values [ - 1 ], c = 'red' , edgecolors = 'none' , s = 100 ) # Remove the axes. ax . get_xaxis () . set_visible ( False ) ax . get_yaxis () . set_visible ( False ) plt . show () Output:","title":"15-3: Molecular Motion"},{"location":"solutions/chapter_15/#15-5-refactoring","text":"The fill_walk() method is lengthy. Create a new method called get_step() to determine the direction and distance for each step, and then calculate the step. You should end up with two calls to get_step() in fill_walk() : x_step = self . get_step () y_step = self . get_step () This refactoring should reduce the size of fill_walk() and make the method easier to read and understand. random_walk_refactored.py from random import choice class RandomWalk : \"\"\"A class to generate random walks.\"\"\" def __init__ ( self , num_points = 5000 ): \"\"\"Initialize attributes of a walk.\"\"\" self . num_points = num_points # All walks start at (0, 0). self . x_values = [ 0 ] self . y_values = [ 0 ] def fill_walk ( self ): \"\"\"Calculate all the points in the walk.\"\"\" # Keep taking steps until the walk reaches the desired length. while len ( self . x_values ) < self . num_points : # Decide which direction to go, and how far to go. x_step = self . get_step () y_step = self . get_step () # Reject moves that go nowhere. if x_step == 0 and y_step == 0 : continue # Calculate the new position. x = self . x_values [ - 1 ] + x_step y = self . y_values [ - 1 ] + y_step self . x_values . append ( x ) self . y_values . append ( y ) def get_step ( self ): \"\"\"Calculate a single step in the walk.\"\"\" direction = choice ([ 1 , - 1 ]) distance = choice ([ 0 , 1 , 2 , 3 , 4 ]) step = direction * distance return step","title":"15-5: Refactoring"},{"location":"solutions/chapter_15/#15-6-two-d8s","text":"Create a simulation showing what happens when you roll two eight-sided dice 1,000 times. Try to picture what you think the visualization will look like before you run the simulation, then see if your intuition was correct. Gradually increase the number of rolls until you start to see the limits of your system\u2019s capabilities. two_d8.py import plotly.express as px from die import Die # Create two D8s. die_1 = Die ( 8 ) die_2 = Die ( 8 ) # Make some rolls, and store results in a list. results = [] for roll_num in range ( 50_000 ): result = die_1 . roll () + die_2 . roll () results . append ( result ) # Analyze the results. frequencies = [] max_result = die_1 . num_sides + die_2 . num_sides poss_results = range ( 2 , max_result + 1 ) for value in poss_results : frequency = results . count ( value ) frequencies . append ( frequency ) # Visualize the results. title = \"Results of Rolling two D8s 50,000 Times\" labels = { 'x' : 'Result' , 'y' : 'Frequency of Result' } fig = px . bar ( x = poss_results , y = frequencies , title = title , labels = labels ) # Further customize chart. fig . update_layout ( xaxis_dtick = 1 ) fig . show () Output:","title":"15-6: Two D8s"},{"location":"solutions/chapter_15/#15-7-three-dice","text":"When you roll three D6 dice, the smallest number you can roll is 3 and the largest number is 18. Create a visualization that shows what happens when you roll three D6 dice. three_dice.py import plotly.express as px from die import Die # Create three D6s. die_1 = Die () die_2 = Die () die_3 = Die () # Make some rolls, and store results in a list. results = [] for roll_num in range ( 50_000 ): result = die_1 . roll () + die_2 . roll () + die_3 . roll () results . append ( result ) # Analyze the results. frequencies = [] max_result = die_1 . num_sides + die_2 . num_sides + die_3 . num_sides poss_results = range ( 3 , max_result + 1 ) for value in poss_results : frequency = results . count ( value ) frequencies . append ( frequency ) # Visualize the results. title = \"Results of Rolling three D6s 50,000 Times\" labels = { 'x' : 'Result' , 'y' : 'Frequency of Result' } fig = px . bar ( x = poss_results , y = frequencies , title = title , labels = labels ) # Further customize chart. fig . update_layout ( xaxis_dtick = 1 ) fig . show () Output:","title":"15-7: Three Dice"},{"location":"solutions/chapter_15/#15-8-multiplication","text":"When you roll two dice, you usually add the two numbers together to get the result. Create a visualization that shows what happens if you multiply these numbers by each other instead. multiplication.py import plotly.express as px from die import Die # Create two D6s. die_1 = Die () die_2 = Die () # Make some rolls, and store results in a list. results = [] for roll_num in range ( 50_000 ): result = die_1 . roll () * die_2 . roll () results . append ( result ) # Analyze the results. frequencies = [] max_result = die_1 . num_sides * die_2 . num_sides poss_results = range ( 1 , max_result + 1 ) for value in poss_results : frequency = results . count ( value ) frequencies . append ( frequency ) # Visualize the results. title = \"Results of Multiplying Two D8s 50,000 Times\" labels = { 'x' : 'Result' , 'y' : 'Frequency of Result' } fig = px . bar ( x = poss_results , y = frequencies , title = title , labels = labels ) # Further customize chart. fig . update_layout ( xaxis_dtick = 1 ) fig . show () Output:","title":"15-8: Multiplication"},{"location":"solutions/chapter_15/#15-9-die-comprehensions","text":"For clarity, the listings in this section use the long form of for loops. If you\u2019re comfortable using list comprehensions, try writing a comprehension for one or both of the loops in each of these programs. die_comprehension.py import plotly.express as px from die import Die # Create a D6 and a D10. die_1 = Die () die_2 = Die ( 10 ) # Make some rolls, and store results in a list. results = [ die_1 . roll () + die_2 . roll () for roll_num in range ( 50_000 )] # Analyze the results. max_result = die_1 . num_sides + die_2 . num_sides poss_results = range ( 2 , max_result + 1 ) frequencies = [ results . count ( value ) for value in poss_results ] # Visualize the results. title = \"Results of Rolling a D6 and a D10 50,000 Times\" labels = { 'x' : 'Result' , 'y' : 'Frequency of Result' } fig = px . bar ( x = poss_results , y = frequencies , title = title , labels = labels ) # Further customize chart. fig . update_layout ( xaxis_dtick = 1 ) fig . show () Output:","title":"15-9: Die Comprehensions"},{"location":"solutions/chapter_16/","text":"Solutions - Chapter 16 16-1: Sitka Rainfall Sitka is located in a temperate rainforest, so it gets a fair amount of rainfall. In the data file sitka_weather_2021_full.csv is a header called PRCP , which represents daily rainfall amounts. Make a visualization focusing on the data in this column. You can repeat the exercise for Death Valley if you\u2019re curious how little rainfall occurs in a desert. sitka_rainfall.py from pathlib import Path import csv from datetime import datetime import matplotlib.pyplot as plt path = Path ( 'weather_data/sitka_weather_2021_full.csv' ) lines = path . read_text () . splitlines () reader = csv . reader ( lines ) header_row = next ( reader ) # Extract dates and rainfall amounts dates , precips = [], [] for row in reader : current_date = datetime . strptime ( row [ 2 ], '%Y-%m- %d ' ) precip = float ( row [ 5 ]) dates . append ( current_date ) precips . append ( precip ) # Plot the high temperatures. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . bar ( dates , precips , color = 'blue' ) # Format plot. ax . set_title ( \"Daily Precipitation, 2021\" , fontsize = 24 ) ax . set_xlabel ( '' , fontsize = 16 ) fig . autofmt_xdate () ax . set_ylabel ( \"Precipitation Amount (in)\" , fontsize = 16 ) ax . tick_params ( labelsize = 16 ) plt . show () Output: 16-2: Sitka\u2013Death Valley Comparison The temperature scales on the Sitka and Death Valley graphs reflect the different data ranges. To accurately compare the temperature range in Sitka to that of Death Valley, you need identical scales on the y-axis. Change the settings for the y-axis on one or both of the charts in Figures 16-5 and 16-6. Then make a direct comparison between temperature ranges in Sitka and Death Valley (or any two places you want to compare). The set_ylim() method allows you to set the limits of just the y-axis. If you ever need to specify the limits of the x-axis, there\u2019s a corresponding set_xlim() function as well. sitka_highs_lows_comparison.py from pathlib import Path import csv from datetime import datetime import matplotlib.pyplot as plt path = Path ( 'weather_data/sitka_weather_2021_simple.csv' ) lines = path . read_text () . splitlines () reader = csv . reader ( lines ) header_row = next ( reader ) # Extract dates, and high and low temperatures. dates , highs , lows = [], [], [] for row in reader : current_date = datetime . strptime ( row [ 2 ], '%Y-%m- %d ' ) high = int ( row [ 4 ]) low = int ( row [ 5 ]) dates . append ( current_date ) highs . append ( high ) lows . append ( low ) # Plot the high and low temperatures. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . plot ( dates , highs , color = 'red' , alpha = 0.5 ) ax . plot ( dates , lows , color = 'blue' , alpha = 0.5 ) ax . fill_between ( dates , highs , lows , facecolor = 'blue' , alpha = 0.1 ) # Format plot. ax . set_title ( \"Daily High and Low Temperatures, 2021\" , fontsize = 24 ) ax . set_xlabel ( '' , fontsize = 16 ) fig . autofmt_xdate () ax . set_ylabel ( \"Temperature (F)\" , fontsize = 16 ) ax . tick_params ( labelsize = 16 ) ax . set_ylim ( 10 , 140 ) plt . show () Output: Using the same limits for the ylim() method with the Death Valley data results in a chart that has the same scale: There are a number of ways you can approach plotting both data sets on the same chart. In the following solution, we put the code for reading the csv file into a function. We then call it once to grab the highs and lows for Sitka before making the chart, and then call the function a second time to add Death Valley\u2019s data to the existing plot. The colors have been adjusted slightly to make each location\u2019s data distinct. sitka_death_valley_comparison.py from pathlib import Path import csv from datetime import datetime import matplotlib.pyplot as plt def get_weather_data ( path , dates , highs , lows , date_index , high_index , low_index ): \"\"\"Get the highs and lows from a data file.\"\"\" lines = path . read_text () . splitlines () reader = csv . reader ( lines ) header_row = next ( reader ) # Extract dates, and high and low temperatures. for row in reader : current_date = datetime . strptime ( row [ date_index ], '%Y-%m- %d ' ) try : high = int ( row [ high_index ]) low = int ( row [ low_index ]) except ValueError : print ( f \"Missing data for { current_date } \" ) else : dates . append ( current_date ) highs . append ( high ) lows . append ( low ) # Get weather data for Sitka. path = Path ( 'weather_data/sitka_weather_2021_simple.csv' ) dates , highs , lows = [], [], [] get_weather_data ( path , dates , highs , lows , date_index = 2 , high_index = 4 , low_index = 5 ) # Plot weather data for Sitka. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . plot ( dates , highs , color = 'red' , alpha = 0.6 ) ax . plot ( dates , lows , color = 'blue' , alpha = 0.6 ) ax . fill_between ( dates , highs , lows , facecolor = 'blue' , alpha = 0.15 ) # Get weather data for Death Valley. path = Path ( 'weather_data/death_valley_2021_simple.csv' ) dates , highs , lows = [], [], [] get_weather_data ( path , dates , highs , lows , date_index = 2 , high_index = 3 , low_index = 4 ) # Add Death Valley weather data to current plot. ax . plot ( dates , highs , color = 'red' , alpha = 0.3 ) ax . plot ( dates , lows , color = 'blue' , alpha = 0.3 ) ax . fill_between ( dates , highs , lows , facecolor = 'blue' , alpha = 0.05 ) # Format plot. title = \"Daily high and low temperatures - 2021\" title += \" \\n Sitka, AK and Death Valley, CA\" ax . set_title ( title , fontsize = 24 ) ax . set_xlabel ( '' , fontsize = 16 ) fig . autofmt_xdate () ax . set_ylabel ( \"Temperature (F)\" , fontsize = 16 ) ax . tick_params ( labelsize = 16 ) ax . set_ylim ( 10 , 140 ) plt . show () Output: 16-4: Automatic Indexes In this section, we hardcoded the indexes corresponding to the TMIN and TMAX columns. Use the header row to determine the indexes for these values, so your program can work for Sitka or Death Valley. Use the station name to automatically generate an appropriate title for your graph as well. The index() method returns the index of an item in a list. For example: >>> animals = ['cat', 'dog', 'mouse', 'elephant'] >>> animals.index('dog') 1 This can help us pull the indexes of the headers we want from the header row: automatic_indexes.py from pathlib import Path import csv from datetime import datetime import matplotlib.pyplot as plt path = Path ( 'weather_data/death_valley_2021_simple.csv' ) lines = path . read_text () . splitlines () reader = csv . reader ( lines ) header_row = next ( reader ) date_index = header_row . index ( 'DATE' ) high_index = header_row . index ( 'TMAX' ) low_index = header_row . index ( 'TMIN' ) name_index = header_row . index ( 'NAME' ) # Extract dates, and high and low temperatures. dates , highs , lows = [], [], [] place_name = \"\" for row in reader : # Grab the station name, if it's not already set. if not place_name : place_name = row [ name_index ] current_date = datetime . strptime ( row [ date_index ], '%Y-%m- %d ' ) try : high = int ( row [ high_index ]) low = int ( row [ low_index ]) except ValueError : print ( f \"Missing data for { current_date } \" ) else : dates . append ( current_date ) highs . append ( high ) lows . append ( low ) # Plot the high and low temperatures. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . plot ( dates , highs , color = 'red' , alpha = 0.5 ) ax . plot ( dates , lows , color = 'blue' , alpha = 0.5 ) ax . fill_between ( dates , highs , lows , facecolor = 'blue' , alpha = 0.1 ) # Format plot. title = f \"Daily High and Low Temperatures, 2021 \\n { place_name } \" ax . set_title ( title , fontsize = 20 ) fig . autofmt_xdate () ax . set_ylabel ( \"Temperature (F)\" , fontsize = 16 ) ax . tick_params ( labelsize = 16 ) plt . show () Output: 16-6: Refactoring The loop that pulls data from all_eq_dicts uses variables for the magnitude, longitude, latitude, and title of each earthquake before appending these values to their appropriate lists. This approach was chosen for clarity in how to pull data from a GeoJSON file, but it\u2019s not necessary in your code. Instead of using these temporary variables, pull each value from eq_dict and append it to the appropriate list in one line. Doing so should shorten the body of this loop to just four lines. eq_world_map_refactored.py from pathlib import Path import json import plotly.express as px # Read data as a string and convert to a Python object. path = Path ( 'eq_data/eq_data_30_day_m1.geojson' ) contents = path . read_text () all_eq_data = json . loads ( contents ) # Examine all earthquakes in the dataset. all_eq_dicts = all_eq_data [ 'features' ] mags , lons , lats , eq_titles = [], [], [], [] for eq_dict in all_eq_dicts : mags . append ( eq_dict [ 'properties' ][ 'mag' ]) lons . append ( eq_dict [ 'geometry' ][ 'coordinates' ][ 0 ]) lats . append ( eq_dict [ 'geometry' ][ 'coordinates' ][ 1 ]) eq_titles . append ( eq_dict [ 'properties' ][ 'title' ]) title = 'Global Earthquakes' fig = px . scatter_geo ( lat = lats , lon = lons , size = mags , title = title , color = mags , color_continuous_scale = 'Viridis' , labels = { 'color' : 'Magnitude' }, projection = 'natural earth' , hover_name = eq_titles , ) fig . show () Output: 16-6: Automated Title In this section, we used the generic title Global Earthquakes . Instead, you can use the title for the dataset in the metadata part of the GeoJSON file. Pull this value and assign it to the variable title. eq_world_map_automated_title.py from pathlib import Path import json import plotly.express as px # Read data as a string and convert to a Python object. path = Path ( 'eq_data/eq_data_30_day_m1.geojson' ) contents = path . read_text () all_eq_data = json . loads ( contents ) # Examine all earthquakes in the dataset. title = all_eq_data [ 'metadata' ][ 'title' ] all_eq_dicts = all_eq_data [ 'features' ] mags , lons , lats , eq_titles = [], [], [], [] for eq_dict in all_eq_dicts : mags . append ( eq_dict [ 'properties' ][ 'mag' ]) lons . append ( eq_dict [ 'geometry' ][ 'coordinates' ][ 0 ]) lats . append ( eq_dict [ 'geometry' ][ 'coordinates' ][ 1 ]) eq_titles . append ( eq_dict [ 'properties' ][ 'title' ]) fig = px . scatter_geo ( lat = lats , lon = lons , size = mags , title = title , color = mags , color_continuous_scale = 'Viridis' , labels = { 'color' : 'Magnitude' }, projection = 'natural earth' , hover_name = eq_titles , ) fig . show () Output: 16-9: World Fires In the resources for this chapter, you\u2019ll find a file called world_fires_1_day.csv . This file contains information about fires burning in different locations around the globe, including the latitude, longitude, and brightness of each fire. Using the data-processing work from the first part of this chapter and the mapping work from this section, make a map that shows which parts of the world are affected by fires. You can download more recent versions of this data at https://earthdata.nasa.gov/earth-observation-data/near-real-time/firms/active-fire-data . You can find links to the data in CSV format in the SHP, KML, and TXT Files section. Note: Global fire activity can be highly variable, so the size of this dataset can vary widely depending on when you happen to download it. Using all of the data may slow your system down too much. If that happens, make a copy of the original data file but only keep the first 5,000 rows, or however many rows your system can handle in a reasonable amount of processing time. world_fires.py from pathlib import Path import csv import plotly.express as px path = Path ( 'eq_data/world_fires_1_day.csv' ) lines = path . read_text () . splitlines () reader = csv . reader ( lines ) header_row = next ( reader ) # Extract lat, lon, brightness lats , lons , brights = [], [], [] for row in reader : try : lat = float ( row [ 0 ]) lon = float ( row [ 1 ]) bright = float ( row [ 2 ]) except ValueError : # Show raw date information for invalid rows. print ( f \"Invalid data for { row [ 5 ] } \" ) else : lats . append ( lat ) lons . append ( lon ) brights . append ( bright ) # Plot brightnesses on a world map. title = \"Global wildfire activity\" fig = px . scatter_geo ( lat = lats , lon = lons , size = brights , title = title , color = brights , color_continuous_scale = 'Viridis' , labels = { 'color' : 'Brightness' }, projection = 'natural earth' , ) fig . show () Output:","title":"Chapter 16"},{"location":"solutions/chapter_16/#solutions-chapter-16","text":"","title":"Solutions - Chapter 16"},{"location":"solutions/chapter_16/#16-1-sitka-rainfall","text":"Sitka is located in a temperate rainforest, so it gets a fair amount of rainfall. In the data file sitka_weather_2021_full.csv is a header called PRCP , which represents daily rainfall amounts. Make a visualization focusing on the data in this column. You can repeat the exercise for Death Valley if you\u2019re curious how little rainfall occurs in a desert. sitka_rainfall.py from pathlib import Path import csv from datetime import datetime import matplotlib.pyplot as plt path = Path ( 'weather_data/sitka_weather_2021_full.csv' ) lines = path . read_text () . splitlines () reader = csv . reader ( lines ) header_row = next ( reader ) # Extract dates and rainfall amounts dates , precips = [], [] for row in reader : current_date = datetime . strptime ( row [ 2 ], '%Y-%m- %d ' ) precip = float ( row [ 5 ]) dates . append ( current_date ) precips . append ( precip ) # Plot the high temperatures. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . bar ( dates , precips , color = 'blue' ) # Format plot. ax . set_title ( \"Daily Precipitation, 2021\" , fontsize = 24 ) ax . set_xlabel ( '' , fontsize = 16 ) fig . autofmt_xdate () ax . set_ylabel ( \"Precipitation Amount (in)\" , fontsize = 16 ) ax . tick_params ( labelsize = 16 ) plt . show () Output:","title":"16-1: Sitka Rainfall"},{"location":"solutions/chapter_16/#16-2-sitkadeath-valley-comparison","text":"The temperature scales on the Sitka and Death Valley graphs reflect the different data ranges. To accurately compare the temperature range in Sitka to that of Death Valley, you need identical scales on the y-axis. Change the settings for the y-axis on one or both of the charts in Figures 16-5 and 16-6. Then make a direct comparison between temperature ranges in Sitka and Death Valley (or any two places you want to compare). The set_ylim() method allows you to set the limits of just the y-axis. If you ever need to specify the limits of the x-axis, there\u2019s a corresponding set_xlim() function as well. sitka_highs_lows_comparison.py from pathlib import Path import csv from datetime import datetime import matplotlib.pyplot as plt path = Path ( 'weather_data/sitka_weather_2021_simple.csv' ) lines = path . read_text () . splitlines () reader = csv . reader ( lines ) header_row = next ( reader ) # Extract dates, and high and low temperatures. dates , highs , lows = [], [], [] for row in reader : current_date = datetime . strptime ( row [ 2 ], '%Y-%m- %d ' ) high = int ( row [ 4 ]) low = int ( row [ 5 ]) dates . append ( current_date ) highs . append ( high ) lows . append ( low ) # Plot the high and low temperatures. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . plot ( dates , highs , color = 'red' , alpha = 0.5 ) ax . plot ( dates , lows , color = 'blue' , alpha = 0.5 ) ax . fill_between ( dates , highs , lows , facecolor = 'blue' , alpha = 0.1 ) # Format plot. ax . set_title ( \"Daily High and Low Temperatures, 2021\" , fontsize = 24 ) ax . set_xlabel ( '' , fontsize = 16 ) fig . autofmt_xdate () ax . set_ylabel ( \"Temperature (F)\" , fontsize = 16 ) ax . tick_params ( labelsize = 16 ) ax . set_ylim ( 10 , 140 ) plt . show () Output: Using the same limits for the ylim() method with the Death Valley data results in a chart that has the same scale: There are a number of ways you can approach plotting both data sets on the same chart. In the following solution, we put the code for reading the csv file into a function. We then call it once to grab the highs and lows for Sitka before making the chart, and then call the function a second time to add Death Valley\u2019s data to the existing plot. The colors have been adjusted slightly to make each location\u2019s data distinct. sitka_death_valley_comparison.py from pathlib import Path import csv from datetime import datetime import matplotlib.pyplot as plt def get_weather_data ( path , dates , highs , lows , date_index , high_index , low_index ): \"\"\"Get the highs and lows from a data file.\"\"\" lines = path . read_text () . splitlines () reader = csv . reader ( lines ) header_row = next ( reader ) # Extract dates, and high and low temperatures. for row in reader : current_date = datetime . strptime ( row [ date_index ], '%Y-%m- %d ' ) try : high = int ( row [ high_index ]) low = int ( row [ low_index ]) except ValueError : print ( f \"Missing data for { current_date } \" ) else : dates . append ( current_date ) highs . append ( high ) lows . append ( low ) # Get weather data for Sitka. path = Path ( 'weather_data/sitka_weather_2021_simple.csv' ) dates , highs , lows = [], [], [] get_weather_data ( path , dates , highs , lows , date_index = 2 , high_index = 4 , low_index = 5 ) # Plot weather data for Sitka. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . plot ( dates , highs , color = 'red' , alpha = 0.6 ) ax . plot ( dates , lows , color = 'blue' , alpha = 0.6 ) ax . fill_between ( dates , highs , lows , facecolor = 'blue' , alpha = 0.15 ) # Get weather data for Death Valley. path = Path ( 'weather_data/death_valley_2021_simple.csv' ) dates , highs , lows = [], [], [] get_weather_data ( path , dates , highs , lows , date_index = 2 , high_index = 3 , low_index = 4 ) # Add Death Valley weather data to current plot. ax . plot ( dates , highs , color = 'red' , alpha = 0.3 ) ax . plot ( dates , lows , color = 'blue' , alpha = 0.3 ) ax . fill_between ( dates , highs , lows , facecolor = 'blue' , alpha = 0.05 ) # Format plot. title = \"Daily high and low temperatures - 2021\" title += \" \\n Sitka, AK and Death Valley, CA\" ax . set_title ( title , fontsize = 24 ) ax . set_xlabel ( '' , fontsize = 16 ) fig . autofmt_xdate () ax . set_ylabel ( \"Temperature (F)\" , fontsize = 16 ) ax . tick_params ( labelsize = 16 ) ax . set_ylim ( 10 , 140 ) plt . show () Output:","title":"16-2: Sitka\u2013Death Valley Comparison"},{"location":"solutions/chapter_16/#16-4-automatic-indexes","text":"In this section, we hardcoded the indexes corresponding to the TMIN and TMAX columns. Use the header row to determine the indexes for these values, so your program can work for Sitka or Death Valley. Use the station name to automatically generate an appropriate title for your graph as well. The index() method returns the index of an item in a list. For example: >>> animals = ['cat', 'dog', 'mouse', 'elephant'] >>> animals.index('dog') 1 This can help us pull the indexes of the headers we want from the header row: automatic_indexes.py from pathlib import Path import csv from datetime import datetime import matplotlib.pyplot as plt path = Path ( 'weather_data/death_valley_2021_simple.csv' ) lines = path . read_text () . splitlines () reader = csv . reader ( lines ) header_row = next ( reader ) date_index = header_row . index ( 'DATE' ) high_index = header_row . index ( 'TMAX' ) low_index = header_row . index ( 'TMIN' ) name_index = header_row . index ( 'NAME' ) # Extract dates, and high and low temperatures. dates , highs , lows = [], [], [] place_name = \"\" for row in reader : # Grab the station name, if it's not already set. if not place_name : place_name = row [ name_index ] current_date = datetime . strptime ( row [ date_index ], '%Y-%m- %d ' ) try : high = int ( row [ high_index ]) low = int ( row [ low_index ]) except ValueError : print ( f \"Missing data for { current_date } \" ) else : dates . append ( current_date ) highs . append ( high ) lows . append ( low ) # Plot the high and low temperatures. plt . style . use ( 'seaborn-v0_8' ) fig , ax = plt . subplots () ax . plot ( dates , highs , color = 'red' , alpha = 0.5 ) ax . plot ( dates , lows , color = 'blue' , alpha = 0.5 ) ax . fill_between ( dates , highs , lows , facecolor = 'blue' , alpha = 0.1 ) # Format plot. title = f \"Daily High and Low Temperatures, 2021 \\n { place_name } \" ax . set_title ( title , fontsize = 20 ) fig . autofmt_xdate () ax . set_ylabel ( \"Temperature (F)\" , fontsize = 16 ) ax . tick_params ( labelsize = 16 ) plt . show () Output:","title":"16-4: Automatic Indexes"},{"location":"solutions/chapter_16/#16-6-refactoring","text":"The loop that pulls data from all_eq_dicts uses variables for the magnitude, longitude, latitude, and title of each earthquake before appending these values to their appropriate lists. This approach was chosen for clarity in how to pull data from a GeoJSON file, but it\u2019s not necessary in your code. Instead of using these temporary variables, pull each value from eq_dict and append it to the appropriate list in one line. Doing so should shorten the body of this loop to just four lines. eq_world_map_refactored.py from pathlib import Path import json import plotly.express as px # Read data as a string and convert to a Python object. path = Path ( 'eq_data/eq_data_30_day_m1.geojson' ) contents = path . read_text () all_eq_data = json . loads ( contents ) # Examine all earthquakes in the dataset. all_eq_dicts = all_eq_data [ 'features' ] mags , lons , lats , eq_titles = [], [], [], [] for eq_dict in all_eq_dicts : mags . append ( eq_dict [ 'properties' ][ 'mag' ]) lons . append ( eq_dict [ 'geometry' ][ 'coordinates' ][ 0 ]) lats . append ( eq_dict [ 'geometry' ][ 'coordinates' ][ 1 ]) eq_titles . append ( eq_dict [ 'properties' ][ 'title' ]) title = 'Global Earthquakes' fig = px . scatter_geo ( lat = lats , lon = lons , size = mags , title = title , color = mags , color_continuous_scale = 'Viridis' , labels = { 'color' : 'Magnitude' }, projection = 'natural earth' , hover_name = eq_titles , ) fig . show () Output:","title":"16-6: Refactoring"},{"location":"solutions/chapter_16/#16-6-automated-title","text":"In this section, we used the generic title Global Earthquakes . Instead, you can use the title for the dataset in the metadata part of the GeoJSON file. Pull this value and assign it to the variable title. eq_world_map_automated_title.py from pathlib import Path import json import plotly.express as px # Read data as a string and convert to a Python object. path = Path ( 'eq_data/eq_data_30_day_m1.geojson' ) contents = path . read_text () all_eq_data = json . loads ( contents ) # Examine all earthquakes in the dataset. title = all_eq_data [ 'metadata' ][ 'title' ] all_eq_dicts = all_eq_data [ 'features' ] mags , lons , lats , eq_titles = [], [], [], [] for eq_dict in all_eq_dicts : mags . append ( eq_dict [ 'properties' ][ 'mag' ]) lons . append ( eq_dict [ 'geometry' ][ 'coordinates' ][ 0 ]) lats . append ( eq_dict [ 'geometry' ][ 'coordinates' ][ 1 ]) eq_titles . append ( eq_dict [ 'properties' ][ 'title' ]) fig = px . scatter_geo ( lat = lats , lon = lons , size = mags , title = title , color = mags , color_continuous_scale = 'Viridis' , labels = { 'color' : 'Magnitude' }, projection = 'natural earth' , hover_name = eq_titles , ) fig . show () Output:","title":"16-6: Automated Title"},{"location":"solutions/chapter_16/#16-9-world-fires","text":"In the resources for this chapter, you\u2019ll find a file called world_fires_1_day.csv . This file contains information about fires burning in different locations around the globe, including the latitude, longitude, and brightness of each fire. Using the data-processing work from the first part of this chapter and the mapping work from this section, make a map that shows which parts of the world are affected by fires. You can download more recent versions of this data at https://earthdata.nasa.gov/earth-observation-data/near-real-time/firms/active-fire-data . You can find links to the data in CSV format in the SHP, KML, and TXT Files section. Note: Global fire activity can be highly variable, so the size of this dataset can vary widely depending on when you happen to download it. Using all of the data may slow your system down too much. If that happens, make a copy of the original data file but only keep the first 5,000 rows, or however many rows your system can handle in a reasonable amount of processing time. world_fires.py from pathlib import Path import csv import plotly.express as px path = Path ( 'eq_data/world_fires_1_day.csv' ) lines = path . read_text () . splitlines () reader = csv . reader ( lines ) header_row = next ( reader ) # Extract lat, lon, brightness lats , lons , brights = [], [], [] for row in reader : try : lat = float ( row [ 0 ]) lon = float ( row [ 1 ]) bright = float ( row [ 2 ]) except ValueError : # Show raw date information for invalid rows. print ( f \"Invalid data for { row [ 5 ] } \" ) else : lats . append ( lat ) lons . append ( lon ) brights . append ( bright ) # Plot brightnesses on a world map. title = \"Global wildfire activity\" fig = px . scatter_geo ( lat = lats , lon = lons , size = brights , title = title , color = brights , color_continuous_scale = 'Viridis' , labels = { 'color' : 'Brightness' }, projection = 'natural earth' , ) fig . show () Output:","title":"16-9: World Fires"},{"location":"solutions/chapter_17/","text":"Solutions - Chapter 17 17-1: Other Languages Modify the API call in python_repos.py so it generates a chart showing the most popular projects in other languages. Try languages such as JavaScript , Ruby , C , Java , Perl , Haskell , and Go . javascript_repos.py import requests import plotly.express as px # Make an API call and check the response. url = \"https://api.github.com/search/repositories\" url += \"?q=language:javascript+sort:stars+stars:>10000\" headers = { \"Accept\" : \"application/vnd.github.v3+json\" } r = requests . get ( url , headers = headers ) print ( f \"Status code: { r . status_code } \" ) # Process overall results. response_dict = r . json () print ( f \"Complete results: { not response_dict [ 'incomplete_results' ] } \" ) # Process repository information. repo_dicts = response_dict [ 'items' ] repo_links , stars , hover_texts = [], [], [] for repo_dict in repo_dicts : # Turn repo names into active links. repo_name = repo_dict [ 'name' ] repo_url = repo_dict [ 'html_url' ] repo_link = f \"<a href=' { repo_url } '> { repo_name } </a>\" repo_links . append ( repo_link ) stars . append ( repo_dict [ 'stargazers_count' ]) # Build hover texts. owner = repo_dict [ 'owner' ][ 'login' ] description = repo_dict [ 'description' ] hover_text = f \" { owner } <br /> { description } \" hover_texts . append ( hover_text ) # Make visualization. title = \"Most-Starred JavaScript Projects on GitHub\" labels = { 'x' : 'Repository' , 'y' : 'Stars' } fig = px . bar ( x = repo_links , y = stars , title = title , labels = labels , hover_name = hover_texts ) fig . update_layout ( title_font_size = 28 , xaxis_title_font_size = 20 , yaxis_title_font_size = 20 ) fig . update_traces ( marker_color = 'SteelBlue' , marker_opacity = 0.6 ) fig . show () Output: 17-2: Active Discussions Using the data from hn_submissions.py , make a bar chart showing the most active discussions currently happening on Hacker News. The height of each bar should correspond to the number of comments each submission has. The label for each bar should include the submission\u2019s title and act as a link to the discussion page for that submission. If you get a KeyError when creating a chart, use a try-except block to skip over the promotional posts. hn_discussions_visual.py from operator import itemgetter import requests import plotly.express as px # Make an API call and check the response. url = 'https://hacker-news.firebaseio.com/v0/topstories.json' r = requests . get ( url ) print ( f \"Status code: { r . status_code } \" ) # Process information about each submission. submission_ids = r . json () submission_dicts = [] for submission_id in submission_ids [: 20 ]: # Make a new API call for each submission. url = f \"https://hacker-news.firebaseio.com/v0/item/ { submission_id } .json\" r = requests . get ( url ) print ( f \"id: { submission_id } \\t status: { r . status_code } \" ) response_dict = r . json () # Build a dictionary for each article. try : submission_dict = { 'title' : response_dict [ 'title' ], 'hn_link' : f \"https://news.ycombinator.com/item?id= { submission_id } \" , 'comments' : response_dict [ 'descendants' ], } except KeyError : # This is a special YC post with comments disabled. continue else : submission_dicts . append ( submission_dict ) submission_dicts = sorted ( submission_dicts , key = itemgetter ( 'comments' ), reverse = True ) # Process data for plotting. article_links , comment_counts , hover_texts = [], [], [] for submission_dict in submission_dicts : # Shorten long article titles. title = submission_dict [ 'title' ][: 30 ] discussion_link = submission_dict [ 'hn_link' ] article_link = f '<a href=\" { discussion_link } \"\"> { title } </a>' comment_count = submission_dict [ 'comments' ] article_links . append ( article_link ) comment_counts . append ( comment_count ) # Show the full title on hover. hover_texts . append ( submission_dict [ 'title' ]) # Make visualization. title = \"Most active discussions on Hacker News\" labels = { 'x' : 'Article' , 'y' : 'Comment count' } fig = px . bar ( x = article_links , y = comment_counts , title = title , labels = labels , hover_name = hover_texts ) fig . update_layout ( title_font_size = 28 , xaxis_title_font_size = 20 , yaxis_title_font_size = 20 ) fig . update_traces ( marker_color = 'SteelBlue' , marker_opacity = 0.6 ) fig . show () Output: 17-3 Testing python_repos.py In python_repos.py , we printed the value of status_code to make sure the API call was successful. Write a program called test_python_repos.py that uses pytest to assert that the value of status_code is 200. Figure out some other assertions you can make: for example, that the number of items returned is expected and that the total number of repositories is greater than a certain amount. Note: It's much easier to test a program that's broken up into functions or classes. So this solution actually has three parts: a version of python_repos.py that uses functions to do its work, a simpler test file, and a test file that uses fixtures. python_repos_tested.py import requests def get_repos_info (): \"\"\"Get information about Python repositories on GitHub.\"\"\" # Make an API call and check the response. url = \"https://api.github.com/search/repositories\" url += \"?q=language:python+sort:stars+stars:>10000\" headers = { \"Accept\" : \"application/vnd.github.v3+json\" } r = requests . get ( url , headers = headers ) print ( f \"Status code: { r . status_code } \" ) return r def get_response_dict ( response ): \"\"\"Convert the response object to a dictionary.\"\"\" response_dict = response . json () return response_dict def show_repos_info ( response_dict ): \"\"\"Show information about the returned repositories.\"\"\" print ( f \"Total repositories: { response_dict [ 'total_count' ] } \" ) print ( f \"Complete results: { not response_dict [ 'incomplete_results' ] } \" ) def get_repo_dicts ( response_dict ): \"\"\"Return list of dictionaries, one for each repository.\"\"\" repo_dicts = response_dict [ 'items' ] return repo_dicts def show_repo_dicts_info ( repo_dicts ): \"\"\"Summarize information about repositories.\"\"\" print ( f \"Repositories returned: { len ( repo_dicts ) } \" ) print ( \" \\n Selected information about each repository:\" ) for repo_dict in repo_dicts : print ( \" \\n Selected information about first repository:\" ) print ( f \"Name: { repo_dict [ 'name' ] } \" ) print ( f \"Owner: { repo_dict [ 'owner' ][ 'login' ] } \" ) print ( f \"Stars: { repo_dict [ 'stargazers_count' ] } \" ) print ( f \"Repository: { repo_dict [ 'html_url' ] } \" ) print ( f \"Created: { repo_dict [ 'created_at' ] } \" ) print ( f \"Updated: { repo_dict [ 'updated_at' ] } \" ) print ( f \"Description: { repo_dict [ 'description' ] } \" ) response = get_repos_info () response_dict = get_response_dict ( response ) show_repos_info ( response_dict ) repo_dicts = get_repo_dicts ( response_dict ) show_repo_dicts_info ( repo_dicts ) Output: Status code: 200 Total repositories: 307 Complete results: True Repositories returned: 30 Selected information about each repository: Selected information about first repository: Name: public-apis Owner: public-apis Stars: 227342 Repository: https://github.com/public-apis/public-apis Created: 2016-03-20T23:49:42Z Updated: 2023-02-08T01:53:56Z Description: A collective list of free APIs ... Here's a version of test_python_repos.py that does not use fixtures: test_python_repos.py import pytest from python_repos_tested import get_repos_info , get_response_dict , get_repo_dicts def test_response_status_code (): \"\"\"Test that a response has a successful status code.\"\"\" r = get_repos_info () assert r . status_code == 200 def test_response_dict (): \"\"\"Verify an appropriate number of repositories are represented, and the results are complete. \"\"\" r = get_repos_info () response_dict = get_response_dict ( r ) total_count = response_dict [ 'total_count' ] complete_results = not response_dict [ 'incomplete_results' ] assert total_count > 240 assert complete_results def test_repo_dicts (): \"\"\"Verify the results in repo_dicts are correct.\"\"\" r = get_repos_info () response_dict = get_response_dict ( r ) repo_dicts = get_repo_dicts ( response_dict ) assert len ( repo_dicts ) == 30 # Check that all repos returned have over 10k stars. for repo_dict in repo_dicts : assert repo_dict [ 'stargazers_count' ] > 10_000 Output: $ pytest test_python_repos.py ==================== test session starts ==================== platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /Users/eric/pcc_3e/solution_files/chapter_17 collected 3 items test_python_repos.py ... [100%] ==================== 3 passed in 6.42s ==================== This is a reasonable first pass at writing these three tests. But you might notice that every test function needs to call get_repos_info() , which means there's one API call for every single test function. That would quickly get out of hand. Here's the same three tests, using a fixture to make sure that get_repos_info() is only called once for the entire test run: test_python_repos_with_fixture.py import pytest from python_repos_tested import get_repos_info , get_response_dict , get_repo_dicts @pytest . fixture def response (): \"\"\"Get a response object.\"\"\" r = get_repos_info () return r def test_response_status_code ( response ): \"\"\"Test that a response has a successful status code.\"\"\" assert response . status_code == 200 def test_response_dict ( response ): \"\"\"Verify an appropriate number of repositories are represented, and the results are complete. \"\"\" response_dict = get_response_dict ( response ) total_count = response_dict [ 'total_count' ] complete_results = not response_dict [ 'incomplete_results' ] assert total_count > 240 assert complete_results def test_repo_dicts ( response ): \"\"\"Verify the results in repo_dicts are correct.\"\"\" response_dict = get_response_dict ( response ) repo_dicts = get_repo_dicts ( response_dict ) assert len ( repo_dicts ) == 30 # Check that all repos returned have over 10k stars. for repo_dict in repo_dicts : assert repo_dict [ 'stargazers_count' ] > 10_000 Output: $ pytest test_python_repos_with_fixture.py ==================== test session starts ==================== platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /Users/eric/pcc_3e/solution_files/chapter_17 collected 3 items test_python_repos_with_fixture.py ... [100%] ==================== 3 passed in 7.46s ==================== Note: The times reported by pytest are not representative of the entire time it takes to run the test suite. Some of the time that's spent waiting for network calls is not counted by pytest. If you time these two test runs with a stopwatch or another non-pytest timer, you'll find that the file using a fixture runs significantly faster than the file without a fixture. This difference would become even more significant as the number of test functions grows.","title":"Chapter 17"},{"location":"solutions/chapter_17/#solutions-chapter-17","text":"","title":"Solutions - Chapter 17"},{"location":"solutions/chapter_17/#17-1-other-languages","text":"Modify the API call in python_repos.py so it generates a chart showing the most popular projects in other languages. Try languages such as JavaScript , Ruby , C , Java , Perl , Haskell , and Go . javascript_repos.py import requests import plotly.express as px # Make an API call and check the response. url = \"https://api.github.com/search/repositories\" url += \"?q=language:javascript+sort:stars+stars:>10000\" headers = { \"Accept\" : \"application/vnd.github.v3+json\" } r = requests . get ( url , headers = headers ) print ( f \"Status code: { r . status_code } \" ) # Process overall results. response_dict = r . json () print ( f \"Complete results: { not response_dict [ 'incomplete_results' ] } \" ) # Process repository information. repo_dicts = response_dict [ 'items' ] repo_links , stars , hover_texts = [], [], [] for repo_dict in repo_dicts : # Turn repo names into active links. repo_name = repo_dict [ 'name' ] repo_url = repo_dict [ 'html_url' ] repo_link = f \"<a href=' { repo_url } '> { repo_name } </a>\" repo_links . append ( repo_link ) stars . append ( repo_dict [ 'stargazers_count' ]) # Build hover texts. owner = repo_dict [ 'owner' ][ 'login' ] description = repo_dict [ 'description' ] hover_text = f \" { owner } <br /> { description } \" hover_texts . append ( hover_text ) # Make visualization. title = \"Most-Starred JavaScript Projects on GitHub\" labels = { 'x' : 'Repository' , 'y' : 'Stars' } fig = px . bar ( x = repo_links , y = stars , title = title , labels = labels , hover_name = hover_texts ) fig . update_layout ( title_font_size = 28 , xaxis_title_font_size = 20 , yaxis_title_font_size = 20 ) fig . update_traces ( marker_color = 'SteelBlue' , marker_opacity = 0.6 ) fig . show () Output:","title":"17-1: Other Languages"},{"location":"solutions/chapter_17/#17-2-active-discussions","text":"Using the data from hn_submissions.py , make a bar chart showing the most active discussions currently happening on Hacker News. The height of each bar should correspond to the number of comments each submission has. The label for each bar should include the submission\u2019s title and act as a link to the discussion page for that submission. If you get a KeyError when creating a chart, use a try-except block to skip over the promotional posts. hn_discussions_visual.py from operator import itemgetter import requests import plotly.express as px # Make an API call and check the response. url = 'https://hacker-news.firebaseio.com/v0/topstories.json' r = requests . get ( url ) print ( f \"Status code: { r . status_code } \" ) # Process information about each submission. submission_ids = r . json () submission_dicts = [] for submission_id in submission_ids [: 20 ]: # Make a new API call for each submission. url = f \"https://hacker-news.firebaseio.com/v0/item/ { submission_id } .json\" r = requests . get ( url ) print ( f \"id: { submission_id } \\t status: { r . status_code } \" ) response_dict = r . json () # Build a dictionary for each article. try : submission_dict = { 'title' : response_dict [ 'title' ], 'hn_link' : f \"https://news.ycombinator.com/item?id= { submission_id } \" , 'comments' : response_dict [ 'descendants' ], } except KeyError : # This is a special YC post with comments disabled. continue else : submission_dicts . append ( submission_dict ) submission_dicts = sorted ( submission_dicts , key = itemgetter ( 'comments' ), reverse = True ) # Process data for plotting. article_links , comment_counts , hover_texts = [], [], [] for submission_dict in submission_dicts : # Shorten long article titles. title = submission_dict [ 'title' ][: 30 ] discussion_link = submission_dict [ 'hn_link' ] article_link = f '<a href=\" { discussion_link } \"\"> { title } </a>' comment_count = submission_dict [ 'comments' ] article_links . append ( article_link ) comment_counts . append ( comment_count ) # Show the full title on hover. hover_texts . append ( submission_dict [ 'title' ]) # Make visualization. title = \"Most active discussions on Hacker News\" labels = { 'x' : 'Article' , 'y' : 'Comment count' } fig = px . bar ( x = article_links , y = comment_counts , title = title , labels = labels , hover_name = hover_texts ) fig . update_layout ( title_font_size = 28 , xaxis_title_font_size = 20 , yaxis_title_font_size = 20 ) fig . update_traces ( marker_color = 'SteelBlue' , marker_opacity = 0.6 ) fig . show () Output:","title":"17-2: Active Discussions"},{"location":"solutions/chapter_17/#17-3-testing-python_repospy","text":"In python_repos.py , we printed the value of status_code to make sure the API call was successful. Write a program called test_python_repos.py that uses pytest to assert that the value of status_code is 200. Figure out some other assertions you can make: for example, that the number of items returned is expected and that the total number of repositories is greater than a certain amount. Note: It's much easier to test a program that's broken up into functions or classes. So this solution actually has three parts: a version of python_repos.py that uses functions to do its work, a simpler test file, and a test file that uses fixtures. python_repos_tested.py import requests def get_repos_info (): \"\"\"Get information about Python repositories on GitHub.\"\"\" # Make an API call and check the response. url = \"https://api.github.com/search/repositories\" url += \"?q=language:python+sort:stars+stars:>10000\" headers = { \"Accept\" : \"application/vnd.github.v3+json\" } r = requests . get ( url , headers = headers ) print ( f \"Status code: { r . status_code } \" ) return r def get_response_dict ( response ): \"\"\"Convert the response object to a dictionary.\"\"\" response_dict = response . json () return response_dict def show_repos_info ( response_dict ): \"\"\"Show information about the returned repositories.\"\"\" print ( f \"Total repositories: { response_dict [ 'total_count' ] } \" ) print ( f \"Complete results: { not response_dict [ 'incomplete_results' ] } \" ) def get_repo_dicts ( response_dict ): \"\"\"Return list of dictionaries, one for each repository.\"\"\" repo_dicts = response_dict [ 'items' ] return repo_dicts def show_repo_dicts_info ( repo_dicts ): \"\"\"Summarize information about repositories.\"\"\" print ( f \"Repositories returned: { len ( repo_dicts ) } \" ) print ( \" \\n Selected information about each repository:\" ) for repo_dict in repo_dicts : print ( \" \\n Selected information about first repository:\" ) print ( f \"Name: { repo_dict [ 'name' ] } \" ) print ( f \"Owner: { repo_dict [ 'owner' ][ 'login' ] } \" ) print ( f \"Stars: { repo_dict [ 'stargazers_count' ] } \" ) print ( f \"Repository: { repo_dict [ 'html_url' ] } \" ) print ( f \"Created: { repo_dict [ 'created_at' ] } \" ) print ( f \"Updated: { repo_dict [ 'updated_at' ] } \" ) print ( f \"Description: { repo_dict [ 'description' ] } \" ) response = get_repos_info () response_dict = get_response_dict ( response ) show_repos_info ( response_dict ) repo_dicts = get_repo_dicts ( response_dict ) show_repo_dicts_info ( repo_dicts ) Output: Status code: 200 Total repositories: 307 Complete results: True Repositories returned: 30 Selected information about each repository: Selected information about first repository: Name: public-apis Owner: public-apis Stars: 227342 Repository: https://github.com/public-apis/public-apis Created: 2016-03-20T23:49:42Z Updated: 2023-02-08T01:53:56Z Description: A collective list of free APIs ... Here's a version of test_python_repos.py that does not use fixtures: test_python_repos.py import pytest from python_repos_tested import get_repos_info , get_response_dict , get_repo_dicts def test_response_status_code (): \"\"\"Test that a response has a successful status code.\"\"\" r = get_repos_info () assert r . status_code == 200 def test_response_dict (): \"\"\"Verify an appropriate number of repositories are represented, and the results are complete. \"\"\" r = get_repos_info () response_dict = get_response_dict ( r ) total_count = response_dict [ 'total_count' ] complete_results = not response_dict [ 'incomplete_results' ] assert total_count > 240 assert complete_results def test_repo_dicts (): \"\"\"Verify the results in repo_dicts are correct.\"\"\" r = get_repos_info () response_dict = get_response_dict ( r ) repo_dicts = get_repo_dicts ( response_dict ) assert len ( repo_dicts ) == 30 # Check that all repos returned have over 10k stars. for repo_dict in repo_dicts : assert repo_dict [ 'stargazers_count' ] > 10_000 Output: $ pytest test_python_repos.py ==================== test session starts ==================== platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /Users/eric/pcc_3e/solution_files/chapter_17 collected 3 items test_python_repos.py ... [100%] ==================== 3 passed in 6.42s ==================== This is a reasonable first pass at writing these three tests. But you might notice that every test function needs to call get_repos_info() , which means there's one API call for every single test function. That would quickly get out of hand. Here's the same three tests, using a fixture to make sure that get_repos_info() is only called once for the entire test run: test_python_repos_with_fixture.py import pytest from python_repos_tested import get_repos_info , get_response_dict , get_repo_dicts @pytest . fixture def response (): \"\"\"Get a response object.\"\"\" r = get_repos_info () return r def test_response_status_code ( response ): \"\"\"Test that a response has a successful status code.\"\"\" assert response . status_code == 200 def test_response_dict ( response ): \"\"\"Verify an appropriate number of repositories are represented, and the results are complete. \"\"\" response_dict = get_response_dict ( response ) total_count = response_dict [ 'total_count' ] complete_results = not response_dict [ 'incomplete_results' ] assert total_count > 240 assert complete_results def test_repo_dicts ( response ): \"\"\"Verify the results in repo_dicts are correct.\"\"\" response_dict = get_response_dict ( response ) repo_dicts = get_repo_dicts ( response_dict ) assert len ( repo_dicts ) == 30 # Check that all repos returned have over 10k stars. for repo_dict in repo_dicts : assert repo_dict [ 'stargazers_count' ] > 10_000 Output: $ pytest test_python_repos_with_fixture.py ==================== test session starts ==================== platform darwin -- Python 3.10.0, pytest-7.1.2, pluggy-1.0.0 rootdir: /Users/eric/pcc_3e/solution_files/chapter_17 collected 3 items test_python_repos_with_fixture.py ... [100%] ==================== 3 passed in 7.46s ==================== Note: The times reported by pytest are not representative of the entire time it takes to run the test suite. Some of the time that's spent waiting for network calls is not counted by pytest. If you time these two test runs with a stopwatch or another non-pytest timer, you'll find that the file using a fixture runs significantly faster than the file without a fixture. This difference would become even more significant as the number of test functions grows.","title":"17-3 Testing python_repos.py"},{"location":"solutions/chapter_2/","text":"Solutions - Chapter 2 2-1: Simple Message Assign a message to a variable, and then print that message. simple_message.py msg = \"I love learning to use Python.\" print ( msg ) Output: I love learning to use Python. 2-2: Simple Messages Assign a message to a variable, and print that message. Then change the value of the variable to a new message, and print the new message. simple_messages.py msg = \"I love learning to use Python.\" print ( msg ) msg = \"It's really satisfying!\" print ( msg ) Output: I love learning to use Python. It's really satisfying! 2-3: Personal Message Use a variable to represent a person\u2019s name, and print a message to that person. Your message should be simple, such as, \u201cHello Eric, would you like to learn some Python today?\u201d personal_message.py name = \"eric\" msg = f \"Hello { name . title () } , would you like to learn some Python today?\" print ( msg ) Output: Hello Eric, would you like to learn some Python today? 2-4: Name Cases Use a variable to represent a person\u2019s name, and then print that person\u2019s name in lowercase, uppercase, and title case. name_cases.py name = \"eric\" print ( name . lower ()) print ( name . upper ()) print ( name . title ()) Output: eric ERIC Eric 2-5: Famous Quote Find a quote from a famous person you admire. Print the quote and the name of its author. Your output should look something like the following, including the quotation marks: Albert Einstein once said, \"A person who never made a mistake never tried anything new.\" famous_quote.py print ( 'Albert Einstein once said, \"A person who never made a mistake' ) print ( 'never tried anything new.\"' ) Output: Albert Einstein once said, \"A person who never made a mistake never tried anything new.\" 2-6: Famous Quote 2 Repeat Exercise 2-5, but this time, represent the famous person\u2019s name using a variable called famous_person . Then compose your message and represent it with a new variable called message . Print your message. famous_quote_2.py famous_person = \"Albert Einstein\" message = f ' { famous_person } once said, \"A person who never made a mistake never tried anything new.\"' print ( message ) Output: Albert Einstein once said, \"A person who never made a mistake never tried anything new.\" Note The line that defines message in this file is longer than we'd typically like to write. You'll see this a little later in Chapter 7, but you can add to a string using the += operator. So this program could also be written like this, with exactly the same output: famous_quote_3.py famous_person = \"Albert Einstein\" message = f ' { famous_person } once said, \"A person who never made a mistake' message += ' never tried anything new.\"' print ( message ) 2-7: Stripping Names Use a variable to represent a person's name, and include some whitespace characters at the beginning and end of the name. Make sure you use each character combination, \"\\t\" and \"\\n\" , at least once. Print the name once, so the whitespace around the name is displayed. Then print the name using each of the three stripping functions, lstrip() , rstrip() , and strip() . stripping_names.py name = \" \\t Eric Matthes \\n \" print ( \"Unmodified:\" ) print ( name ) print ( \" \\n Using lstrip():\" ) print ( name . lstrip ()) print ( \" \\n Using rstrip():\" ) print ( name . rstrip ()) print ( \" \\n Using strip():\" ) print ( name . strip ()) Output: Unmodified: Eric Matthes Using lstrip(): Eric Matthes Using rstrip(): Eric Matthes Using strip(): Eric Matthes 2-8: File Extensions Python has a removesuffix() method that works exactly like removeprefix() . Assign the value 'python_notes.txt' to a variable called filename . Then use the removesuffix() method to display the filename without the file extension, like some file browsers do. file_extensions.py filename = 'python_notes.txt' simple_filename = filename . removesuffix ( '.txt' ) print ( simple_filename ) Output: python_notes 2-10: Favorite Number Use a variable to represent your favorite number. Then, using that variable, create a message that reveals your favorite number. Print that message. favorite_number.py fav_num = 42 msg = f \"My favorite number is { fav_num } .\" print ( msg ) Output: My favorite number is 42.","title":"Chapter 2"},{"location":"solutions/chapter_2/#solutions-chapter-2","text":"","title":"Solutions - Chapter 2"},{"location":"solutions/chapter_2/#2-1-simple-message","text":"Assign a message to a variable, and then print that message. simple_message.py msg = \"I love learning to use Python.\" print ( msg ) Output: I love learning to use Python.","title":"2-1: Simple Message"},{"location":"solutions/chapter_2/#2-2-simple-messages","text":"Assign a message to a variable, and print that message. Then change the value of the variable to a new message, and print the new message. simple_messages.py msg = \"I love learning to use Python.\" print ( msg ) msg = \"It's really satisfying!\" print ( msg ) Output: I love learning to use Python. It's really satisfying!","title":"2-2: Simple Messages"},{"location":"solutions/chapter_2/#2-3-personal-message","text":"Use a variable to represent a person\u2019s name, and print a message to that person. Your message should be simple, such as, \u201cHello Eric, would you like to learn some Python today?\u201d personal_message.py name = \"eric\" msg = f \"Hello { name . title () } , would you like to learn some Python today?\" print ( msg ) Output: Hello Eric, would you like to learn some Python today?","title":"2-3: Personal Message"},{"location":"solutions/chapter_2/#2-4-name-cases","text":"Use a variable to represent a person\u2019s name, and then print that person\u2019s name in lowercase, uppercase, and title case. name_cases.py name = \"eric\" print ( name . lower ()) print ( name . upper ()) print ( name . title ()) Output: eric ERIC Eric","title":"2-4: Name Cases"},{"location":"solutions/chapter_2/#2-5-famous-quote","text":"Find a quote from a famous person you admire. Print the quote and the name of its author. Your output should look something like the following, including the quotation marks: Albert Einstein once said, \"A person who never made a mistake never tried anything new.\" famous_quote.py print ( 'Albert Einstein once said, \"A person who never made a mistake' ) print ( 'never tried anything new.\"' ) Output: Albert Einstein once said, \"A person who never made a mistake never tried anything new.\"","title":"2-5: Famous Quote"},{"location":"solutions/chapter_2/#2-6-famous-quote-2","text":"Repeat Exercise 2-5, but this time, represent the famous person\u2019s name using a variable called famous_person . Then compose your message and represent it with a new variable called message . Print your message. famous_quote_2.py famous_person = \"Albert Einstein\" message = f ' { famous_person } once said, \"A person who never made a mistake never tried anything new.\"' print ( message ) Output: Albert Einstein once said, \"A person who never made a mistake never tried anything new.\" Note The line that defines message in this file is longer than we'd typically like to write. You'll see this a little later in Chapter 7, but you can add to a string using the += operator. So this program could also be written like this, with exactly the same output: famous_quote_3.py famous_person = \"Albert Einstein\" message = f ' { famous_person } once said, \"A person who never made a mistake' message += ' never tried anything new.\"' print ( message )","title":"2-6: Famous Quote 2"},{"location":"solutions/chapter_2/#2-7-stripping-names","text":"Use a variable to represent a person's name, and include some whitespace characters at the beginning and end of the name. Make sure you use each character combination, \"\\t\" and \"\\n\" , at least once. Print the name once, so the whitespace around the name is displayed. Then print the name using each of the three stripping functions, lstrip() , rstrip() , and strip() . stripping_names.py name = \" \\t Eric Matthes \\n \" print ( \"Unmodified:\" ) print ( name ) print ( \" \\n Using lstrip():\" ) print ( name . lstrip ()) print ( \" \\n Using rstrip():\" ) print ( name . rstrip ()) print ( \" \\n Using strip():\" ) print ( name . strip ()) Output: Unmodified: Eric Matthes Using lstrip(): Eric Matthes Using rstrip(): Eric Matthes Using strip(): Eric Matthes","title":"2-7: Stripping Names"},{"location":"solutions/chapter_2/#2-8-file-extensions","text":"Python has a removesuffix() method that works exactly like removeprefix() . Assign the value 'python_notes.txt' to a variable called filename . Then use the removesuffix() method to display the filename without the file extension, like some file browsers do. file_extensions.py filename = 'python_notes.txt' simple_filename = filename . removesuffix ( '.txt' ) print ( simple_filename ) Output: python_notes","title":"2-8: File Extensions"},{"location":"solutions/chapter_2/#2-10-favorite-number","text":"Use a variable to represent your favorite number. Then, using that variable, create a message that reveals your favorite number. Print that message. favorite_number.py fav_num = 42 msg = f \"My favorite number is { fav_num } .\" print ( msg ) Output: My favorite number is 42.","title":"2-10: Favorite Number"},{"location":"solutions/chapter_3/","text":"Solutions - Chapter 3 3-1: Names Store the names of a few of your friends in a list called names . Print each person's name by accessing each element in the list, one at a time. names.py names = [ 'ron' , 'tyler' , 'dani' ] print ( names [ 0 ]) print ( names [ 1 ]) print ( names [ 2 ]) Output: ron tyler dani 3-2: Greetings Start with the list you used in Exercise 3-1, but instead of just printing each person's name, print a message to them. The text of each message should be the same, but each message should be personalized with the person's name. greetings.py names = [ 'ron' , 'tyler' , 'dani' ] msg = f \"Hello, { names [ 0 ] . title () } !\" print ( msg ) msg = f \"Hello, { names [ 1 ] . title () } !\" print ( msg ) msg = f \"Hello, { names [ 2 ] . title () } !\" print ( msg ) Output: Hello, Ron! Hello, Tyler! Hello, Dani! 3-4: Guest List If you could invite anyone, living or deceased, to dinner, who would you invite? Make a list that includes at least three people you'd like to invite to dinner. Then use your list to print a message to each person, inviting them to dinner. guest_list.py guests = [ 'guido van rossum' , 'jack turner' , 'lynn hill' ] name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) Output: Guido Van Rossum, please come to dinner. Jack Turner, please come to dinner. Lynn Hill, please come to dinner. 3-5: Changing Guest List You just heard that one of your guests can't make the dinner, so you need to send out a new set of invitations. You'll have to think of someone else to invite. Start with your program from Exercise 3-4. Add a print() call at the end of your program, stating the name of the guest who can't make it. Modify your list, replacing the name of the guest who can't make it with the name of the new person you are inviting. Print a second set of invitation messages, one for each person who is still in your list. changing_guest_list.py # Invite some people to dinner. guests = [ 'guido van rossum' , 'jack turner' , 'lynn hill' ] name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" \\n Sorry, { name } can't make it to dinner.\" ) # Jack can't make it! Let's invite Gary instead. del ( guests [ 1 ]) guests . insert ( 1 , 'gary snyder' ) # Print the invitations again. name = guests [ 0 ] . title () print ( f \" \\n { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) Output: Guido Van Rossum, please come to dinner. Jack Turner, please come to dinner. Lynn Hill, please come to dinner. Sorry, Jack Turner can't make it to dinner. Guido Van Rossum, please come to dinner. Gary Snyder, please come to dinner. Lynn Hill, please come to dinner. 3-6: More Guests You just found a bigger dinner table, so now more space is available. Think of three more guests to invite to dinner. Start with your program from Exercise 3-4 or Exercise 3-5. Add a print() call to the end of your program, informing people that you found a bigger dinner table. Use insert() to add one new guest to the beginning of your list. Use insert() to add one new guest to the middle of your list. Use append() to add one new guest to the end of your list. Print a new set of invitation messages, one for each person in your list. more_guests.py # Invite some people to dinner. guests = [ 'guido van rossum' , 'jack turner' , 'lynn hill' ] name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" \\n Sorry, { name } can't make it to dinner.\" ) # Jack can't make it! Let's invite Gary instead. del ( guests [ 1 ]) guests . insert ( 1 , 'gary snyder' ) # Print the invitations again. name = guests [ 0 ] . title () print ( f \" \\n { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) # We got a bigger table, so let's add some more people to the list. print ( \" \\n We got a bigger table!\" ) guests . insert ( 0 , 'frida kahlo' ) guests . insert ( 2 , 'reinhold messner' ) guests . append ( 'elizabeth peratrovich' ) name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 3 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 4 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 5 ] . title () print ( f \" { name } , please come to dinner.\" ) Output: Guido Van Rossum, please come to dinner. Jack Turner, please come to dinner. Lynn Hill, please come to dinner. Sorry, Jack Turner can't make it to dinner. Guido Van Rossum, please come to dinner. Gary Snyder, please come to dinner. Lynn Hill, please come to dinner. We got a bigger table! Frida Kahlo, please come to dinner. Guido Van Rossum, please come to dinner. Reinhold Messner, please come to dinner. Gary Snyder, please come to dinner. Lynn Hill, please come to dinner. Elizabeth Peratrovich, please come to dinner. 3-7: Shrinking Guest List You just found out that your new dinner table won't arrive in time for the dinner, and you have space for only two guests. Start with your program from Exercise 3-6. Add a new line that prints a message saying that you can invite only two people for dinner. Use pop() to remove guests from your list one at a time until only two names remain in your list. Each time you pop a name from your list, print a message to that person letting them know you're sorry you can't invite them to dinner. Print a message to each of the two people still on your list, letting them know they're still invited. Use del to remove the last two names from your list, so you have an empty list. Print your list to make sure you actually have an empty list at the end of your program. shrinking_guest_list.py # Invite some people to dinner. guests = [ 'guido van rossum' , 'jack turner' , 'lynn hill' ] name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" \\n Sorry, { name } can't make it to dinner.\" ) # Jack can't make it! Let's invite Gary instead. del ( guests [ 1 ]) guests . insert ( 1 , 'gary snyder' ) # Print the invitations again. name = guests [ 0 ] . title () print ( f \" \\n { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) # We got a bigger table, so let's add some more people to the list. print ( \" \\n We got a bigger table!\" ) guests . insert ( 0 , 'frida kahlo' ) guests . insert ( 2 , 'reinhold messner' ) guests . append ( 'elizabeth peratrovich' ) name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 3 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 4 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 5 ] . title () print ( f \" { name } , please come to dinner.\" ) # Oh no, the table won't arrive on time! print ( \" \\n Sorry, we can only invite two people to dinner.\" ) name = guests . pop () print ( f \"Sorry, { name . title () } there's no room at the table.\" ) name = guests . pop () print ( f \"Sorry, { name . title () } there's no room at the table.\" ) name = guests . pop () print ( f \"Sorry, { name . title () } there's no room at the table.\" ) name = guests . pop () print ( f \"Sorry, { name . title () } there's no room at the table.\" ) # There should be two people left. Let's invite them. name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) # Empty out the list. del ( guests [ 0 ]) del ( guests [ 0 ]) # Prove the list is empty. print ( guests ) Output: Guido Van Rossum, please come to dinner. Jack Turner, please come to dinner. Lynn Hill, please come to dinner. Sorry, Jack Turner can't make it to dinner. Guido Van Rossum, please come to dinner. Gary Snyder, please come to dinner. Lynn Hill, please come to dinner. We got a bigger table! Frida Kahlo, please come to dinner. Guido Van Rossum, please come to dinner. Reinhold Messner, please come to dinner. Gary Snyder, please come to dinner. Lynn Hill, please come to dinner. Elizabeth Peratrovich, please come to dinner. Sorry, we can only invite two people to dinner. Sorry, Elizabeth Peratrovich there's no room at the table. Sorry, Lynn Hill there's no room at the table. Sorry, Gary Snyder there's no room at the table. Sorry, Reinhold Messner there's no room at the table. Frida Kahlo, please come to dinner. Guido Van Rossum, please come to dinner. [] 3-8: Seeing the World Think of at least five places in the world you'd like to visit. Store the locations in a list. Make sure the list is not in alphabetical order. Print your list in its original order. Don't worry about printing the list neatly, just print it as a raw Python list. Use sorted() to print your list in alphabetical order without modifying the actual list. Show that your list is still in its original order by printing it. Use sorted() to print your list in reverse alphabetical order without changing the order of the original list. Show that your list is still in its original order by printing it again. Use reverse() to change the order of your list. Print the list to show that its order has changed. Use reverse() to change the order of your list again. Print the list to show it's back to its original order. Use sort() to change your list so it's stored in alphabetical order. Print the list to show that its order has been changed. Use sort() to change your list so it's stored in reverse alphabetical order. Print the list to show that its order has changed. seeing_the_world.py locations = [ 'himalaya' , 'andes' , 'tierra del fuego' , 'labrador' , 'guam' ] print ( \"Original order:\" ) print ( locations ) print ( \" \\n Alphabetical:\" ) print ( sorted ( locations )) print ( \" \\n Original order:\" ) print ( locations ) print ( \" \\n Reverse alphabetical:\" ) print ( sorted ( locations , reverse = True )) print ( \" \\n Original order:\" ) print ( locations ) print ( \" \\n Reversed:\" ) locations . reverse () print ( locations ) print ( \" \\n Original order:\" ) locations . reverse () print ( locations ) print ( \" \\n Alphabetical\" ) locations . sort () print ( locations ) print ( \" \\n Reverse alphabetical\" ) locations . sort ( reverse = True ) print ( locations ) Output: Original order: ['himalaya', 'andes', 'tierra del fuego', 'labrador', 'guam'] Alphabetical: ['andes', 'guam', 'himalaya', 'labrador', 'tierra del fuego'] Original order: ['himalaya', 'andes', 'tierra del fuego', 'labrador', 'guam'] Reverse alphabetical: ['tierra del fuego', 'labrador', 'himalaya', 'guam', 'andes'] Original order: ['himalaya', 'andes', 'tierra del fuego', 'labrador', 'guam'] Reversed: ['guam', 'labrador', 'tierra del fuego', 'andes', 'himalaya'] Original order: ['himalaya', 'andes', 'tierra del fuego', 'labrador', 'guam'] Alphabetical ['andes', 'guam', 'himalaya', 'labrador', 'tierra del fuego'] Reverse alphabetical ['tierra del fuego', 'labrador', 'himalaya', 'guam', 'andes']","title":"Chapter 3"},{"location":"solutions/chapter_3/#solutions-chapter-3","text":"","title":"Solutions - Chapter 3"},{"location":"solutions/chapter_3/#3-1-names","text":"Store the names of a few of your friends in a list called names . Print each person's name by accessing each element in the list, one at a time. names.py names = [ 'ron' , 'tyler' , 'dani' ] print ( names [ 0 ]) print ( names [ 1 ]) print ( names [ 2 ]) Output: ron tyler dani","title":"3-1: Names"},{"location":"solutions/chapter_3/#3-2-greetings","text":"Start with the list you used in Exercise 3-1, but instead of just printing each person's name, print a message to them. The text of each message should be the same, but each message should be personalized with the person's name. greetings.py names = [ 'ron' , 'tyler' , 'dani' ] msg = f \"Hello, { names [ 0 ] . title () } !\" print ( msg ) msg = f \"Hello, { names [ 1 ] . title () } !\" print ( msg ) msg = f \"Hello, { names [ 2 ] . title () } !\" print ( msg ) Output: Hello, Ron! Hello, Tyler! Hello, Dani!","title":"3-2: Greetings"},{"location":"solutions/chapter_3/#3-4-guest-list","text":"If you could invite anyone, living or deceased, to dinner, who would you invite? Make a list that includes at least three people you'd like to invite to dinner. Then use your list to print a message to each person, inviting them to dinner. guest_list.py guests = [ 'guido van rossum' , 'jack turner' , 'lynn hill' ] name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) Output: Guido Van Rossum, please come to dinner. Jack Turner, please come to dinner. Lynn Hill, please come to dinner.","title":"3-4: Guest List"},{"location":"solutions/chapter_3/#3-5-changing-guest-list","text":"You just heard that one of your guests can't make the dinner, so you need to send out a new set of invitations. You'll have to think of someone else to invite. Start with your program from Exercise 3-4. Add a print() call at the end of your program, stating the name of the guest who can't make it. Modify your list, replacing the name of the guest who can't make it with the name of the new person you are inviting. Print a second set of invitation messages, one for each person who is still in your list. changing_guest_list.py # Invite some people to dinner. guests = [ 'guido van rossum' , 'jack turner' , 'lynn hill' ] name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" \\n Sorry, { name } can't make it to dinner.\" ) # Jack can't make it! Let's invite Gary instead. del ( guests [ 1 ]) guests . insert ( 1 , 'gary snyder' ) # Print the invitations again. name = guests [ 0 ] . title () print ( f \" \\n { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) Output: Guido Van Rossum, please come to dinner. Jack Turner, please come to dinner. Lynn Hill, please come to dinner. Sorry, Jack Turner can't make it to dinner. Guido Van Rossum, please come to dinner. Gary Snyder, please come to dinner. Lynn Hill, please come to dinner.","title":"3-5: Changing Guest List"},{"location":"solutions/chapter_3/#3-6-more-guests","text":"You just found a bigger dinner table, so now more space is available. Think of three more guests to invite to dinner. Start with your program from Exercise 3-4 or Exercise 3-5. Add a print() call to the end of your program, informing people that you found a bigger dinner table. Use insert() to add one new guest to the beginning of your list. Use insert() to add one new guest to the middle of your list. Use append() to add one new guest to the end of your list. Print a new set of invitation messages, one for each person in your list. more_guests.py # Invite some people to dinner. guests = [ 'guido van rossum' , 'jack turner' , 'lynn hill' ] name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" \\n Sorry, { name } can't make it to dinner.\" ) # Jack can't make it! Let's invite Gary instead. del ( guests [ 1 ]) guests . insert ( 1 , 'gary snyder' ) # Print the invitations again. name = guests [ 0 ] . title () print ( f \" \\n { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) # We got a bigger table, so let's add some more people to the list. print ( \" \\n We got a bigger table!\" ) guests . insert ( 0 , 'frida kahlo' ) guests . insert ( 2 , 'reinhold messner' ) guests . append ( 'elizabeth peratrovich' ) name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 3 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 4 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 5 ] . title () print ( f \" { name } , please come to dinner.\" ) Output: Guido Van Rossum, please come to dinner. Jack Turner, please come to dinner. Lynn Hill, please come to dinner. Sorry, Jack Turner can't make it to dinner. Guido Van Rossum, please come to dinner. Gary Snyder, please come to dinner. Lynn Hill, please come to dinner. We got a bigger table! Frida Kahlo, please come to dinner. Guido Van Rossum, please come to dinner. Reinhold Messner, please come to dinner. Gary Snyder, please come to dinner. Lynn Hill, please come to dinner. Elizabeth Peratrovich, please come to dinner.","title":"3-6: More Guests"},{"location":"solutions/chapter_3/#3-7-shrinking-guest-list","text":"You just found out that your new dinner table won't arrive in time for the dinner, and you have space for only two guests. Start with your program from Exercise 3-6. Add a new line that prints a message saying that you can invite only two people for dinner. Use pop() to remove guests from your list one at a time until only two names remain in your list. Each time you pop a name from your list, print a message to that person letting them know you're sorry you can't invite them to dinner. Print a message to each of the two people still on your list, letting them know they're still invited. Use del to remove the last two names from your list, so you have an empty list. Print your list to make sure you actually have an empty list at the end of your program. shrinking_guest_list.py # Invite some people to dinner. guests = [ 'guido van rossum' , 'jack turner' , 'lynn hill' ] name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" \\n Sorry, { name } can't make it to dinner.\" ) # Jack can't make it! Let's invite Gary instead. del ( guests [ 1 ]) guests . insert ( 1 , 'gary snyder' ) # Print the invitations again. name = guests [ 0 ] . title () print ( f \" \\n { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) # We got a bigger table, so let's add some more people to the list. print ( \" \\n We got a bigger table!\" ) guests . insert ( 0 , 'frida kahlo' ) guests . insert ( 2 , 'reinhold messner' ) guests . append ( 'elizabeth peratrovich' ) name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 2 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 3 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 4 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 5 ] . title () print ( f \" { name } , please come to dinner.\" ) # Oh no, the table won't arrive on time! print ( \" \\n Sorry, we can only invite two people to dinner.\" ) name = guests . pop () print ( f \"Sorry, { name . title () } there's no room at the table.\" ) name = guests . pop () print ( f \"Sorry, { name . title () } there's no room at the table.\" ) name = guests . pop () print ( f \"Sorry, { name . title () } there's no room at the table.\" ) name = guests . pop () print ( f \"Sorry, { name . title () } there's no room at the table.\" ) # There should be two people left. Let's invite them. name = guests [ 0 ] . title () print ( f \" { name } , please come to dinner.\" ) name = guests [ 1 ] . title () print ( f \" { name } , please come to dinner.\" ) # Empty out the list. del ( guests [ 0 ]) del ( guests [ 0 ]) # Prove the list is empty. print ( guests ) Output: Guido Van Rossum, please come to dinner. Jack Turner, please come to dinner. Lynn Hill, please come to dinner. Sorry, Jack Turner can't make it to dinner. Guido Van Rossum, please come to dinner. Gary Snyder, please come to dinner. Lynn Hill, please come to dinner. We got a bigger table! Frida Kahlo, please come to dinner. Guido Van Rossum, please come to dinner. Reinhold Messner, please come to dinner. Gary Snyder, please come to dinner. Lynn Hill, please come to dinner. Elizabeth Peratrovich, please come to dinner. Sorry, we can only invite two people to dinner. Sorry, Elizabeth Peratrovich there's no room at the table. Sorry, Lynn Hill there's no room at the table. Sorry, Gary Snyder there's no room at the table. Sorry, Reinhold Messner there's no room at the table. Frida Kahlo, please come to dinner. Guido Van Rossum, please come to dinner. []","title":"3-7: Shrinking Guest List"},{"location":"solutions/chapter_3/#3-8-seeing-the-world","text":"Think of at least five places in the world you'd like to visit. Store the locations in a list. Make sure the list is not in alphabetical order. Print your list in its original order. Don't worry about printing the list neatly, just print it as a raw Python list. Use sorted() to print your list in alphabetical order without modifying the actual list. Show that your list is still in its original order by printing it. Use sorted() to print your list in reverse alphabetical order without changing the order of the original list. Show that your list is still in its original order by printing it again. Use reverse() to change the order of your list. Print the list to show that its order has changed. Use reverse() to change the order of your list again. Print the list to show it's back to its original order. Use sort() to change your list so it's stored in alphabetical order. Print the list to show that its order has been changed. Use sort() to change your list so it's stored in reverse alphabetical order. Print the list to show that its order has changed. seeing_the_world.py locations = [ 'himalaya' , 'andes' , 'tierra del fuego' , 'labrador' , 'guam' ] print ( \"Original order:\" ) print ( locations ) print ( \" \\n Alphabetical:\" ) print ( sorted ( locations )) print ( \" \\n Original order:\" ) print ( locations ) print ( \" \\n Reverse alphabetical:\" ) print ( sorted ( locations , reverse = True )) print ( \" \\n Original order:\" ) print ( locations ) print ( \" \\n Reversed:\" ) locations . reverse () print ( locations ) print ( \" \\n Original order:\" ) locations . reverse () print ( locations ) print ( \" \\n Alphabetical\" ) locations . sort () print ( locations ) print ( \" \\n Reverse alphabetical\" ) locations . sort ( reverse = True ) print ( locations ) Output: Original order: ['himalaya', 'andes', 'tierra del fuego', 'labrador', 'guam'] Alphabetical: ['andes', 'guam', 'himalaya', 'labrador', 'tierra del fuego'] Original order: ['himalaya', 'andes', 'tierra del fuego', 'labrador', 'guam'] Reverse alphabetical: ['tierra del fuego', 'labrador', 'himalaya', 'guam', 'andes'] Original order: ['himalaya', 'andes', 'tierra del fuego', 'labrador', 'guam'] Reversed: ['guam', 'labrador', 'tierra del fuego', 'andes', 'himalaya'] Original order: ['himalaya', 'andes', 'tierra del fuego', 'labrador', 'guam'] Alphabetical ['andes', 'guam', 'himalaya', 'labrador', 'tierra del fuego'] Reverse alphabetical ['tierra del fuego', 'labrador', 'himalaya', 'guam', 'andes']","title":"3-8: Seeing the World"},{"location":"solutions/chapter_4/","text":"Solutions - Chapter 4 4-1: Pizzas Think of at least three kinds of your favorite pizza. Store these pizza names in a list, and then use a for loop to print the name of each pizza. Modify your for loop to print a sentence using the name of the pizza, instead of printing just the name of the pizza. For each pizza, you should have one line of output containing a simple statement like I like pepperoni pizza. Add a line at the end of your program, outside the for loop, that states how much you like pizza. The output should consist of three or more lines about the kinds of pizza you like and then an additional sentence, such as I really love pizza! pizzas.py favorite_pizzas = [ 'pepperoni' , 'hawaiian' , 'veggie' ] # Print the names of all the pizzas. for pizza in favorite_pizzas : print ( pizza ) print ( \" \\n \" ) # Print a sentence about each pizza. for pizza in favorite_pizzas : print ( f \"I really love { pizza } pizza!\" ) print ( \" \\n I really love pizza!\" ) Output: pepperoni hawaiian veggie I really love pepperoni pizza! I really love hawaiian pizza! I really love veggie pizza! I really love pizza! 4-2: Animals Think of at least three different animals that have a common characteristic. Store the names of these animals in a list, and then use a for loop to print out the name of each animal. - Modify your program to print a statement about each animal, such as A dog would make a great pet. - Add a line at the end of your program, stating what these animals have in common. You could print a sentence, such as Any of these animals would make a great pet! animals.py animals = [ \"spider monkey\" , \"lemur\" , \"giraffe\" ] # Print each animal. for animal in animals : print ( animal ) print ( \" \\n \" ) # Print a statement about each animal. for animal in animals : print ( f \"A { animal } has a long tail.\" ) print ( \" \\n All of these animals have long tails.\" ) Output: spider monkey lemur giraffe A spider monkey has a long tail. A lemur has a long tail. A giraffe has a long tail. All of these animals have long tails. 4-3: Counting to Twenty Use a for loop to print the numbers from 1 to 20, inclusive. counting_to_twenty.py numbers = list ( range ( 1 , 21 )) for number in numbers : print ( number ) Output: 1 2 3 ... 18 19 20 4-5: Summing a Million Make a list of the numbers from one to one million, and then use min() and max() to make sure your list actually starts at one and ends at one million. Also, use the sum() function to see how quickly Python can add a million numbers. summing_a_million.py numbers = list ( range ( 1 , 1_000_001 )) print ( min ( numbers )) print ( max ( numbers )) print ( sum ( numbers )) Output: 1 1000000 500000500000 4-6: Odd Numbers Use the third argument of the range() function to make a list of the odd numbers from 1 to 20. Use a for loop to print each number. odd_numbers.py odd_numbers = list ( range ( 1 , 20 , 2 )) for number in odd_numbers : print ( number ) Output: 1 3 5 ... 15 17 19 4-7: Threes Make a list of the multiples of 3 from 3 to 30. Use a for loop to print the numbers in your list. threes.py threes = list ( range ( 3 , 31 , 3 )) for number in threes : print ( number ) Output: 3 6 9 ... 24 27 30 4-8: Cubes A number raised to the third power is called a cube . For example, the cube of 2 is written as 2**3 in Python. Make a list of the first 10 cubes (that is, the cube of each integer from 1 through 10), and use a for loop to print out the value of each cube. cubes.py cubes = [] for number in range ( 1 , 11 ): cube = number ** 3 cubes . append ( cube ) for cube in cubes : print ( cube ) Output: 1 8 27 ... 512 729 1000 4-9: Cube Comprehension Use a list comprehension to generate a list of the first 10 cubes. cube_comprehension.py cubes = [ number ** 3 for number in range ( 1 , 11 )] for cube in cubes : print ( cube ) Output: 1 8 27 ... 512 729 1000 4-11: My Pizzas, Your Pizzas Start with your program from Exercise 4-1 (page 56). Make a copy of the list of pizzas, and call it friend_pizzas . Then, do the following: Add a new pizza to the original list. Add a different pizza to the list friend_pizzas . Prove that you have two separate lists. Print the message, My favorite pizzas are: , and then use a for loop to print the first list. Print the message, My friend's favorite pizzas are: , and then use a for loop to print the second list. Make sure each new pizza is stored in the appropriate list. my_pizzas_your_pizzas.py favorite_pizzas = [ 'pepperoni' , 'hawaiian' , 'veggie' ] friend_pizzas = favorite_pizzas [:] favorite_pizzas . append ( \"meat lover's\" ) friend_pizzas . append ( 'pesto' ) print ( \"My favorite pizzas are:\" ) for pizza in favorite_pizzas : print ( f \"- { pizza } \" ) print ( \" \\n My friend's favorite pizzas are:\" ) for pizza in friend_pizzas : print ( f \"- { pizza } \" ) Output: My favorite pizzas are: - pepperoni - hawaiian - veggie - meat lover's My friend's favorite pizzas are: - pepperoni - hawaiian - veggie - pesto 4-12: More Loops All versions of foods.py in this section have avoided using for loops when printing, to save space. Choose a version of foods.py , and write two for loops to print each list of foods. more_loops.py my_foods = [ 'pizza' , 'falafel' , 'carrot cake' ] friend_foods = my_foods [:] my_foods . append ( 'cannoli' ) friend_foods . append ( 'ice cream' ) print ( \"My favorite foods are:\" ) for food in my_foods : print ( f \"- { food } \" ) print ( \" \\n My friend's favorite foods are:\" ) for food in friend_foods : print ( f \"- { food } \" ) Output: My favorite foods are: - pizza - falafel - carrot cake - cannoli My friend's favorite foods are: - pizza - falafel - carrot cake - ice cream 4-13: Buffet A buffet-style restaurant offers only five basic foods. Think of five simple foods, and store them in a tuple. Use a for loop to print each food the restaurant offers. Try to modify one of the items, and make sure that Python rejects the change. The restaurant changes its menu, replacing two of the items with different foods. Add a line that rewrites the tuple, and then use a for loop to print each of the items on the revised menu. buffet.py menu_items = ( 'rockfish sandwich' , 'halibut nuggets' , 'smoked salmon chowder' , 'salmon burger' , 'crab cakes' , ) print ( \"You can choose from the following menu items:\" ) for item in menu_items : print ( f \"- { item } \" ) menu_items = ( 'rockfish sandwich' , 'halibut nuggets' , 'smoked salmon chowder' , 'black cod tips' , 'king crab legs' , ) print ( \" \\n Our menu has been updated.\" ) print ( \"You can now choose from the following items:\" ) for item in menu_items : print ( f \"- { item } \" ) Output: You can choose from the following menu items: - rockfish sandwich - halibut nuggets - smoked salmon chowder - salmon burger - crab cakes Our menu has been updated. You can now choose from the following items: - rockfish sandwich - halibut nuggets - smoked salmon chowder - black cod tips - king crab legs","title":"Chapter 4"},{"location":"solutions/chapter_4/#solutions-chapter-4","text":"","title":"Solutions - Chapter 4"},{"location":"solutions/chapter_4/#4-1-pizzas","text":"Think of at least three kinds of your favorite pizza. Store these pizza names in a list, and then use a for loop to print the name of each pizza. Modify your for loop to print a sentence using the name of the pizza, instead of printing just the name of the pizza. For each pizza, you should have one line of output containing a simple statement like I like pepperoni pizza. Add a line at the end of your program, outside the for loop, that states how much you like pizza. The output should consist of three or more lines about the kinds of pizza you like and then an additional sentence, such as I really love pizza! pizzas.py favorite_pizzas = [ 'pepperoni' , 'hawaiian' , 'veggie' ] # Print the names of all the pizzas. for pizza in favorite_pizzas : print ( pizza ) print ( \" \\n \" ) # Print a sentence about each pizza. for pizza in favorite_pizzas : print ( f \"I really love { pizza } pizza!\" ) print ( \" \\n I really love pizza!\" ) Output: pepperoni hawaiian veggie I really love pepperoni pizza! I really love hawaiian pizza! I really love veggie pizza! I really love pizza!","title":"4-1: Pizzas"},{"location":"solutions/chapter_4/#4-2-animals","text":"Think of at least three different animals that have a common characteristic. Store the names of these animals in a list, and then use a for loop to print out the name of each animal. - Modify your program to print a statement about each animal, such as A dog would make a great pet. - Add a line at the end of your program, stating what these animals have in common. You could print a sentence, such as Any of these animals would make a great pet! animals.py animals = [ \"spider monkey\" , \"lemur\" , \"giraffe\" ] # Print each animal. for animal in animals : print ( animal ) print ( \" \\n \" ) # Print a statement about each animal. for animal in animals : print ( f \"A { animal } has a long tail.\" ) print ( \" \\n All of these animals have long tails.\" ) Output: spider monkey lemur giraffe A spider monkey has a long tail. A lemur has a long tail. A giraffe has a long tail. All of these animals have long tails.","title":"4-2: Animals"},{"location":"solutions/chapter_4/#4-3-counting-to-twenty","text":"Use a for loop to print the numbers from 1 to 20, inclusive. counting_to_twenty.py numbers = list ( range ( 1 , 21 )) for number in numbers : print ( number ) Output: 1 2 3 ... 18 19 20","title":"4-3: Counting to Twenty"},{"location":"solutions/chapter_4/#4-5-summing-a-million","text":"Make a list of the numbers from one to one million, and then use min() and max() to make sure your list actually starts at one and ends at one million. Also, use the sum() function to see how quickly Python can add a million numbers. summing_a_million.py numbers = list ( range ( 1 , 1_000_001 )) print ( min ( numbers )) print ( max ( numbers )) print ( sum ( numbers )) Output: 1 1000000 500000500000","title":"4-5: Summing a Million"},{"location":"solutions/chapter_4/#4-6-odd-numbers","text":"Use the third argument of the range() function to make a list of the odd numbers from 1 to 20. Use a for loop to print each number. odd_numbers.py odd_numbers = list ( range ( 1 , 20 , 2 )) for number in odd_numbers : print ( number ) Output: 1 3 5 ... 15 17 19","title":"4-6: Odd Numbers"},{"location":"solutions/chapter_4/#4-7-threes","text":"Make a list of the multiples of 3 from 3 to 30. Use a for loop to print the numbers in your list. threes.py threes = list ( range ( 3 , 31 , 3 )) for number in threes : print ( number ) Output: 3 6 9 ... 24 27 30","title":"4-7: Threes"},{"location":"solutions/chapter_4/#4-8-cubes","text":"A number raised to the third power is called a cube . For example, the cube of 2 is written as 2**3 in Python. Make a list of the first 10 cubes (that is, the cube of each integer from 1 through 10), and use a for loop to print out the value of each cube. cubes.py cubes = [] for number in range ( 1 , 11 ): cube = number ** 3 cubes . append ( cube ) for cube in cubes : print ( cube ) Output: 1 8 27 ... 512 729 1000","title":"4-8: Cubes"},{"location":"solutions/chapter_4/#4-9-cube-comprehension","text":"Use a list comprehension to generate a list of the first 10 cubes. cube_comprehension.py cubes = [ number ** 3 for number in range ( 1 , 11 )] for cube in cubes : print ( cube ) Output: 1 8 27 ... 512 729 1000","title":"4-9: Cube Comprehension"},{"location":"solutions/chapter_4/#4-11-my-pizzas-your-pizzas","text":"Start with your program from Exercise 4-1 (page 56). Make a copy of the list of pizzas, and call it friend_pizzas . Then, do the following: Add a new pizza to the original list. Add a different pizza to the list friend_pizzas . Prove that you have two separate lists. Print the message, My favorite pizzas are: , and then use a for loop to print the first list. Print the message, My friend's favorite pizzas are: , and then use a for loop to print the second list. Make sure each new pizza is stored in the appropriate list. my_pizzas_your_pizzas.py favorite_pizzas = [ 'pepperoni' , 'hawaiian' , 'veggie' ] friend_pizzas = favorite_pizzas [:] favorite_pizzas . append ( \"meat lover's\" ) friend_pizzas . append ( 'pesto' ) print ( \"My favorite pizzas are:\" ) for pizza in favorite_pizzas : print ( f \"- { pizza } \" ) print ( \" \\n My friend's favorite pizzas are:\" ) for pizza in friend_pizzas : print ( f \"- { pizza } \" ) Output: My favorite pizzas are: - pepperoni - hawaiian - veggie - meat lover's My friend's favorite pizzas are: - pepperoni - hawaiian - veggie - pesto","title":"4-11: My Pizzas, Your Pizzas"},{"location":"solutions/chapter_4/#4-12-more-loops","text":"All versions of foods.py in this section have avoided using for loops when printing, to save space. Choose a version of foods.py , and write two for loops to print each list of foods. more_loops.py my_foods = [ 'pizza' , 'falafel' , 'carrot cake' ] friend_foods = my_foods [:] my_foods . append ( 'cannoli' ) friend_foods . append ( 'ice cream' ) print ( \"My favorite foods are:\" ) for food in my_foods : print ( f \"- { food } \" ) print ( \" \\n My friend's favorite foods are:\" ) for food in friend_foods : print ( f \"- { food } \" ) Output: My favorite foods are: - pizza - falafel - carrot cake - cannoli My friend's favorite foods are: - pizza - falafel - carrot cake - ice cream","title":"4-12: More Loops"},{"location":"solutions/chapter_4/#4-13-buffet","text":"A buffet-style restaurant offers only five basic foods. Think of five simple foods, and store them in a tuple. Use a for loop to print each food the restaurant offers. Try to modify one of the items, and make sure that Python rejects the change. The restaurant changes its menu, replacing two of the items with different foods. Add a line that rewrites the tuple, and then use a for loop to print each of the items on the revised menu. buffet.py menu_items = ( 'rockfish sandwich' , 'halibut nuggets' , 'smoked salmon chowder' , 'salmon burger' , 'crab cakes' , ) print ( \"You can choose from the following menu items:\" ) for item in menu_items : print ( f \"- { item } \" ) menu_items = ( 'rockfish sandwich' , 'halibut nuggets' , 'smoked salmon chowder' , 'black cod tips' , 'king crab legs' , ) print ( \" \\n Our menu has been updated.\" ) print ( \"You can now choose from the following items:\" ) for item in menu_items : print ( f \"- { item } \" ) Output: You can choose from the following menu items: - rockfish sandwich - halibut nuggets - smoked salmon chowder - salmon burger - crab cakes Our menu has been updated. You can now choose from the following items: - rockfish sandwich - halibut nuggets - smoked salmon chowder - black cod tips - king crab legs","title":"4-13: Buffet"},{"location":"solutions/chapter_5/","text":"Solutions - Chapter 5 5-3: Alien Colors #1 Imagine an alien was just shot down in a game. Create a variable called alien_color and assign it a value of 'green' , 'yellow' , or 'red' . Write an if statement to test whether the alien's color is green. If it is, print a message that the player just earned 5 points. Write one version of this program that passes the if test and another that fails. (The version that fails will have no output.) Passing version alien_colors_1.py alien_color = 'green' if alien_color == 'green' : print ( \"You just earned 5 points!\" ) Output: You just earned 5 points! Failing version alien_colors_1_fail.py alien_color = 'red' if alien_color == 'green' : print ( \"You just earned 5 points!\" ) (no output) 5-4: Alien Colors #2 Choose a color for an alien as you did in Exercise 5-3, and write an if-else chain. If the alien's color is green, print a statement that the player just earned 5 points for shooting the alien. If the alien's color isn't green, print a statement that the player just earned 10 points. Write one version of this program that runs the if block and another that runs the else block. if block runs alien_colors_2_if_block.py alien_color = 'green' if alien_color == 'green' : print ( \"You just earned 5 points!\" ) else : print ( \"You just earned 10 points!\" ) Output: You just earned 5 points! else block runs alien_colors_2_else_block.py alien_color = 'yellow' if alien_color == 'green' : print ( \"You just earned 5 points!\" ) else : print ( \"You just earned 10 points!\" ) Output: You just earned 10 points! 5-5: Alien Colors #3 Turn your if-else chain from Exercise 5-4 into an if-elif-else cahin. If the alien is green, print a message that the player earned 5 points. If the alien is yellow, print a message that the player earned 10 points. If the alien is red, print a message that the player earned 15 points. Write three versions of this program, making sure each message is printed for the appropriate color alien. alien_colors_3.py alien_color = 'red' if alien_color == 'green' : print ( \"You just earned 5 points!\" ) elif alien_color == 'yellow' : print ( \"You just earned 10 points!\" ) else : print ( \"You just earned 15 points!\" ) Output for 'red' alien: You just earned 15 points! 5-6: Stages of Life Write an if-elif-else chain that determines a person's stage of life. Set a value for the variable age , and then: If the person is less than 2 years old, print a message that the person is a baby. If the person is at least 2 years old but less than 4, print a message that the person is a toddler. If the person is at least 4 years old but less than 13, print a message that the person is a toddler. If the person is at least 13 years old but less than 20, print a message that the person is a toddler. If the person is at least 20 years old but less than 65, print a message that the person is a toddler. If the person is age 65 or older, print a message that the person is an elder. stages_of_life.py age = 17 if age < 2 : print ( \"You're a baby!\" ) elif age < 4 : print ( \"You're a toddler!\" ) elif age < 13 : print ( \"You're a kid!\" ) elif age < 20 : print ( \"You're a teenager!\" ) elif age < 65 : print ( \"You're an adult!\" ) else : print ( \"You're an elder!\" ) Output: You're a teenager! 5-7: Favorite Fruit Make a list of your favorite fruits, and then write a series of independent if statements that check for certain fruits in your list. Make a list of your three favorite fruits and call it favorite_fruits . Write five if statements. Each should check whether a certain kind of fruit is in your list. If the fruit is in your list, the if block should print a statement, such as You really like bananas! favorite_fruits.py favorite_fruits = [ 'blueberries' , 'salmonberries' , 'peaches' ] if 'bananas' in favorite_fruits : print ( \"You really like bananas!\" ) if 'apples' in favorite_fruits : print ( \"You really like apples!\" ) if 'blueberries' in favorite_fruits : print ( \"You really like blueberries!\" ) if 'kiwis' in favorite_fruits : print ( \"You really like kiwis!\" ) if 'peaches' in favorite_fruits : print ( \"You really like peaches!\" ) Output: You really like blueberries! You really like peaches! 5-8: Hello Admin Make a list of five or more usernames, including the name 'admin' . Imagine you are writing code that will print a greeting to each user after they log in to a website. Loop through the list, and print a greeting to each user. If the username is 'admin' , print a special greeting, such as Hello admin, would you like to see a status report? Otherwise, print a generic greeting, such as Hello Jaden, thank you for loggin in again. hello_admin.py usernames = [ 'eric' , 'willie' , 'admin' , 'erin' , 'ever' ] for username in usernames : if username == 'admin' : print ( \"Hello admin, would you like to see a status report?\" ) else : print ( f \"Hello { username } , thank you for loggin in again!\" ) Output: Hello eric, thank you for logging in again! Hello willie, thank you for logging in again! Hello admin, would you like to see a status report? Hello erin, thank you for logging in again! Hello ever, thank you for logging in again! 5-9: No Users Add an if test to hello_admin.py to make sure the list of users is not empty. If the list is emtpy, print the message We need to find some users! Remove all of the usernames from your list, and make sure the correct message is printed. no_users.py usernames = [] if usernames : for username in usernames : if username == 'admin' : print ( \"Hello admin, would you like to see a status report?\" ) else : print ( f \"Hello { username } , thank you for loggin in again!\" ) else : print ( \"We need to find some users!\" ) Output: We need to find some users! 5-10: Checking Usernames Do the following to create a program that simulates how websites ensure that everyone has a unique username. Make a list of five or more usernames called current_users . Make another list of five usernames called new_users . Make sure one or two of the new usernames are also in the current_users list. Loop through the new_users list to see if each new username has already been used. If it has, print a message that the person will need to enter a new username. If a username has not been used, print a message saying that the username is available. Make sure your comparison is case insensitive. If 'John' has been used, 'JOHN' should not be accepted. (To do this, you\u2019ll need to make a copy of current_users containing the lowercase versions of all existing users.) checking_usernames.py current_users = [ 'eric' , 'willie' , 'admin' , 'erin' , 'Ever' ] new_users = [ 'sarah' , 'Willie' , 'PHIL' , 'ever' , 'Iona' ] current_users_lower = [ user . lower () for user in current_users ] for new_user in new_users : if new_user . lower () in current_users_lower : print ( f \"Sorry { new_user } , that name is taken.\" ) else : print ( f \"Great, { new_user } is still available.\" ) Output: Great, sarah is still available. Sorry Willie, that name is taken. Great, PHIL is still available. Sorry ever, that name is taken. Great, Iona is still available. Note If you're not comfortable with list comprehensions yet, the list current_users_lower can be generated using a loop: current_users_lower = [] for user in current_users : current_users_lower . append ( user . lower ()) 5-11: Ordinal Numbers Ordinal numbers indicate their position in a list, such as 1st or 2nd . Most ordinal numbers end in th , except 1, 2, and 3. Store the numbers 1 through 9 in a list. Loop through the list. Use an if-elif-else chain inside the loop to print the proper ordinal ending for each number. Your output should read \"1st 2nd 3rd 4th 5th 6th 7th 8th 9th\" , and each result should be on a separate line. ordinal_numbers.py numbers = list ( range ( 1 , 10 )) for number in numbers : if number == 1 : print ( \"1st\" ) elif number == 2 : print ( \"2nd\" ) elif number == 3 : print ( \"3rd\" ) else : print ( f \" { number } th\" ) Output: 1st 2nd 3rd 4th 5th 6th 7th 8th 9th","title":"Chapter 5"},{"location":"solutions/chapter_5/#solutions-chapter-5","text":"","title":"Solutions - Chapter 5"},{"location":"solutions/chapter_5/#5-3-alien-colors-1","text":"Imagine an alien was just shot down in a game. Create a variable called alien_color and assign it a value of 'green' , 'yellow' , or 'red' . Write an if statement to test whether the alien's color is green. If it is, print a message that the player just earned 5 points. Write one version of this program that passes the if test and another that fails. (The version that fails will have no output.)","title":"5-3: Alien Colors #1"},{"location":"solutions/chapter_5/#passing-version","text":"alien_colors_1.py alien_color = 'green' if alien_color == 'green' : print ( \"You just earned 5 points!\" ) Output: You just earned 5 points!","title":"Passing version"},{"location":"solutions/chapter_5/#failing-version","text":"alien_colors_1_fail.py alien_color = 'red' if alien_color == 'green' : print ( \"You just earned 5 points!\" ) (no output)","title":"Failing version"},{"location":"solutions/chapter_5/#5-4-alien-colors-2","text":"Choose a color for an alien as you did in Exercise 5-3, and write an if-else chain. If the alien's color is green, print a statement that the player just earned 5 points for shooting the alien. If the alien's color isn't green, print a statement that the player just earned 10 points. Write one version of this program that runs the if block and another that runs the else block.","title":"5-4: Alien Colors #2"},{"location":"solutions/chapter_5/#if-block-runs","text":"alien_colors_2_if_block.py alien_color = 'green' if alien_color == 'green' : print ( \"You just earned 5 points!\" ) else : print ( \"You just earned 10 points!\" ) Output: You just earned 5 points!","title":"if block runs"},{"location":"solutions/chapter_5/#else-block-runs","text":"alien_colors_2_else_block.py alien_color = 'yellow' if alien_color == 'green' : print ( \"You just earned 5 points!\" ) else : print ( \"You just earned 10 points!\" ) Output: You just earned 10 points!","title":"else block runs"},{"location":"solutions/chapter_5/#5-5-alien-colors-3","text":"Turn your if-else chain from Exercise 5-4 into an if-elif-else cahin. If the alien is green, print a message that the player earned 5 points. If the alien is yellow, print a message that the player earned 10 points. If the alien is red, print a message that the player earned 15 points. Write three versions of this program, making sure each message is printed for the appropriate color alien. alien_colors_3.py alien_color = 'red' if alien_color == 'green' : print ( \"You just earned 5 points!\" ) elif alien_color == 'yellow' : print ( \"You just earned 10 points!\" ) else : print ( \"You just earned 15 points!\" ) Output for 'red' alien: You just earned 15 points!","title":"5-5: Alien Colors #3"},{"location":"solutions/chapter_5/#5-6-stages-of-life","text":"Write an if-elif-else chain that determines a person's stage of life. Set a value for the variable age , and then: If the person is less than 2 years old, print a message that the person is a baby. If the person is at least 2 years old but less than 4, print a message that the person is a toddler. If the person is at least 4 years old but less than 13, print a message that the person is a toddler. If the person is at least 13 years old but less than 20, print a message that the person is a toddler. If the person is at least 20 years old but less than 65, print a message that the person is a toddler. If the person is age 65 or older, print a message that the person is an elder. stages_of_life.py age = 17 if age < 2 : print ( \"You're a baby!\" ) elif age < 4 : print ( \"You're a toddler!\" ) elif age < 13 : print ( \"You're a kid!\" ) elif age < 20 : print ( \"You're a teenager!\" ) elif age < 65 : print ( \"You're an adult!\" ) else : print ( \"You're an elder!\" ) Output: You're a teenager!","title":"5-6: Stages of Life"},{"location":"solutions/chapter_5/#5-7-favorite-fruit","text":"Make a list of your favorite fruits, and then write a series of independent if statements that check for certain fruits in your list. Make a list of your three favorite fruits and call it favorite_fruits . Write five if statements. Each should check whether a certain kind of fruit is in your list. If the fruit is in your list, the if block should print a statement, such as You really like bananas! favorite_fruits.py favorite_fruits = [ 'blueberries' , 'salmonberries' , 'peaches' ] if 'bananas' in favorite_fruits : print ( \"You really like bananas!\" ) if 'apples' in favorite_fruits : print ( \"You really like apples!\" ) if 'blueberries' in favorite_fruits : print ( \"You really like blueberries!\" ) if 'kiwis' in favorite_fruits : print ( \"You really like kiwis!\" ) if 'peaches' in favorite_fruits : print ( \"You really like peaches!\" ) Output: You really like blueberries! You really like peaches!","title":"5-7: Favorite Fruit"},{"location":"solutions/chapter_5/#5-8-hello-admin","text":"Make a list of five or more usernames, including the name 'admin' . Imagine you are writing code that will print a greeting to each user after they log in to a website. Loop through the list, and print a greeting to each user. If the username is 'admin' , print a special greeting, such as Hello admin, would you like to see a status report? Otherwise, print a generic greeting, such as Hello Jaden, thank you for loggin in again. hello_admin.py usernames = [ 'eric' , 'willie' , 'admin' , 'erin' , 'ever' ] for username in usernames : if username == 'admin' : print ( \"Hello admin, would you like to see a status report?\" ) else : print ( f \"Hello { username } , thank you for loggin in again!\" ) Output: Hello eric, thank you for logging in again! Hello willie, thank you for logging in again! Hello admin, would you like to see a status report? Hello erin, thank you for logging in again! Hello ever, thank you for logging in again!","title":"5-8: Hello Admin"},{"location":"solutions/chapter_5/#5-9-no-users","text":"Add an if test to hello_admin.py to make sure the list of users is not empty. If the list is emtpy, print the message We need to find some users! Remove all of the usernames from your list, and make sure the correct message is printed. no_users.py usernames = [] if usernames : for username in usernames : if username == 'admin' : print ( \"Hello admin, would you like to see a status report?\" ) else : print ( f \"Hello { username } , thank you for loggin in again!\" ) else : print ( \"We need to find some users!\" ) Output: We need to find some users!","title":"5-9: No Users"},{"location":"solutions/chapter_5/#5-10-checking-usernames","text":"Do the following to create a program that simulates how websites ensure that everyone has a unique username. Make a list of five or more usernames called current_users . Make another list of five usernames called new_users . Make sure one or two of the new usernames are also in the current_users list. Loop through the new_users list to see if each new username has already been used. If it has, print a message that the person will need to enter a new username. If a username has not been used, print a message saying that the username is available. Make sure your comparison is case insensitive. If 'John' has been used, 'JOHN' should not be accepted. (To do this, you\u2019ll need to make a copy of current_users containing the lowercase versions of all existing users.) checking_usernames.py current_users = [ 'eric' , 'willie' , 'admin' , 'erin' , 'Ever' ] new_users = [ 'sarah' , 'Willie' , 'PHIL' , 'ever' , 'Iona' ] current_users_lower = [ user . lower () for user in current_users ] for new_user in new_users : if new_user . lower () in current_users_lower : print ( f \"Sorry { new_user } , that name is taken.\" ) else : print ( f \"Great, { new_user } is still available.\" ) Output: Great, sarah is still available. Sorry Willie, that name is taken. Great, PHIL is still available. Sorry ever, that name is taken. Great, Iona is still available. Note If you're not comfortable with list comprehensions yet, the list current_users_lower can be generated using a loop: current_users_lower = [] for user in current_users : current_users_lower . append ( user . lower ())","title":"5-10: Checking Usernames"},{"location":"solutions/chapter_5/#5-11-ordinal-numbers","text":"Ordinal numbers indicate their position in a list, such as 1st or 2nd . Most ordinal numbers end in th , except 1, 2, and 3. Store the numbers 1 through 9 in a list. Loop through the list. Use an if-elif-else chain inside the loop to print the proper ordinal ending for each number. Your output should read \"1st 2nd 3rd 4th 5th 6th 7th 8th 9th\" , and each result should be on a separate line. ordinal_numbers.py numbers = list ( range ( 1 , 10 )) for number in numbers : if number == 1 : print ( \"1st\" ) elif number == 2 : print ( \"2nd\" ) elif number == 3 : print ( \"3rd\" ) else : print ( f \" { number } th\" ) Output: 1st 2nd 3rd 4th 5th 6th 7th 8th 9th","title":"5-11: Ordinal Numbers"},{"location":"solutions/chapter_6/","text":"Solutions - Chapter 6 6-1: Person Use a dictionary to store information about a person you know. Store their first name, last name, age, and the city in which they live. You should have keys such as first_name , last_name , age , and city . Print each piece of information stored in your dictionary. person.py person = { 'first_name' : 'eric' , 'last_name' : 'matthes' , 'age' : 43 , 'city' : 'sitka' , } print ( person [ 'first_name' ]) print ( person [ 'last_name' ]) print ( person [ 'age' ]) print ( person [ 'city' ]) Output: eric matthes 43 sitka 6-2: Favorite Numbers Use a dictionary to store people's favorite numbers. Think of five names, and use them as keys in your dictionary. Think of a favorite number for each person, and store each as a value in your dictionary. Print each person's name and their favorite number. For even more fun, poll a few friends and get some actual data for your program. favorite_numbers.py favorite_numbers = { 'mandy' : 42 , 'micah' : 23 , 'gus' : 7 , 'hank' : 1_000_000 , 'maggie' : 0 , } num = favorite_numbers [ 'mandy' ] print ( f \"Mandy's favorite number is { num } .\" ) num = favorite_numbers [ 'micah' ] print ( f \"Micah's favorite number is { num } .\" ) num = favorite_numbers [ 'gus' ] print ( f \"Gus's favorite number is { num } .\" ) num = favorite_numbers [ 'hank' ] print ( f \"Hank's favorite number is { num } .\" ) num = favorite_numbers [ 'maggie' ] print ( f \"Maggie's favorite number is { num } .\" ) Output: Mandy's favorite number is 42. Micah's favorite number is 23. Gus's favorite number is 7. Hank's favorite number is 1000000. Maggie's favorite number is 0. 6-3: Glossary A Python dictionary can be used to model an actual dictionary. However, to avoid confusion, let's call it a glossary. Think of five programming words you've learned about in the previous chapters. Use these words as the keys in your glossary, and store their meanings as values. Print each word and its meaning as neatly formatted output. You might print the word followed by a colon and then its meaning, or print the word on one line and then print its meaning indented on a second line. Use the newline character ( '\\n' ) to insert a blank line between each word-meaning pair in your output. glossary.py glossary = { 'string' : 'A series of characters.' , 'comment' : 'A note in a program that the Python interpreter ignores.' , 'list' : 'A collection of items in a particular order.' , 'loop' : 'Work through a collection of items, one at a time.' , 'dictionary' : \"A collection of key-value pairs.\" , } word = 'string' print ( f \" \\n { word . title () } : { glossary [ word ] } \" ) word = 'comment' print ( f \" \\n { word . title () } : { glossary [ word ] } \" ) word = 'list' print ( f \" \\n { word . title () } : { glossary [ word ] } \" ) word = 'loop' print ( f \" \\n { word . title () } : { glossary [ word ] } \" ) word = 'dictionary' print ( f \" \\n { word . title () } : { glossary [ word ] } \" ) Output: String: A series of characters. Comment: A note in a program that the Python interpreter ignores. List: A collection of items in a particular order. Loop: Work through a collection of items, one at a time. Dictionary: A collection of key-value pairs. 6-4: Glossary 2 Now that you know how to loop through a dictionary, clean up the code from Exercise 6-3 (page 99) by replacing your series of print() calls with a loop that runs through the dictionary's keys and values. When you're sure that your loop works, add five more Python terms to your glossary. When you run your program again, these new words and meanings should automatically be included in the output. glossary_2.py glossary = { 'string' : 'A series of characters.' , 'comment' : 'A note in a program that the Python interpreter ignores.' , 'list' : 'A collection of items in a particular order.' , 'loop' : 'Work through a collection of items, one at a time.' , 'dictionary' : \"A collection of key-value pairs.\" , 'key' : 'The first item in a key-value pair in a dictionary.' , 'value' : 'An item associated with a key in a dictionary.' , 'conditional test' : 'A comparison between two values.' , 'float' : 'A numerical value with a decimal component.' , 'boolean expression' : 'An expression that evaluates to True or False.' , } for word , definition in glossary . items (): print ( f \" \\n { word . title () } : { definition } \" ) Output: String: A series of characters. Comment: A note in a program that the Python interpreter ignores. List: A collection of items in a particular order. Loop: Work through a collection of items, one at a time. Dictionary: A collection of key-value pairs. Key: The first item in a key-value pair in a dictionary. Value: An item associated with a key in a dictionary. Conditional Test: A comparison between two values. Float: A numerical value with a decimal component. Boolean Expression: An expression that evaluates to True or False. 6-5: Rivers Make a dictionary containing three major rivers and the country each river runs through. One key-value pair might be 'nile': 'egypt' . Use a loop to print a sentence about each river, such as The Nile runs through Egypt. Use a loop to print the name of each river included in the dictionary. Use a loop to print the name of each country included in the dictionary. rivers.py rivers = { 'nile' : 'egypt' , 'mississippi' : 'united states' , 'fraser' : 'canada' , 'kuskokwim' : 'alaska' , 'yangtze' : 'china' , } for river , country in rivers . items (): print ( f \"The { river . title () } flows through { country . title () } .\" ) print ( \" \\n The following rivers are included in this data set:\" ) for river in rivers . keys (): print ( f \"- { river . title () } \" ) print ( \" \\n The following countries are included in this data set:\" ) for country in rivers . values (): print ( f \"- { country . title () } \" ) Output*: The Nile flows through Egypt. The Mississippi flows through United States. The Fraser flows through Canada. The Kuskokwim flows through Alaska. The Yangtze flows through China. The following rivers are included in this data set: - Nile - Mississippi - Fraser - Kuskokwim - Yangtze The following countries are included in this data set: - Egypt - United States - Canada - Alaska - China * Sometimes we like to think of Alaska as our own separate country. 6-6: Polling Use the code in favorite_languages.py (page 96). Make a list of people who should take the favorite languages poll. Include some names that are already in the dictionary and some that are not. Loop through the list of people who should take the poll. If they have already taken the poll, print a message thanking them for responding. If they have not yet taken the poll, print a message inviting them to take the poll. polling.py favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name , language in favorite_languages . items (): print ( f \" { name . title () } 's favorite language is { language . title () } .\" ) print ( \" \\n \" ) coders = [ 'phil' , 'josh' , 'david' , 'becca' , 'sarah' , 'matt' , 'danielle' ] for coder in coders : if coder in favorite_languages . keys (): print ( f \"Thank you for taking the poll, { coder . title () } !\" ) else : print ( f \" { coder . title () } , what's your favorite programming language?\" ) Output: Jen's favorite language is Python. Sarah's favorite language is C. Edward's favorite language is Ruby. Phil's favorite language is Python. Thank you for taking the poll, Phil! Josh, what's your favorite programming language? David, what's your favorite programming language? Becca, what's your favorite programming language? Thank you for taking the poll, Sarah! Matt, what's your favorite programming language? Danielle, what's your favorite programming language? 6-7: People Start with the program you wrote for Exercise 6-1 (page 98). Make two new dictionaries representing different people, and store all three dictionaries in a list called people . Loop through your list of people. As you loop through the list, print everything you know about each person. people.py # Make an empty list to store people in. people = [] # Define some people, and add them to the list. person = { 'first_name' : 'eric' , 'last_name' : 'matthes' , 'age' : 46 , 'city' : 'sitka' , } people . append ( person ) person = { 'first_name' : 'lemmy' , 'last_name' : 'matthes' , 'age' : 2 , 'city' : 'sitka' , } people . append ( person ) person = { 'first_name' : 'willie' , 'last_name' : 'matthes' , 'age' : 11 , 'city' : 'sitka' , } people . append ( person ) # Display all of the information in the dictionary. for person in people : name = f \" { person [ 'first_name' ] . title () } { person [ 'last_name' ] . title () } \" age = person [ 'age' ] city = person [ 'city' ] . title () print ( f \" { name } , of { city } , is { age } years old.\" ) Output: Eric Matthes, of Sitka, is 46 years old. Lemmy Matthes, of Sitka, is 2 years old. Willie Matthes, of Sitka, is 11 years old. 6-8: Pets Make several dictionaries, where each dictionary represents a different pet. In each dictionary, include the kind of animal and the owner\u2019s name. Store these dictionaries in a list called pets . Next, loop through your list and as you do, print everything you know about each pet. pets.py # Make an empty list to store the pets in. pets = [] # Make individual pets, and store each one in the list. pet = { 'animal type' : 'python' , 'name' : 'john' , 'owner' : 'guido' , 'weight' : 43 , 'eats' : 'bugs' , } pets . append ( pet ) pet = { 'animal type' : 'chicken' , 'name' : 'clarence' , 'owner' : 'tiffany' , 'weight' : 2 , 'eats' : 'seeds' , } pets . append ( pet ) pet = { 'animal type' : 'dog' , 'name' : 'peso' , 'owner' : 'eric' , 'weight' : 37 , 'eats' : 'shoes' , } pets . append ( pet ) # Display information about each pet. for pet in pets : print ( f \" \\n Here's what I know about { pet [ 'name' ] . title () } :\" ) for key , value in pet . items (): print ( f \" \\t { key } : { value } \" ) Output: Here's what I know about John: animal type: python name: john owner: guido weight: 43 eats: bugs Here's what I know about Clarence: animal type: chicken name: clarence owner: tiffany weight: 2 eats: seeds Here's what I know about Peso: animal type: dog name: peso owner: eric weight: 37 eats: shoes 6-9: Favorite Places Make a dictionary called favorite_places . Think of three names to use as keys in the dictionary, and store one to three favorite places for each person. To make this exericse a bit more interesting, ask some friends to name a few of their favorite places. Loop through the dictionary, and print each person's name and their favorite places. favorite_places.py favorite_places = { 'eric' : [ 'bear mountain' , 'death valley' , 'tierra del fuego' ], 'erin' : [ 'hawaii' , 'iceland' ], 'willie' : [ 'mt. verstovia' , 'the playground' , 'new hampshire' ] } for name , places in favorite_places . items (): print ( f \" \\n { name . title () } likes the following places:\" ) for place in places : print ( f \"- { place . title () } \" ) Output: Eric likes the following places: - Bear Mountain - Death Valley - Tierra Del Fuego Erin likes the following places: - Hawaii - Iceland Willie likes the following places: - Mt. Verstovia - The Playground - New Hampshire 6-10: Favorite Numbers Modify your program from Exercise 6-2 (page 98) so each person can have more than one favorite number. Then print each person's name along with their favorite numbers. favorite_numbers_6_10.py favorite_numbers = { 'mandy' : [ 42 , 17 ], 'micah' : [ 42 , 39 , 56 ], 'gus' : [ 7 , 12 ], } for name , numbers in favorite_numbers . items (): print ( f \" \\n { name . title () } likes the following numbers:\" ) for number in numbers : print ( f \" { number } \" ) Output: Mandy likes the following numbers: 42 17 Micah likes the following numbers: 42 39 56 Gus likes the following numbers: 7 12 6-11: Cities Make a dictionary called cities . Use the names of three cities as keys in your dictionary. Create a dictionary of information about each city and include the country that the city is in, its approximate population, and one fact about that city. The keys for each city's dictionary should be something like country , population , and fact . Print the name of each city and all of the information you have stored about it. cities.py cities = { 'santiago' : { 'country' : 'chile' , 'population' : 6_310_000 , 'nearby mountains' : 'andes' , }, 'talkeetna' : { 'country' : 'united states' , 'population' : 876 , 'nearby mountains' : 'alaska range' , }, 'kathmandu' : { 'country' : 'nepal' , 'population' : 975_453 , 'nearby mountains' : 'himilaya' , } } for city , city_info in cities . items (): country = city_info [ 'country' ] . title () population = city_info [ 'population' ] mountains = city_info [ 'nearby mountains' ] . title () print ( f \" \\n { city . title () } is in { country } .\" ) print ( f \" It has a population of about { population } .\" ) print ( f \" The { mountains } mounats are nearby.\" ) Output: Santiago is in Chile. It has a population of about 6310000. The Andes mounats are nearby. Talkeetna is in United States. It has a population of about 876. The Alaska Range mounats are nearby. Kathmandu is in Nepal. It has a population of about 975453. The Himilaya mounats are nearby.","title":"Chapter 6"},{"location":"solutions/chapter_6/#solutions-chapter-6","text":"","title":"Solutions - Chapter 6"},{"location":"solutions/chapter_6/#6-1-person","text":"Use a dictionary to store information about a person you know. Store their first name, last name, age, and the city in which they live. You should have keys such as first_name , last_name , age , and city . Print each piece of information stored in your dictionary. person.py person = { 'first_name' : 'eric' , 'last_name' : 'matthes' , 'age' : 43 , 'city' : 'sitka' , } print ( person [ 'first_name' ]) print ( person [ 'last_name' ]) print ( person [ 'age' ]) print ( person [ 'city' ]) Output: eric matthes 43 sitka","title":"6-1: Person"},{"location":"solutions/chapter_6/#6-2-favorite-numbers","text":"Use a dictionary to store people's favorite numbers. Think of five names, and use them as keys in your dictionary. Think of a favorite number for each person, and store each as a value in your dictionary. Print each person's name and their favorite number. For even more fun, poll a few friends and get some actual data for your program. favorite_numbers.py favorite_numbers = { 'mandy' : 42 , 'micah' : 23 , 'gus' : 7 , 'hank' : 1_000_000 , 'maggie' : 0 , } num = favorite_numbers [ 'mandy' ] print ( f \"Mandy's favorite number is { num } .\" ) num = favorite_numbers [ 'micah' ] print ( f \"Micah's favorite number is { num } .\" ) num = favorite_numbers [ 'gus' ] print ( f \"Gus's favorite number is { num } .\" ) num = favorite_numbers [ 'hank' ] print ( f \"Hank's favorite number is { num } .\" ) num = favorite_numbers [ 'maggie' ] print ( f \"Maggie's favorite number is { num } .\" ) Output: Mandy's favorite number is 42. Micah's favorite number is 23. Gus's favorite number is 7. Hank's favorite number is 1000000. Maggie's favorite number is 0.","title":"6-2: Favorite Numbers"},{"location":"solutions/chapter_6/#6-3-glossary","text":"A Python dictionary can be used to model an actual dictionary. However, to avoid confusion, let's call it a glossary. Think of five programming words you've learned about in the previous chapters. Use these words as the keys in your glossary, and store their meanings as values. Print each word and its meaning as neatly formatted output. You might print the word followed by a colon and then its meaning, or print the word on one line and then print its meaning indented on a second line. Use the newline character ( '\\n' ) to insert a blank line between each word-meaning pair in your output. glossary.py glossary = { 'string' : 'A series of characters.' , 'comment' : 'A note in a program that the Python interpreter ignores.' , 'list' : 'A collection of items in a particular order.' , 'loop' : 'Work through a collection of items, one at a time.' , 'dictionary' : \"A collection of key-value pairs.\" , } word = 'string' print ( f \" \\n { word . title () } : { glossary [ word ] } \" ) word = 'comment' print ( f \" \\n { word . title () } : { glossary [ word ] } \" ) word = 'list' print ( f \" \\n { word . title () } : { glossary [ word ] } \" ) word = 'loop' print ( f \" \\n { word . title () } : { glossary [ word ] } \" ) word = 'dictionary' print ( f \" \\n { word . title () } : { glossary [ word ] } \" ) Output: String: A series of characters. Comment: A note in a program that the Python interpreter ignores. List: A collection of items in a particular order. Loop: Work through a collection of items, one at a time. Dictionary: A collection of key-value pairs.","title":"6-3: Glossary"},{"location":"solutions/chapter_6/#6-4-glossary-2","text":"Now that you know how to loop through a dictionary, clean up the code from Exercise 6-3 (page 99) by replacing your series of print() calls with a loop that runs through the dictionary's keys and values. When you're sure that your loop works, add five more Python terms to your glossary. When you run your program again, these new words and meanings should automatically be included in the output. glossary_2.py glossary = { 'string' : 'A series of characters.' , 'comment' : 'A note in a program that the Python interpreter ignores.' , 'list' : 'A collection of items in a particular order.' , 'loop' : 'Work through a collection of items, one at a time.' , 'dictionary' : \"A collection of key-value pairs.\" , 'key' : 'The first item in a key-value pair in a dictionary.' , 'value' : 'An item associated with a key in a dictionary.' , 'conditional test' : 'A comparison between two values.' , 'float' : 'A numerical value with a decimal component.' , 'boolean expression' : 'An expression that evaluates to True or False.' , } for word , definition in glossary . items (): print ( f \" \\n { word . title () } : { definition } \" ) Output: String: A series of characters. Comment: A note in a program that the Python interpreter ignores. List: A collection of items in a particular order. Loop: Work through a collection of items, one at a time. Dictionary: A collection of key-value pairs. Key: The first item in a key-value pair in a dictionary. Value: An item associated with a key in a dictionary. Conditional Test: A comparison between two values. Float: A numerical value with a decimal component. Boolean Expression: An expression that evaluates to True or False.","title":"6-4: Glossary 2"},{"location":"solutions/chapter_6/#6-5-rivers","text":"Make a dictionary containing three major rivers and the country each river runs through. One key-value pair might be 'nile': 'egypt' . Use a loop to print a sentence about each river, such as The Nile runs through Egypt. Use a loop to print the name of each river included in the dictionary. Use a loop to print the name of each country included in the dictionary. rivers.py rivers = { 'nile' : 'egypt' , 'mississippi' : 'united states' , 'fraser' : 'canada' , 'kuskokwim' : 'alaska' , 'yangtze' : 'china' , } for river , country in rivers . items (): print ( f \"The { river . title () } flows through { country . title () } .\" ) print ( \" \\n The following rivers are included in this data set:\" ) for river in rivers . keys (): print ( f \"- { river . title () } \" ) print ( \" \\n The following countries are included in this data set:\" ) for country in rivers . values (): print ( f \"- { country . title () } \" ) Output*: The Nile flows through Egypt. The Mississippi flows through United States. The Fraser flows through Canada. The Kuskokwim flows through Alaska. The Yangtze flows through China. The following rivers are included in this data set: - Nile - Mississippi - Fraser - Kuskokwim - Yangtze The following countries are included in this data set: - Egypt - United States - Canada - Alaska - China * Sometimes we like to think of Alaska as our own separate country.","title":"6-5: Rivers"},{"location":"solutions/chapter_6/#6-6-polling","text":"Use the code in favorite_languages.py (page 96). Make a list of people who should take the favorite languages poll. Include some names that are already in the dictionary and some that are not. Loop through the list of people who should take the poll. If they have already taken the poll, print a message thanking them for responding. If they have not yet taken the poll, print a message inviting them to take the poll. polling.py favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name , language in favorite_languages . items (): print ( f \" { name . title () } 's favorite language is { language . title () } .\" ) print ( \" \\n \" ) coders = [ 'phil' , 'josh' , 'david' , 'becca' , 'sarah' , 'matt' , 'danielle' ] for coder in coders : if coder in favorite_languages . keys (): print ( f \"Thank you for taking the poll, { coder . title () } !\" ) else : print ( f \" { coder . title () } , what's your favorite programming language?\" ) Output: Jen's favorite language is Python. Sarah's favorite language is C. Edward's favorite language is Ruby. Phil's favorite language is Python. Thank you for taking the poll, Phil! Josh, what's your favorite programming language? David, what's your favorite programming language? Becca, what's your favorite programming language? Thank you for taking the poll, Sarah! Matt, what's your favorite programming language? Danielle, what's your favorite programming language?","title":"6-6: Polling"},{"location":"solutions/chapter_6/#6-7-people","text":"Start with the program you wrote for Exercise 6-1 (page 98). Make two new dictionaries representing different people, and store all three dictionaries in a list called people . Loop through your list of people. As you loop through the list, print everything you know about each person. people.py # Make an empty list to store people in. people = [] # Define some people, and add them to the list. person = { 'first_name' : 'eric' , 'last_name' : 'matthes' , 'age' : 46 , 'city' : 'sitka' , } people . append ( person ) person = { 'first_name' : 'lemmy' , 'last_name' : 'matthes' , 'age' : 2 , 'city' : 'sitka' , } people . append ( person ) person = { 'first_name' : 'willie' , 'last_name' : 'matthes' , 'age' : 11 , 'city' : 'sitka' , } people . append ( person ) # Display all of the information in the dictionary. for person in people : name = f \" { person [ 'first_name' ] . title () } { person [ 'last_name' ] . title () } \" age = person [ 'age' ] city = person [ 'city' ] . title () print ( f \" { name } , of { city } , is { age } years old.\" ) Output: Eric Matthes, of Sitka, is 46 years old. Lemmy Matthes, of Sitka, is 2 years old. Willie Matthes, of Sitka, is 11 years old.","title":"6-7: People"},{"location":"solutions/chapter_6/#6-8-pets","text":"Make several dictionaries, where each dictionary represents a different pet. In each dictionary, include the kind of animal and the owner\u2019s name. Store these dictionaries in a list called pets . Next, loop through your list and as you do, print everything you know about each pet. pets.py # Make an empty list to store the pets in. pets = [] # Make individual pets, and store each one in the list. pet = { 'animal type' : 'python' , 'name' : 'john' , 'owner' : 'guido' , 'weight' : 43 , 'eats' : 'bugs' , } pets . append ( pet ) pet = { 'animal type' : 'chicken' , 'name' : 'clarence' , 'owner' : 'tiffany' , 'weight' : 2 , 'eats' : 'seeds' , } pets . append ( pet ) pet = { 'animal type' : 'dog' , 'name' : 'peso' , 'owner' : 'eric' , 'weight' : 37 , 'eats' : 'shoes' , } pets . append ( pet ) # Display information about each pet. for pet in pets : print ( f \" \\n Here's what I know about { pet [ 'name' ] . title () } :\" ) for key , value in pet . items (): print ( f \" \\t { key } : { value } \" ) Output: Here's what I know about John: animal type: python name: john owner: guido weight: 43 eats: bugs Here's what I know about Clarence: animal type: chicken name: clarence owner: tiffany weight: 2 eats: seeds Here's what I know about Peso: animal type: dog name: peso owner: eric weight: 37 eats: shoes","title":"6-8: Pets"},{"location":"solutions/chapter_6/#6-9-favorite-places","text":"Make a dictionary called favorite_places . Think of three names to use as keys in the dictionary, and store one to three favorite places for each person. To make this exericse a bit more interesting, ask some friends to name a few of their favorite places. Loop through the dictionary, and print each person's name and their favorite places. favorite_places.py favorite_places = { 'eric' : [ 'bear mountain' , 'death valley' , 'tierra del fuego' ], 'erin' : [ 'hawaii' , 'iceland' ], 'willie' : [ 'mt. verstovia' , 'the playground' , 'new hampshire' ] } for name , places in favorite_places . items (): print ( f \" \\n { name . title () } likes the following places:\" ) for place in places : print ( f \"- { place . title () } \" ) Output: Eric likes the following places: - Bear Mountain - Death Valley - Tierra Del Fuego Erin likes the following places: - Hawaii - Iceland Willie likes the following places: - Mt. Verstovia - The Playground - New Hampshire","title":"6-9: Favorite Places"},{"location":"solutions/chapter_6/#6-10-favorite-numbers","text":"Modify your program from Exercise 6-2 (page 98) so each person can have more than one favorite number. Then print each person's name along with their favorite numbers. favorite_numbers_6_10.py favorite_numbers = { 'mandy' : [ 42 , 17 ], 'micah' : [ 42 , 39 , 56 ], 'gus' : [ 7 , 12 ], } for name , numbers in favorite_numbers . items (): print ( f \" \\n { name . title () } likes the following numbers:\" ) for number in numbers : print ( f \" { number } \" ) Output: Mandy likes the following numbers: 42 17 Micah likes the following numbers: 42 39 56 Gus likes the following numbers: 7 12","title":"6-10: Favorite Numbers"},{"location":"solutions/chapter_6/#6-11-cities","text":"Make a dictionary called cities . Use the names of three cities as keys in your dictionary. Create a dictionary of information about each city and include the country that the city is in, its approximate population, and one fact about that city. The keys for each city's dictionary should be something like country , population , and fact . Print the name of each city and all of the information you have stored about it. cities.py cities = { 'santiago' : { 'country' : 'chile' , 'population' : 6_310_000 , 'nearby mountains' : 'andes' , }, 'talkeetna' : { 'country' : 'united states' , 'population' : 876 , 'nearby mountains' : 'alaska range' , }, 'kathmandu' : { 'country' : 'nepal' , 'population' : 975_453 , 'nearby mountains' : 'himilaya' , } } for city , city_info in cities . items (): country = city_info [ 'country' ] . title () population = city_info [ 'population' ] mountains = city_info [ 'nearby mountains' ] . title () print ( f \" \\n { city . title () } is in { country } .\" ) print ( f \" It has a population of about { population } .\" ) print ( f \" The { mountains } mounats are nearby.\" ) Output: Santiago is in Chile. It has a population of about 6310000. The Andes mounats are nearby. Talkeetna is in United States. It has a population of about 876. The Alaska Range mounats are nearby. Kathmandu is in Nepal. It has a population of about 975453. The Himilaya mounats are nearby.","title":"6-11: Cities"},{"location":"solutions/chapter_7/","text":"Solutions - Chapter 7 Note: VS Code isn't always set up to run programs that prompt the user for input. If you're having trouble entering user input with VS Code, see Running programs that use input() for help. 7-1: Rental Car Write a program that asks the user what kind of rental car they would like. Print a message about that car, such as \"Let me see if I can find you a Subaru\". rental_car.py car = input ( \"What kind of car would you like? \" ) print ( f \"Let me see if I can find you a { car . title () } .\" ) Output: What kind of car would you like? Toyota Tacoma Let me see if I can find you a Toyota Tacoma. 7-2: Restaurant Seating Write a program that asks the user how many people are in their dinner group. If the answer is more than eight, print a message saying they'll have to wait for a table. Otherwise, report that their table is ready. restaurant_seating.py party_size = input ( \"How many people are in your dinner party tonight? \" ) party_size = int ( party_size ) if party_size > 8 : print ( \"I'm sorry, you'll have to wait for a table.\" ) else : print ( \"Your table is ready.\" ) Output: How many people are in your dinner party tonight? 12 I'm sorry, you'll have to wait for a table. or: How many people are in your dinner party tonight? 6 Your table is ready. 7-3: Multiples of Ten Ask the user for a number, and then report whether the number is a multiple of 10 or not. multiples_of_ten.py number = input ( \"Give me a number, please: \" ) number = int ( number ) if number % 10 == 0 : print ( f \" { number } is a multiple of 10.\" ) else : print ( f \" { number } is not a multiple of 10.\" ) Output: Give me a number, please: 23 23 is not a multiple of 10. or: Give me a number, please: 90 90 is a multiple of 10. 7-4: Pizza Toppings Write a loop that prompts the user to enter a series of pizza toppings until they enter a quit value. As they enter each topping, print a message saying you'll add that topping to their pizza. pizza_toppings.py prompt = \" \\n What topping would you like on your pizza?\" prompt += \" \\n Enter 'quit' when you are finished: \" while True : topping = input ( prompt ) if topping != 'quit' : print ( f \" I'll add { topping } to your pizza.\" ) else : break Output: What topping would you like on your pizza? Enter 'quit' when you are finished: pepperoni I'll add pepperoni to your pizza. What topping would you like on your pizza? Enter 'quit' when you are finished: sausage I'll add sausage to your pizza. What topping would you like on your pizza? Enter 'quit' when you are finished: bacon I'll add bacon to your pizza. What topping would you like on your pizza? Enter 'quit' when you are finished: quit 7-5: Movie Tickets A movie theater charges different ticket prices depending on a person's age. If a person is under the age of 3, the ticket is free; if they are between 3 and 12, the ticket is $10; and if they are over age 12, the ticket is $15. Write a loop in which you ask users their age, and then tell them the cost of their movie ticket. movie_tickets.py prompt = \" \\n How old are you?\" prompt += \" \\n Enter 'quit' when you are finished. \" while True : age = input ( prompt ) if age == 'quit' : break age = int ( age ) if age < 3 : print ( \" You get in free!\" ) elif age < 13 : print ( \" Your ticket is $10.\" ) else : print ( \" Your ticket is $15.\" ) Output: How old are you? Enter 'quit' when you are finished. 2 You get in free! How old are you? Enter 'quit' when you are finished. 3 Your ticket is $10. How old are you? Enter 'quit' when you are finished. 12 Your ticket is $10. How old are you? Enter 'quit' when you are finished. 18 Your ticket is $15. How old are you? Enter 'quit' when you are finished. quit 7-8: Deli Make a list called sandwich_orders and fill it with the names of various sandwiches. Then make an empty list called finished_sandwiches . Loop through the list of sandwich orders and print a message for each order, such as I made your tuna sandwich. As each sandwich is made, move it to the list of finished sandwiches. After all the sandwiches have been made, print a message listing each sandwich that was made. deli.py sandwich_orders = [ 'veggie' , 'grilled cheese' , 'turkey' , 'roast beef' ] finished_sandwiches = [] while sandwich_orders : current_sandwich = sandwich_orders . pop () print ( f \"I'm working on your { current_sandwich } sandwich.\" ) finished_sandwiches . append ( current_sandwich ) print ( \" \\n \" ) for sandwich in finished_sandwiches : print ( f \"I made a { sandwich } sandwich.\" ) Output: I'm working on your roast beef sandwich. I'm working on your turkey sandwich. I'm working on your grilled cheese sandwich. I'm working on your veggie sandwich. I made a roast beef sandwich. I made a turkey sandwich. I made a grilled cheese sandwich. I made a veggie sandwich. 7-9: No Pastrami Using the list sandwich_orders from Exercise 7-8, make sure the sandwich 'pastrami' appears in the list at least three times. Add code near the beginning of your program to print a message saying the deli has run out of pastrami, and then use a while loop to remove all occurences of 'pastrami' from sandwich_orders . Make sure no pastrami sandwiches end up in finished_sandiches . no_pastrami.py sandwich_orders = [ 'pastrami' , 'veggie' , 'grilled cheese' , 'pastrami' , 'turkey' , 'roast beef' , 'pastrami' ] finished_sandwiches = [] print ( \"I'm sorry, we're all out of pastrami today.\" ) while 'pastrami' in sandwich_orders : sandwich_orders . remove ( 'pastrami' ) print ( \" \\n \" ) while sandwich_orders : current_sandwich = sandwich_orders . pop () print ( f \"I'm working on your { current_sandwich } sandwich.\" ) finished_sandwiches . append ( current_sandwich ) print ( \" \\n \" ) for sandwich in finished_sandwiches : print ( f \"I made a { sandwich } sandwich.\" ) Output: I'm sorry, we're all out of pastrami today. I'm working on your roast beef sandwich. I'm working on your turkey sandwich. I'm working on your grilled cheese sandwich. I'm working on your veggie sandwich. I made a roast beef sandwich. I made a turkey sandwich. I made a grilled cheese sandwich. I made a veggie sandwich. 7-10: Dream Vacation Write a program that polls users about their dream vacation. Write a prompt similar to If you could visit one place in the world, where would you go? Include a block of code that prints the results of the poll. dream_vacation.py name_prompt = \" \\n What's your name? \" place_prompt = \"If you could visit one place in the world, where would it be? \" continue_prompt = \" \\n Would you like to let someone else respond? (yes/no) \" # Responses will be stored in the form {name: place}. responses = {} while True : # Ask the user where they'd like to go. name = input ( name_prompt ) place = input ( place_prompt ) # Store the response. responses [ name ] = place # Ask if there's anyone else responding. repeat = input ( continue_prompt ) if repeat != 'yes' : break # Show results of the survey. print ( \" \\n --- Results ---\" ) for name , place in responses . items (): print ( f \" { name . title () } would like to visit { place . title () } .\" ) Output: What's your name? eric If you could visit one place in the world, where would it be? china Would you like to let someone else respond? (yes/no) yes What's your name? erin If you could visit one place in the world, where would it be? iceland Would you like to let someone else respond? (yes/no) yes What's your name? ever If you could visit one place in the world, where would it be? japan Would you like to let someone else respond? (yes/no) --- Results --- Eric would like to visit China. Erin would like to visit Iceland. Ever would like to visit Japan.","title":"Chapter 7"},{"location":"solutions/chapter_7/#solutions-chapter-7","text":"Note: VS Code isn't always set up to run programs that prompt the user for input. If you're having trouble entering user input with VS Code, see Running programs that use input() for help.","title":"Solutions - Chapter 7"},{"location":"solutions/chapter_7/#7-1-rental-car","text":"Write a program that asks the user what kind of rental car they would like. Print a message about that car, such as \"Let me see if I can find you a Subaru\". rental_car.py car = input ( \"What kind of car would you like? \" ) print ( f \"Let me see if I can find you a { car . title () } .\" ) Output: What kind of car would you like? Toyota Tacoma Let me see if I can find you a Toyota Tacoma.","title":"7-1: Rental Car"},{"location":"solutions/chapter_7/#7-2-restaurant-seating","text":"Write a program that asks the user how many people are in their dinner group. If the answer is more than eight, print a message saying they'll have to wait for a table. Otherwise, report that their table is ready. restaurant_seating.py party_size = input ( \"How many people are in your dinner party tonight? \" ) party_size = int ( party_size ) if party_size > 8 : print ( \"I'm sorry, you'll have to wait for a table.\" ) else : print ( \"Your table is ready.\" ) Output: How many people are in your dinner party tonight? 12 I'm sorry, you'll have to wait for a table. or: How many people are in your dinner party tonight? 6 Your table is ready.","title":"7-2: Restaurant Seating"},{"location":"solutions/chapter_7/#7-3-multiples-of-ten","text":"Ask the user for a number, and then report whether the number is a multiple of 10 or not. multiples_of_ten.py number = input ( \"Give me a number, please: \" ) number = int ( number ) if number % 10 == 0 : print ( f \" { number } is a multiple of 10.\" ) else : print ( f \" { number } is not a multiple of 10.\" ) Output: Give me a number, please: 23 23 is not a multiple of 10. or: Give me a number, please: 90 90 is a multiple of 10.","title":"7-3: Multiples of Ten"},{"location":"solutions/chapter_7/#7-4-pizza-toppings","text":"Write a loop that prompts the user to enter a series of pizza toppings until they enter a quit value. As they enter each topping, print a message saying you'll add that topping to their pizza. pizza_toppings.py prompt = \" \\n What topping would you like on your pizza?\" prompt += \" \\n Enter 'quit' when you are finished: \" while True : topping = input ( prompt ) if topping != 'quit' : print ( f \" I'll add { topping } to your pizza.\" ) else : break Output: What topping would you like on your pizza? Enter 'quit' when you are finished: pepperoni I'll add pepperoni to your pizza. What topping would you like on your pizza? Enter 'quit' when you are finished: sausage I'll add sausage to your pizza. What topping would you like on your pizza? Enter 'quit' when you are finished: bacon I'll add bacon to your pizza. What topping would you like on your pizza? Enter 'quit' when you are finished: quit","title":"7-4: Pizza Toppings"},{"location":"solutions/chapter_7/#7-5-movie-tickets","text":"A movie theater charges different ticket prices depending on a person's age. If a person is under the age of 3, the ticket is free; if they are between 3 and 12, the ticket is $10; and if they are over age 12, the ticket is $15. Write a loop in which you ask users their age, and then tell them the cost of their movie ticket. movie_tickets.py prompt = \" \\n How old are you?\" prompt += \" \\n Enter 'quit' when you are finished. \" while True : age = input ( prompt ) if age == 'quit' : break age = int ( age ) if age < 3 : print ( \" You get in free!\" ) elif age < 13 : print ( \" Your ticket is $10.\" ) else : print ( \" Your ticket is $15.\" ) Output: How old are you? Enter 'quit' when you are finished. 2 You get in free! How old are you? Enter 'quit' when you are finished. 3 Your ticket is $10. How old are you? Enter 'quit' when you are finished. 12 Your ticket is $10. How old are you? Enter 'quit' when you are finished. 18 Your ticket is $15. How old are you? Enter 'quit' when you are finished. quit","title":"7-5: Movie Tickets"},{"location":"solutions/chapter_7/#7-8-deli","text":"Make a list called sandwich_orders and fill it with the names of various sandwiches. Then make an empty list called finished_sandwiches . Loop through the list of sandwich orders and print a message for each order, such as I made your tuna sandwich. As each sandwich is made, move it to the list of finished sandwiches. After all the sandwiches have been made, print a message listing each sandwich that was made. deli.py sandwich_orders = [ 'veggie' , 'grilled cheese' , 'turkey' , 'roast beef' ] finished_sandwiches = [] while sandwich_orders : current_sandwich = sandwich_orders . pop () print ( f \"I'm working on your { current_sandwich } sandwich.\" ) finished_sandwiches . append ( current_sandwich ) print ( \" \\n \" ) for sandwich in finished_sandwiches : print ( f \"I made a { sandwich } sandwich.\" ) Output: I'm working on your roast beef sandwich. I'm working on your turkey sandwich. I'm working on your grilled cheese sandwich. I'm working on your veggie sandwich. I made a roast beef sandwich. I made a turkey sandwich. I made a grilled cheese sandwich. I made a veggie sandwich.","title":"7-8: Deli"},{"location":"solutions/chapter_7/#7-9-no-pastrami","text":"Using the list sandwich_orders from Exercise 7-8, make sure the sandwich 'pastrami' appears in the list at least three times. Add code near the beginning of your program to print a message saying the deli has run out of pastrami, and then use a while loop to remove all occurences of 'pastrami' from sandwich_orders . Make sure no pastrami sandwiches end up in finished_sandiches . no_pastrami.py sandwich_orders = [ 'pastrami' , 'veggie' , 'grilled cheese' , 'pastrami' , 'turkey' , 'roast beef' , 'pastrami' ] finished_sandwiches = [] print ( \"I'm sorry, we're all out of pastrami today.\" ) while 'pastrami' in sandwich_orders : sandwich_orders . remove ( 'pastrami' ) print ( \" \\n \" ) while sandwich_orders : current_sandwich = sandwich_orders . pop () print ( f \"I'm working on your { current_sandwich } sandwich.\" ) finished_sandwiches . append ( current_sandwich ) print ( \" \\n \" ) for sandwich in finished_sandwiches : print ( f \"I made a { sandwich } sandwich.\" ) Output: I'm sorry, we're all out of pastrami today. I'm working on your roast beef sandwich. I'm working on your turkey sandwich. I'm working on your grilled cheese sandwich. I'm working on your veggie sandwich. I made a roast beef sandwich. I made a turkey sandwich. I made a grilled cheese sandwich. I made a veggie sandwich.","title":"7-9: No Pastrami"},{"location":"solutions/chapter_7/#7-10-dream-vacation","text":"Write a program that polls users about their dream vacation. Write a prompt similar to If you could visit one place in the world, where would you go? Include a block of code that prints the results of the poll. dream_vacation.py name_prompt = \" \\n What's your name? \" place_prompt = \"If you could visit one place in the world, where would it be? \" continue_prompt = \" \\n Would you like to let someone else respond? (yes/no) \" # Responses will be stored in the form {name: place}. responses = {} while True : # Ask the user where they'd like to go. name = input ( name_prompt ) place = input ( place_prompt ) # Store the response. responses [ name ] = place # Ask if there's anyone else responding. repeat = input ( continue_prompt ) if repeat != 'yes' : break # Show results of the survey. print ( \" \\n --- Results ---\" ) for name , place in responses . items (): print ( f \" { name . title () } would like to visit { place . title () } .\" ) Output: What's your name? eric If you could visit one place in the world, where would it be? china Would you like to let someone else respond? (yes/no) yes What's your name? erin If you could visit one place in the world, where would it be? iceland Would you like to let someone else respond? (yes/no) yes What's your name? ever If you could visit one place in the world, where would it be? japan Would you like to let someone else respond? (yes/no) --- Results --- Eric would like to visit China. Erin would like to visit Iceland. Ever would like to visit Japan.","title":"7-10: Dream Vacation"},{"location":"solutions/chapter_8/","text":"Solutions - Chapter 8 8-1: Message Write a function called display_message() that prints one sentence telling everyone what you are learning about in this chapter. Call the function, and make sure the message displays correctly. message.py def display_message (): \"\"\"Display a message about what I'm learning.\"\"\" msg = \"I'm learning to store code in functions.\" print ( msg ) display_message () Output: I'm learning to store code in functions. 8-2: Favorite Book Write a function called favorite_book() that accepts one parameter, title . The function should print a message, such as One of my favorite books is Alice in Wonderland. Call the function, making sure to include a book title as an argument in the function call. favorite_book.py def favorite_book ( title ): \"\"\"Display a message about someone's favorite book.\"\"\" print ( f \" { title } is one of my favorite books.\" ) favorite_book ( 'The Abstract Wild' ) Output: The Abstract Wild is one of my favorite books. 8-3: T-Shirt Write a function called make_shirt() that accepts a size and the text of a message that should be printed on the shirt. The function should print a sentence summarizing the size of the shirt and the message printed on it. Call the function once using positional arguments to make a shirt. Call the function a second time using keyword arguments. t_shirt.py def make_shirt ( size , message ): \"\"\"Summarize the shirt that's going to be made.\"\"\" print ( f \" \\n I'm going to make a { size } t-shirt.\" ) print ( f 'It will say, \" { message } \"' ) make_shirt ( 'large' , 'I love Python!' ) make_shirt ( message = \"Readability counts.\" , size = 'medium' ) Output: I'm going to make a large t-shirt. It will say, \"I love Python!\" I'm going to make a medium t-shirt. It will say, \"Readability counts.\" 8-4: Large Shirts Modify the make_shirt() function so that shirts are large by default with a message that reads I love Python . Make a large shirt and a medium shirt with the default message, and a shirt of any size with a different message. large_shirts.py def make_shirt ( size = 'large' , message = 'I love Python!' ): \"\"\"Summarize the shirt that's going to be made.\"\"\" print ( f \" \\n I'm going to make a { size } t-shirt.\" ) print ( f 'It will say, \" { message } \"' ) make_shirt () make_shirt ( size = 'medium' ) make_shirt ( 'small' , 'Programmers are loopy.' ) Output: I'm going to make a large t-shirt. It will say, \"I love Python!\" I'm going to make a medium t-shirt. It will say, \"I love Python!\" I'm going to make a small t-shirt. It will say, \"Programmers are loopy.\" 8-5: Cities Write a function called describe_city() that accepts the name of a city and its country. The function should print a simple sentence, such as Reykjavik is in Iceland. Give the parameter for the country a default value. Call your function for three different cities, at least one of which is not in the default country. cities.py def describe_city ( city , country = 'chile' ): \"\"\"Describe a city.\"\"\" msg = f \" { city . title () } is in { country . title () } .\" print ( msg ) describe_city ( 'santiago' ) describe_city ( 'reykjavik' , 'iceland' ) describe_city ( 'punta arenas' ) Output: Santiago is in Chile. Reykjavik is in Iceland. Punta Arenas is in Chile. 8-6: City Names Write a function called city_country() that takes in the name of a city and its country. The function should return a string formatted like this: \"Santiago, Chile\" Call your function with at least three city-country pairs, and print the values that are returned. city_names.py def city_country ( city , country ): \"\"\"Return a string like 'Santiago, Chile'.\"\"\" return f \" { city . title () } , { country . title () } \" city = city_country ( 'santiago' , 'chile' ) print ( city ) city = city_country ( 'ushuaia' , 'argentina' ) print ( city ) city = city_country ( 'longyearbyen' , 'svalbard' ) print ( city ) Output: Santiago, Chile Ushuaia, Argentina Longyearbyen, Svalbard 8-7: Album Write a function called make_album() that builds a dictionary describing a music album. The function should take in an artist name and an album title, and it should return a dictionary containing these two pieces of information. Use the function to make three dictionaries representing different albums. Print each return value to show that the dictionaries are storing the album information correctly. Use None to add an optional parameter to make_album() that allows you to store the number of songs on an album. If the calling line includes a value for the number of songs, add that value to the album\u2019s dictionary. Make at least one new function call that includes the number of songs on an album. Simple version: album.py def make_album ( artist , title ): \"\"\"Build a dictionary containing information about an album.\"\"\" album_dict = { 'artist' : artist . title (), 'title' : title . title (), } return album_dict album = make_album ( 'metallica' , 'ride the lightning' ) print ( album ) album = make_album ( 'beethoven' , 'ninth symphony' ) print ( album ) album = make_album ( 'willie nelson' , 'red-headed stranger' ) print ( album ) Output: {'artist': 'Metallica', 'title': 'Ride The Lightning'} {'artist': 'Beethoven', 'title': 'Ninth Symphony'} {'artist': 'Willie Nelson', 'title': 'Red-Headed Stranger'} With number of songs: album_num_songs.py def make_album ( artist , title , num_songs = 0 ): \"\"\"Build a dictionary containing information about an album.\"\"\" album_dict = { 'artist' : artist . title (), 'title' : title . title (), } if num_songs : album_dict [ 'num_songs' ] = num_songs return album_dict album = make_album ( 'metallica' , 'ride the lightning' ) print ( album ) album = make_album ( 'beethoven' , 'ninth symphony' ) print ( album ) album = make_album ( 'willie nelson' , 'red-headed stranger' ) print ( album ) album = make_album ( 'iron maiden' , 'piece of mind' , num_songs = 8 ) print ( album ) Output: {'artist': 'Metallica', 'title': 'Ride The Lightning'} {'artist': 'Beethoven', 'title': 'Ninth Symphony'} {'artist': 'Willie Nelson', 'title': 'Red-Headed Stranger'} {'artist': 'Iron Maiden', 'title': 'Piece Of Mind', 'num_songs': 8} 8-8: User Albums Start with your program from Exercise 8-7. Write a while loop that allows users to enter an album's artist and title. Once you have that information, call make_album() with the user's input and print the dictionary that's created. Be sure to include a quit value in the while loop. user_albums.py def make_album ( artist , title , tracks = 0 ): \"\"\"Build a dictionary containing information about an album.\"\"\" album_dict = { 'artist' : artist . title (), 'title' : title . title (), } if tracks : album_dict [ 'tracks' ] = tracks return album_dict # Prepare the prompts. title_prompt = \" \\n What album are you thinking of? \" artist_prompt = \"Who's the artist? \" # Let the user know how to quit. print ( \"Enter 'quit' at any time to stop.\" ) while True : title = input ( title_prompt ) if title == 'quit' : break artist = input ( artist_prompt ) if artist == 'quit' : break album = make_album ( artist , title ) print ( album ) print ( \" \\n Thanks for responding!\" ) Output: Enter 'quit' at any time to stop. What album are you thinking of? number of the beast Who's the artist? iron maiden {'artist': 'Iron Maiden', 'title': 'Number Of The Beast'} What album are you thinking of? touch of class Who's the artist? angel romero {'artist': 'Angel Romero', 'title': 'Touch Of Class'} What album are you thinking of? rust in peace Who's the artist? megadeth {'artist': 'Megadeth', 'title': 'Rust In Peace'} What album are you thinking of? quit Thanks for responding! 8-9: Messages Make a list containing a series of short text messages. Pass the list to a function called show_messages() , which prints each text message. messages.py def show_messages ( messages ): \"\"\"Print all messages in the list.\"\"\" for message in messages : print ( message ) messages = [ \"hello there\" , \"how are u?\" , \":)\" ] show_messages ( messages ) Output: hello there how are u? :) 8-10: Sending Messages Start with a copy of your program from Exercise 8-9. Write a function called send_messages() that prints each text message and moves each message to a new list called sent_messages as it\u2019s printed. After calling the function, print both of your lists to make sure the messages were moved correctly. sending_messages.py def show_messages ( messages ): \"\"\"Print all messages in the list.\"\"\" print ( \"Showing all messages:\" ) for message in messages : print ( message ) def send_messages ( messages , sent_messages ): \"\"\"Print each message, and then move it to sent_messages.\"\"\" print ( \" \\n Sending all messages:\" ) while messages : current_message = messages . pop () print ( current_message ) sent_messages . append ( current_message ) messages = [ \"hello there\" , \"how are u?\" , \":)\" ] show_messages ( messages ) sent_messages = [] send_messages ( messages , sent_messages ) print ( \" \\n Final lists:\" ) print ( messages ) print ( sent_messages ) Output: Showing all messages: hello there how are u? :) Sending all messages: :) how are u? hello there Final lists: [] [':)', 'how are u?', 'hello there'] 8-11: Archived Messages Start with your work from Exercise 8-10. Call the function send_messages() with a copy of the list of messages. After calling the function, print both of your lists to show that the original list has retained its messages. archived_messages.py def show_messages ( messages ): \"\"\"Print all messages in the list.\"\"\" print ( \"Showing all messages:\" ) for message in messages : print ( message ) def send_messages ( messages , sent_messages ): \"\"\"Print each message, and then move it to sent_messages.\"\"\" print ( \" \\n Sending all messages:\" ) while messages : current_message = messages . pop () print ( current_message ) sent_messages . append ( current_message ) messages = [ \"hello there\" , \"how are u?\" , \":)\" ] show_messages ( messages ) sent_messages = [] send_messages ( messages [:], sent_messages ) print ( \" \\n Final lists:\" ) print ( messages ) print ( sent_messages ) Output: Showing all messages: hello there how are u? :) Sending all messages: :) how are u? hello there Final lists: ['hello there', 'how are u?', ':)'] [':)', 'how are u?', 'hello there'] 8-12: Sandwiches Write a function that accepts a list of items a person wants on a sandwich. The function should have one parameter that collects as many items as the function call provides, and it should print a summary of the sandiwch that is being ordered. Call the function three tiems, using a different number of arguments each time. sandwiches.py def make_sandwich ( * items ): \"\"\"Make a sandwich with the given items.\"\"\" print ( \" \\n I'll make you a great sandwich:\" ) for item in items : print ( f \" ...adding { item } to your sandwich.\" ) print ( \"Your sandwich is ready!\" ) make_sandwich ( 'roast beef' , 'cheddar cheese' , 'lettuce' , 'honey dijon' ) make_sandwich ( 'turkey' , 'apple slices' , 'honey mustard' ) make_sandwich ( 'peanut butter' , 'strawberry jam' ) Output: I'll make you a great sandwich: ...adding roast beef to your sandwich. ...adding cheddar cheese to your sandwich. ...adding lettuce to your sandwich. ...adding honey dijon to your sandwich. Your sandwich is ready! I'll make you a great sandwich: ...adding turkey to your sandwich. ...adding apple slices to your sandwich. ...adding honey mustard to your sandwich. Your sandwich is ready! I'll make you a great sandwich: ...adding peanut butter to your sandwich. ...adding strawberry jam to your sandwich. Your sandwich is ready! 8-14: Cars Write a function that stores information about a car in a dictionary. the function should always receive a manufacturer and a model name. It should then accept an arbitrary number of keyword arguments. Call the function with the required information and two other name-value pairs, such as a color or an optional feature. Your function should work for a call like this one: car = make_car ( 'subaru' , 'outback' , color = 'blue' , tow_package = True ) Print the dictionary that's returned to make sure all the information was stored correctly. cars.py def make_car ( manufacturer , model , ** options ): \"\"\"Make a dictionary representing a car.\"\"\" car_dict = { 'manufacturer' : manufacturer . title (), 'model' : model . title (), } for option , value in options . items (): car_dict [ option ] = value return car_dict my_outback = make_car ( 'subaru' , 'outback' , color = 'blue' , tow_package = True ) print ( my_outback ) my_old_accord = make_car ( 'honda' , 'accord' , year = 1991 , color = 'white' , headlights = 'popup' ) print ( my_old_accord ) Output: {'manufacturer': 'Subaru', 'model': 'Outback', 'color': 'blue', 'tow_package': True} {'manufacturer': 'Honda', 'model': 'Accord', 'year': 1991, 'color': 'white', 'headlights': 'popup'} 8-15: Printing Models Put the functions for the example printing_models.py in a separate file called printing_functions.py . Write an import statement at the top of printing_models.py , and modify the file to use the imported functions. printing_functions.py: printing_functions.py \"\"\"Functions related to printing 3d models.\"\"\" def print_models ( unprinted_designs , completed_models ): \"\"\" Simulate printing each design, until there are none left. Move each design to completed_models after printing. \"\"\" while unprinted_designs : current_design = unprinted_designs . pop () # Simulate creating a 3d print from the design. print ( f \"Printing model: { current_design } \" ) completed_models . append ( current_design ) def show_completed_models ( completed_models ): \"\"\"Show all the models that were printed.\"\"\" print ( \" \\n The following models have been printed:\" ) for completed_model in completed_models : print ( completed_model ) printing_models.py: printing_models.py import printing_functions as pf unprinted_designs = [ 'iphone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] pf . print_models ( unprinted_designs , completed_models ) pf . show_completed_models ( completed_models ) Output: Printing model: dodecahedron Printing model: robot pendant Printing model: iphone case The following models have been printed: dodecahedron robot pendant iphone case","title":"Chapter 8"},{"location":"solutions/chapter_8/#solutions-chapter-8","text":"","title":"Solutions - Chapter 8"},{"location":"solutions/chapter_8/#8-1-message","text":"Write a function called display_message() that prints one sentence telling everyone what you are learning about in this chapter. Call the function, and make sure the message displays correctly. message.py def display_message (): \"\"\"Display a message about what I'm learning.\"\"\" msg = \"I'm learning to store code in functions.\" print ( msg ) display_message () Output: I'm learning to store code in functions.","title":"8-1: Message"},{"location":"solutions/chapter_8/#8-2-favorite-book","text":"Write a function called favorite_book() that accepts one parameter, title . The function should print a message, such as One of my favorite books is Alice in Wonderland. Call the function, making sure to include a book title as an argument in the function call. favorite_book.py def favorite_book ( title ): \"\"\"Display a message about someone's favorite book.\"\"\" print ( f \" { title } is one of my favorite books.\" ) favorite_book ( 'The Abstract Wild' ) Output: The Abstract Wild is one of my favorite books.","title":"8-2: Favorite Book"},{"location":"solutions/chapter_8/#8-3-t-shirt","text":"Write a function called make_shirt() that accepts a size and the text of a message that should be printed on the shirt. The function should print a sentence summarizing the size of the shirt and the message printed on it. Call the function once using positional arguments to make a shirt. Call the function a second time using keyword arguments. t_shirt.py def make_shirt ( size , message ): \"\"\"Summarize the shirt that's going to be made.\"\"\" print ( f \" \\n I'm going to make a { size } t-shirt.\" ) print ( f 'It will say, \" { message } \"' ) make_shirt ( 'large' , 'I love Python!' ) make_shirt ( message = \"Readability counts.\" , size = 'medium' ) Output: I'm going to make a large t-shirt. It will say, \"I love Python!\" I'm going to make a medium t-shirt. It will say, \"Readability counts.\"","title":"8-3: T-Shirt"},{"location":"solutions/chapter_8/#8-4-large-shirts","text":"Modify the make_shirt() function so that shirts are large by default with a message that reads I love Python . Make a large shirt and a medium shirt with the default message, and a shirt of any size with a different message. large_shirts.py def make_shirt ( size = 'large' , message = 'I love Python!' ): \"\"\"Summarize the shirt that's going to be made.\"\"\" print ( f \" \\n I'm going to make a { size } t-shirt.\" ) print ( f 'It will say, \" { message } \"' ) make_shirt () make_shirt ( size = 'medium' ) make_shirt ( 'small' , 'Programmers are loopy.' ) Output: I'm going to make a large t-shirt. It will say, \"I love Python!\" I'm going to make a medium t-shirt. It will say, \"I love Python!\" I'm going to make a small t-shirt. It will say, \"Programmers are loopy.\"","title":"8-4: Large Shirts"},{"location":"solutions/chapter_8/#8-5-cities","text":"Write a function called describe_city() that accepts the name of a city and its country. The function should print a simple sentence, such as Reykjavik is in Iceland. Give the parameter for the country a default value. Call your function for three different cities, at least one of which is not in the default country. cities.py def describe_city ( city , country = 'chile' ): \"\"\"Describe a city.\"\"\" msg = f \" { city . title () } is in { country . title () } .\" print ( msg ) describe_city ( 'santiago' ) describe_city ( 'reykjavik' , 'iceland' ) describe_city ( 'punta arenas' ) Output: Santiago is in Chile. Reykjavik is in Iceland. Punta Arenas is in Chile.","title":"8-5: Cities"},{"location":"solutions/chapter_8/#8-6-city-names","text":"Write a function called city_country() that takes in the name of a city and its country. The function should return a string formatted like this: \"Santiago, Chile\" Call your function with at least three city-country pairs, and print the values that are returned. city_names.py def city_country ( city , country ): \"\"\"Return a string like 'Santiago, Chile'.\"\"\" return f \" { city . title () } , { country . title () } \" city = city_country ( 'santiago' , 'chile' ) print ( city ) city = city_country ( 'ushuaia' , 'argentina' ) print ( city ) city = city_country ( 'longyearbyen' , 'svalbard' ) print ( city ) Output: Santiago, Chile Ushuaia, Argentina Longyearbyen, Svalbard","title":"8-6: City Names"},{"location":"solutions/chapter_8/#8-7-album","text":"Write a function called make_album() that builds a dictionary describing a music album. The function should take in an artist name and an album title, and it should return a dictionary containing these two pieces of information. Use the function to make three dictionaries representing different albums. Print each return value to show that the dictionaries are storing the album information correctly. Use None to add an optional parameter to make_album() that allows you to store the number of songs on an album. If the calling line includes a value for the number of songs, add that value to the album\u2019s dictionary. Make at least one new function call that includes the number of songs on an album. Simple version: album.py def make_album ( artist , title ): \"\"\"Build a dictionary containing information about an album.\"\"\" album_dict = { 'artist' : artist . title (), 'title' : title . title (), } return album_dict album = make_album ( 'metallica' , 'ride the lightning' ) print ( album ) album = make_album ( 'beethoven' , 'ninth symphony' ) print ( album ) album = make_album ( 'willie nelson' , 'red-headed stranger' ) print ( album ) Output: {'artist': 'Metallica', 'title': 'Ride The Lightning'} {'artist': 'Beethoven', 'title': 'Ninth Symphony'} {'artist': 'Willie Nelson', 'title': 'Red-Headed Stranger'} With number of songs: album_num_songs.py def make_album ( artist , title , num_songs = 0 ): \"\"\"Build a dictionary containing information about an album.\"\"\" album_dict = { 'artist' : artist . title (), 'title' : title . title (), } if num_songs : album_dict [ 'num_songs' ] = num_songs return album_dict album = make_album ( 'metallica' , 'ride the lightning' ) print ( album ) album = make_album ( 'beethoven' , 'ninth symphony' ) print ( album ) album = make_album ( 'willie nelson' , 'red-headed stranger' ) print ( album ) album = make_album ( 'iron maiden' , 'piece of mind' , num_songs = 8 ) print ( album ) Output: {'artist': 'Metallica', 'title': 'Ride The Lightning'} {'artist': 'Beethoven', 'title': 'Ninth Symphony'} {'artist': 'Willie Nelson', 'title': 'Red-Headed Stranger'} {'artist': 'Iron Maiden', 'title': 'Piece Of Mind', 'num_songs': 8}","title":"8-7: Album"},{"location":"solutions/chapter_8/#8-8-user-albums","text":"Start with your program from Exercise 8-7. Write a while loop that allows users to enter an album's artist and title. Once you have that information, call make_album() with the user's input and print the dictionary that's created. Be sure to include a quit value in the while loop. user_albums.py def make_album ( artist , title , tracks = 0 ): \"\"\"Build a dictionary containing information about an album.\"\"\" album_dict = { 'artist' : artist . title (), 'title' : title . title (), } if tracks : album_dict [ 'tracks' ] = tracks return album_dict # Prepare the prompts. title_prompt = \" \\n What album are you thinking of? \" artist_prompt = \"Who's the artist? \" # Let the user know how to quit. print ( \"Enter 'quit' at any time to stop.\" ) while True : title = input ( title_prompt ) if title == 'quit' : break artist = input ( artist_prompt ) if artist == 'quit' : break album = make_album ( artist , title ) print ( album ) print ( \" \\n Thanks for responding!\" ) Output: Enter 'quit' at any time to stop. What album are you thinking of? number of the beast Who's the artist? iron maiden {'artist': 'Iron Maiden', 'title': 'Number Of The Beast'} What album are you thinking of? touch of class Who's the artist? angel romero {'artist': 'Angel Romero', 'title': 'Touch Of Class'} What album are you thinking of? rust in peace Who's the artist? megadeth {'artist': 'Megadeth', 'title': 'Rust In Peace'} What album are you thinking of? quit Thanks for responding!","title":"8-8: User Albums"},{"location":"solutions/chapter_8/#8-9-messages","text":"Make a list containing a series of short text messages. Pass the list to a function called show_messages() , which prints each text message. messages.py def show_messages ( messages ): \"\"\"Print all messages in the list.\"\"\" for message in messages : print ( message ) messages = [ \"hello there\" , \"how are u?\" , \":)\" ] show_messages ( messages ) Output: hello there how are u? :)","title":"8-9: Messages"},{"location":"solutions/chapter_8/#8-10-sending-messages","text":"Start with a copy of your program from Exercise 8-9. Write a function called send_messages() that prints each text message and moves each message to a new list called sent_messages as it\u2019s printed. After calling the function, print both of your lists to make sure the messages were moved correctly. sending_messages.py def show_messages ( messages ): \"\"\"Print all messages in the list.\"\"\" print ( \"Showing all messages:\" ) for message in messages : print ( message ) def send_messages ( messages , sent_messages ): \"\"\"Print each message, and then move it to sent_messages.\"\"\" print ( \" \\n Sending all messages:\" ) while messages : current_message = messages . pop () print ( current_message ) sent_messages . append ( current_message ) messages = [ \"hello there\" , \"how are u?\" , \":)\" ] show_messages ( messages ) sent_messages = [] send_messages ( messages , sent_messages ) print ( \" \\n Final lists:\" ) print ( messages ) print ( sent_messages ) Output: Showing all messages: hello there how are u? :) Sending all messages: :) how are u? hello there Final lists: [] [':)', 'how are u?', 'hello there']","title":"8-10: Sending Messages"},{"location":"solutions/chapter_8/#8-11-archived-messages","text":"Start with your work from Exercise 8-10. Call the function send_messages() with a copy of the list of messages. After calling the function, print both of your lists to show that the original list has retained its messages. archived_messages.py def show_messages ( messages ): \"\"\"Print all messages in the list.\"\"\" print ( \"Showing all messages:\" ) for message in messages : print ( message ) def send_messages ( messages , sent_messages ): \"\"\"Print each message, and then move it to sent_messages.\"\"\" print ( \" \\n Sending all messages:\" ) while messages : current_message = messages . pop () print ( current_message ) sent_messages . append ( current_message ) messages = [ \"hello there\" , \"how are u?\" , \":)\" ] show_messages ( messages ) sent_messages = [] send_messages ( messages [:], sent_messages ) print ( \" \\n Final lists:\" ) print ( messages ) print ( sent_messages ) Output: Showing all messages: hello there how are u? :) Sending all messages: :) how are u? hello there Final lists: ['hello there', 'how are u?', ':)'] [':)', 'how are u?', 'hello there']","title":"8-11: Archived Messages"},{"location":"solutions/chapter_8/#8-12-sandwiches","text":"Write a function that accepts a list of items a person wants on a sandwich. The function should have one parameter that collects as many items as the function call provides, and it should print a summary of the sandiwch that is being ordered. Call the function three tiems, using a different number of arguments each time. sandwiches.py def make_sandwich ( * items ): \"\"\"Make a sandwich with the given items.\"\"\" print ( \" \\n I'll make you a great sandwich:\" ) for item in items : print ( f \" ...adding { item } to your sandwich.\" ) print ( \"Your sandwich is ready!\" ) make_sandwich ( 'roast beef' , 'cheddar cheese' , 'lettuce' , 'honey dijon' ) make_sandwich ( 'turkey' , 'apple slices' , 'honey mustard' ) make_sandwich ( 'peanut butter' , 'strawberry jam' ) Output: I'll make you a great sandwich: ...adding roast beef to your sandwich. ...adding cheddar cheese to your sandwich. ...adding lettuce to your sandwich. ...adding honey dijon to your sandwich. Your sandwich is ready! I'll make you a great sandwich: ...adding turkey to your sandwich. ...adding apple slices to your sandwich. ...adding honey mustard to your sandwich. Your sandwich is ready! I'll make you a great sandwich: ...adding peanut butter to your sandwich. ...adding strawberry jam to your sandwich. Your sandwich is ready!","title":"8-12: Sandwiches"},{"location":"solutions/chapter_8/#8-14-cars","text":"Write a function that stores information about a car in a dictionary. the function should always receive a manufacturer and a model name. It should then accept an arbitrary number of keyword arguments. Call the function with the required information and two other name-value pairs, such as a color or an optional feature. Your function should work for a call like this one: car = make_car ( 'subaru' , 'outback' , color = 'blue' , tow_package = True ) Print the dictionary that's returned to make sure all the information was stored correctly. cars.py def make_car ( manufacturer , model , ** options ): \"\"\"Make a dictionary representing a car.\"\"\" car_dict = { 'manufacturer' : manufacturer . title (), 'model' : model . title (), } for option , value in options . items (): car_dict [ option ] = value return car_dict my_outback = make_car ( 'subaru' , 'outback' , color = 'blue' , tow_package = True ) print ( my_outback ) my_old_accord = make_car ( 'honda' , 'accord' , year = 1991 , color = 'white' , headlights = 'popup' ) print ( my_old_accord ) Output: {'manufacturer': 'Subaru', 'model': 'Outback', 'color': 'blue', 'tow_package': True} {'manufacturer': 'Honda', 'model': 'Accord', 'year': 1991, 'color': 'white', 'headlights': 'popup'}","title":"8-14: Cars"},{"location":"solutions/chapter_8/#8-15-printing-models","text":"Put the functions for the example printing_models.py in a separate file called printing_functions.py . Write an import statement at the top of printing_models.py , and modify the file to use the imported functions. printing_functions.py: printing_functions.py \"\"\"Functions related to printing 3d models.\"\"\" def print_models ( unprinted_designs , completed_models ): \"\"\" Simulate printing each design, until there are none left. Move each design to completed_models after printing. \"\"\" while unprinted_designs : current_design = unprinted_designs . pop () # Simulate creating a 3d print from the design. print ( f \"Printing model: { current_design } \" ) completed_models . append ( current_design ) def show_completed_models ( completed_models ): \"\"\"Show all the models that were printed.\"\"\" print ( \" \\n The following models have been printed:\" ) for completed_model in completed_models : print ( completed_model ) printing_models.py: printing_models.py import printing_functions as pf unprinted_designs = [ 'iphone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] pf . print_models ( unprinted_designs , completed_models ) pf . show_completed_models ( completed_models ) Output: Printing model: dodecahedron Printing model: robot pendant Printing model: iphone case The following models have been printed: dodecahedron robot pendant iphone case","title":"8-15: Printing Models"},{"location":"solutions/chapter_9/","text":"Solutions - Chapter 9 9-1: Restaurant Make a class called Restaurant . The __init__() method for Restaurant should store two attributes: a restaurant_name and a cuisine_type . Make a method called describe_restaurant() that prints these two pieces of information, and a method called open_restaurant() that prints a message indicating that the restaurant is open. Make an instance called restaurant from your class. Print the two attributes individually, and then call both methods. restaurant.py class Restaurant : \"\"\"A class representing a restaurant.\"\"\" def __init__ ( self , name , cuisine_type ): \"\"\"Initialize the restaurant.\"\"\" self . name = name . title () self . cuisine_type = cuisine_type def describe_restaurant ( self ): \"\"\"Display a summary of the restaurant.\"\"\" msg = f \" { self . name } serves wonderful { self . cuisine_type } .\" print ( f \" \\n { msg } \" ) def open_restaurant ( self ): \"\"\"Display a message that the restaurant is open.\"\"\" msg = f \" { self . name } is open. Come on in!\" print ( f \" \\n { msg } \" ) restaurant = Restaurant ( 'the mean queen' , 'pizza' ) print ( restaurant . name ) print ( restaurant . cuisine_type ) restaurant . describe_restaurant () restaurant . open_restaurant () Output: The Mean Queen pizza The Mean Queen serves wonderful pizza. The Mean Queen is open. Come on in! 9-2: Three Restaurants Start with your class from Exercise 9-1. Create three different instances from the class, and call describe_restaurant() for each instance. three_restaurants.py class Restaurant : \"\"\"A class representing a restaurant.\"\"\" def __init__ ( self , name , cuisine_type ): \"\"\"Initialize the restaurant.\"\"\" self . name = name . title () self . cuisine_type = cuisine_type def describe_restaurant ( self ): \"\"\"Display a summary of the restaurant.\"\"\" msg = f \" { self . name } serves wonderful { self . cuisine_type } .\" print ( f \" \\n { msg } \" ) def open_restaurant ( self ): \"\"\"Display a message that the restaurant is open.\"\"\" msg = f \" { self . name } is open. Come on in!\" print ( f \" \\n { msg } \" ) mean_queen = Restaurant ( 'the mean queen' , 'pizza' ) mean_queen . describe_restaurant () ludvigs = Restaurant ( \"ludvig's bistro\" , 'seafood' ) ludvigs . describe_restaurant () mango_thai = Restaurant ( 'mango thai' , 'thai food' ) mango_thai . describe_restaurant () Output: The Mean Queen serves wonderful pizza. Ludvig'S Bistro serves wonderful seafood. Mango Thai serves wonderful thai food. 9-3: Users Make a class called User . Create two attributes called first_name and last_name , and then create several other attributes that are typically stored in a user profile. Make a method called describe_user() that prints a summary of the user's information. Make another method called greet_user() that prints a personalized greeting to the user. Create several instances representing different users, and call both methods for each user. users.py class User : \"\"\"Represent a simple user profile.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the user.\"\"\" self . first_name = first_name . title () self . last_name = last_name . title () self . username = username self . email = email self . location = location . title () def describe_user ( self ): \"\"\"Display a summary of the user's information.\"\"\" print ( f \" \\n { self . first_name } { self . last_name } \" ) print ( f \" Username: { self . username } \" ) print ( f \" Email: { self . email } \" ) print ( f \" Location: { self . location } \" ) def greet_user ( self ): \"\"\"Display a personalized greeting to the user.\"\"\" print ( f \" \\n Welcome back, { self . username } !\" ) eric = User ( 'eric' , 'matthes' , 'e_matthes' , 'e_matthes@example.com' , 'alaska' ) eric . describe_user () eric . greet_user () willie = User ( 'willie' , 'burger' , 'willieburger' , 'wb@example.com' , 'alaska' ) willie . describe_user () willie . greet_user () Output: Eric Matthes Username: e_matthes Email: e_matthes@example.com Location: Alaska Welcome back, e_matthes! Willie Burger Username: willieburger Email: wb@example.com Location: Alaska Welcome back, willieburger! 9-4: Number Served Start with your program from Exercise 9-1 (page 162). Add an attribute called number_served with a default value of 0. Create an instance called restaurant from this class. Print the number of customers the restaurant has served, and then change this value and print it again. Add a method called set_number_served() that lets you set the number of customers that have been served. Call this method with a new number and print the value again. Add a method called increment_number_served() that lets you increment the number of customers who've been served. Call this method with any number you like that could represent how many customers were served in, say, a day of business. number_served.py class Restaurant : \"\"\"A class representing a restaurant.\"\"\" def __init__ ( self , name , cuisine_type ): \"\"\"Initialize the restaurant.\"\"\" self . name = name . title () self . cuisine_type = cuisine_type self . number_served = 0 def describe_restaurant ( self ): \"\"\"Display a summary of the restaurant.\"\"\" msg = f \" { self . name } serves wonderful { self . cuisine_type } .\" print ( f \" \\n { msg } \" ) def open_restaurant ( self ): \"\"\"Display a message that the restaurant is open.\"\"\" msg = f \" { self . name } is open. Come on in!\" print ( f \" \\n { msg } \" ) def set_number_served ( self , number_served ): \"\"\"Allow user to set the number of customers that have been served.\"\"\" self . number_served = number_served def increment_number_served ( self , additional_served ): \"\"\"Allow user to increment the number of customers served.\"\"\" self . number_served += additional_served restaurant = Restaurant ( 'the mean queen' , 'pizza' ) restaurant . describe_restaurant () print ( f \" \\n Number served: { restaurant . number_served } \" ) restaurant . number_served = 500 print ( f \"Number served: { restaurant . number_served } \" ) restaurant . set_number_served ( 1000 ) print ( f \"Number served: { restaurant . number_served } \" ) restaurant . increment_number_served ( 250 ) print ( f \"Number served: { restaurant . number_served } \" ) Output: The Mean Queen serves wonderful pizza. Number served: 0 Number served: 500 Number served: 1000 Number served: 1250 9-5: Login Attempts Add an attribute called login_attempts to your User class from Exercise 9-3 (page 162). Write a method called increment_login_attempts() that increments the value of login_attempts by 1. Write another method called reset_login_attempts() that resets the value of login_attempts to 0. Make an instance of the User class and call increment_login_attempts() several times. Print the value of login_attempts to make sure it was incremented properly, and then call reset_login_attempts() . Print login_attempts again to make sure it was reset to 0. login_attempts.py class User : \"\"\"Represent a simple user profile.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the user.\"\"\" self . first_name = first_name . title () self . last_name = last_name . title () self . username = username self . email = email self . location = location . title () self . login_attempts = 0 def describe_user ( self ): \"\"\"Display a summary of the user's information.\"\"\" print ( f \" \\n { self . first_name } { self . last_name } \" ) print ( f \" Username: { self . username } \" ) print ( f \" Email: { self . email } \" ) print ( f \" Location: { self . location } \" ) def greet_user ( self ): \"\"\"Display a personalized greeting to the user.\"\"\" print ( f \" \\n Welcome back, { self . username } !\" ) def increment_login_attempts ( self ): \"\"\"Increment the value of login_attempts.\"\"\" self . login_attempts += 1 def reset_login_attempts ( self ): \"\"\"Reset login_attempts to 0.\"\"\" self . login_attempts = 0 eric = User ( 'eric' , 'matthes' , 'e_matthes' , 'e_matthes@example.com' , 'alaska' ) eric . describe_user () eric . greet_user () print ( \" \\n Making 3 login attempts...\" ) eric . increment_login_attempts () eric . increment_login_attempts () eric . increment_login_attempts () print ( f \" Login attempts: { eric . login_attempts } \" ) print ( \"Resetting login attempts...\" ) eric . reset_login_attempts () print ( f \" Login attempts: { eric . login_attempts } \" ) Output: Eric Matthes Username: e_matthes Email: e_matthes@example.com Location: Alaska Welcome back, e_matthes! Making 3 login attempts... Login attempts: 3 Resetting login attempts... Login attempts: 0 9-6: Ice Cream Stand An ice cream stand is a specific kind of restaurant. Write a class called IceCreamStand that inherits from the Restaurant class you wrote in Exercise 9-1 (page 162) or Exercise 9-4 (page 166). Either version of the class will work; just pick the one you like better. Add an attribute called flavors that stores a list of ice cream flavors. Write a method that displays theese flavors. Create an instance of IceCreamStand , and call this method. ice_cream_stand.py class Restaurant : \"\"\"A class representing a restaurant.\"\"\" def __init__ ( self , name , cuisine_type ): \"\"\"Initialize the restaurant.\"\"\" self . name = name . title () self . cuisine_type = cuisine_type self . number_served = 0 def describe_restaurant ( self ): \"\"\"Display a summary of the restaurant.\"\"\" msg = f \" { self . name } serves wonderful { self . cuisine_type } .\" print ( f \" \\n { msg } \" ) def open_restaurant ( self ): \"\"\"Display a message that the restaurant is open.\"\"\" msg = f \" { self . name } is open. Come on in!\" print ( f \" \\n { msg } \" ) def set_number_served ( self , number_served ): \"\"\"Allow user to set the number of customers that have been served.\"\"\" self . number_served = number_served def increment_number_served ( self , additional_served ): \"\"\"Allow user to increment the number of customers served.\"\"\" self . number_served += additional_served class IceCreamStand ( Restaurant ): \"\"\"Represent an ice cream stand.\"\"\" def __init__ ( self , name , cuisine_type = 'ice cream' ): \"\"\"Initialize an ice cream stand.\"\"\" super () . __init__ ( name , cuisine_type ) self . flavors = [] def show_flavors ( self ): \"\"\"Display the flavors available.\"\"\" print ( \" \\n We have the following flavors available:\" ) for flavor in self . flavors : print ( f \"- { flavor . title () } \" ) big_one = IceCreamStand ( 'The Big One' ) big_one . flavors = [ 'vanilla' , 'chocolate' , 'black cherry' ] big_one . describe_restaurant () big_one . show_flavors () Output: The Big One serves wonderful ice cream. We have the following flavors available: - Vanilla - Chocolate - Black Cherry 9-7: Admin An administrator is a special kind of user. Write a class called Admin that inherits from the User class you wrote in Exercise 9-3 (page 162) or Exercise 9-5 (page 167). Add an attribute, privileges , that stores a list of strings like \"can add post\" , \"can delete post\" , \"can ban user\" , and so on. Write a method called show_privileges() that lists the administrator's set of privileges. Create an instance of Admin , and call your method. admin.py class User : \"\"\"Represent a simple user profile.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the user.\"\"\" self . first_name = first_name . title () self . last_name = last_name . title () self . username = username self . email = email self . location = location . title () self . login_attempts = 0 def describe_user ( self ): \"\"\"Display a summary of the user's information.\"\"\" print ( f \" \\n { self . first_name } { self . last_name } \" ) print ( f \" Username: { self . username } \" ) print ( f \" Email: { self . email } \" ) print ( f \" Location: { self . location } \" ) def greet_user ( self ): \"\"\"Display a personalized greeting to the user.\"\"\" print ( f \" \\n Welcome back, { self . username } !\" ) def increment_login_attempts ( self ): \"\"\"Increment the value of login_attempts.\"\"\" self . login_attempts += 1 def reset_login_attempts ( self ): \"\"\"Reset login_attempts to 0.\"\"\" self . login_attempts = 0 class Admin ( User ): \"\"\"A user with administrative privileges.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the admin.\"\"\" super () . __init__ ( first_name , last_name , username , email , location ) self . privileges = [] def show_privileges ( self ): \"\"\"Display the privileges this administrator has.\"\"\" print ( \" \\n Privileges:\" ) for privilege in self . privileges : print ( f \"- { privilege } \" ) eric = Admin ( 'eric' , 'matthes' , 'e_matthes' , 'e_matthes@example.com' , 'alaska' ) eric . describe_user () eric . privileges = [ 'can reset passwords' , 'can moderate discussions' , 'can suspend accounts' , ] eric . show_privileges () Output: Eric Matthes Username: e_matthes Email: e_matthes@example.com Location: Alaska Privileges: - can reset passwords - can moderate discussions - can suspend accounts 9-8: Privileges Write a separate Privileges class. The class should have one attribute, privileges , that stores a list of strings as described in Exercise 9-7. Move the show_privileges() method to this class. Make a Privileges instance as an attribute in the Admin class. Create a new instance of Admin and use your method to show its privileges. privileges.py class User : \"\"\"Represent a simple user profile.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the user.\"\"\" self . first_name = first_name . title () self . last_name = last_name . title () self . username = username self . email = email self . location = location . title () self . login_attempts = 0 def describe_user ( self ): \"\"\"Display a summary of the user's information.\"\"\" print ( f \" \\n { self . first_name } { self . last_name } \" ) print ( f \" Username: { self . username } \" ) print ( f \" Email: { self . email } \" ) print ( f \" Location: { self . location } \" ) def greet_user ( self ): \"\"\"Display a personalized greeting to the user.\"\"\" print ( f \" \\n Welcome back, { self . username } !\" ) def increment_login_attempts ( self ): \"\"\"Increment the value of login_attempts.\"\"\" self . login_attempts += 1 def reset_login_attempts ( self ): \"\"\"Reset login_attempts to 0.\"\"\" self . login_attempts = 0 class Admin ( User ): \"\"\"A user with administrative privileges.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the admin.\"\"\" super () . __init__ ( first_name , last_name , username , email , location ) # Initialize an empty set of privileges. self . privileges = Privileges () class Privileges : \"\"\"A class to store an admin's privileges.\"\"\" def __init__ ( self , privileges = []): self . privileges = privileges def show_privileges ( self ): print ( \" \\n Privileges:\" ) if self . privileges : for privilege in self . privileges : print ( f \"- { privilege } \" ) else : print ( \"- This user has no privileges.\" ) eric = Admin ( 'eric' , 'matthes' , 'e_matthes' , 'e_matthes@example.com' , 'alaska' ) eric . describe_user () eric . privileges . show_privileges () print ( \" \\n Adding privileges...\" ) eric_privileges = [ 'can reset passwords' , 'can moderate discussions' , 'can suspend accounts' , ] eric . privileges . privileges = eric_privileges eric . privileges . show_privileges () Output: Eric Matthes Username: e_matthes Email: e_matthes@example.com Location: Alaska Privileges: - This user has no privileges. Adding privileges... Privileges: - can reset passwords - can moderate discussions - can suspend accounts 9-9: Battery Upgrade Use the final version of electric_car.py from this section. Add a method to the Battery class called upgrade_battery() . This method should check the battery size and set the capacity to 65 if it isn't already. Make an electric car with a default battery size, call get_range() once, and then call get_range() a second time after upgrading the battery. You should see an increase in the car's range. battery_upgrade.py class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Initialize attributes to describe a car.\"\"\" self . make = make self . model = model self . year = year self . odometer_reading = 0 def get_descriptive_name ( self ): \"\"\"Return a neatly formatted descriptive name.\"\"\" long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () def read_odometer ( self ): \"\"\"Print a statement showing the car's mileage.\"\"\" print ( f \"This car has { self . odometer_reading } miles on it.\" ) def update_odometer ( self , mileage ): \"\"\"Set the odometer reading to the given value.\"\"\" if mileage >= self . odometer_reading : self . odometer_reading = mileage else : print ( \"You can't roll back an odometer!\" ) def increment_odometer ( self , miles ): \"\"\"Add the given amount to the odometer reading.\"\"\" self . odometer_reading += miles class Battery : \"\"\"A simple attempt to model a battery for an electric car.\"\"\" def __init__ ( self , battery_size = 40 ): \"\"\"Initialize the battery's attributes.\"\"\" self . battery_size = battery_size def describe_battery ( self ): \"\"\"Print a statement describing the battery size.\"\"\" print ( f \"This car has a { self . battery_size } -kWh battery.\" ) def get_range ( self ): \"\"\"Print a statement about the range this battery provides.\"\"\" if self . battery_size == 40 : range = 150 elif self . battery_size == 65 : range = 225 print ( f \"This car can go about { range } miles on a full charge.\" ) def upgrade_battery ( self ): \"\"\"Upgrade the battery if possible.\"\"\" if self . battery_size == 40 : self . battery_size = 65 print ( \"Upgraded the battery to 65 kWh.\" ) else : print ( \"The battery is already upgraded.\" ) class ElectricCar ( Car ): \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\" Initialize attributes of the parent class. Then initialize attributes specific to an electric car. \"\"\" super () . __init__ ( make , model , year ) self . battery = Battery () print ( \"Make an electric car, and check the range:\" ) my_leaf = ElectricCar ( 'nissan' , 'leaf' , 2024 ) my_leaf . battery . get_range () print ( \" \\n Upgrade the battery, and check the range again:\" ) my_leaf . battery . upgrade_battery () my_leaf . battery . get_range () Output: Make an electric car, and check the range: This car can go about 150 miles on a full charge. Upgrade the battery, and check the range again: Upgraded the battery to 65 kWh. This car can go about 225 miles on a full charge. 9-10: Imported Restaurant Using your latest Restaurant class, store it in a module. Make a separate file that imports Restaurant . Make a Restaurant instance, and call one of Restaurant 's methods to show that the import statement is working properly. restaurant.py \"\"\"A class representing a restaurant.\"\"\" class Restaurant : \"\"\"A class representing a restaurant.\"\"\" def __init__ ( self , name , cuisine_type ): \"\"\"Initialize the restaurant.\"\"\" self . name = name . title () self . cuisine_type = cuisine_type self . number_served = 0 def describe_restaurant ( self ): \"\"\"Display a summary of the restaurant.\"\"\" msg = f \" { self . name } serves wonderful { self . cuisine_type } .\" print ( f \" \\n { msg } \" ) def open_restaurant ( self ): \"\"\"Display a message that the restaurant is open.\"\"\" msg = f \" { self . name } is open. Come on in!\" print ( f \" \\n { msg } \" ) def set_number_served ( self , number_served ): \"\"\"Allow user to set the number of customers that have been served.\"\"\" self . number_served = number_served def increment_number_served ( self , additional_served ): \"\"\"Allow user to increment the number of customers served.\"\"\" self . number_served += additional_served my_restaurant.py from restaurant import Restaurant channel_club = Restaurant ( 'the channel club' , 'steak and seafood' ) channel_club . describe_restaurant () channel_club . open_restaurant () Output: The Channel Club serves wonderful steak and seafood. The Channel Club is open. Come on in! 9-11: Imported Admin Start with your work from Exercise 9-8 (page 173). Store the classes User , Privileges and Admin in one module. Create a separate file, make an Admin instance, and call show_priveleges() to show that everything is working correctly. user.py \"\"\"A collection of classes for modeling users.\"\"\" class User : \"\"\"Represent a simple user profile.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the user.\"\"\" self . first_name = first_name . title () self . last_name = last_name . title () self . username = username self . email = email self . location = location . title () self . login_attempts = 0 def describe_user ( self ): \"\"\"Display a summary of the user's information.\"\"\" print ( f \" \\n { self . first_name } { self . last_name } \" ) print ( f \" Username: { self . username } \" ) print ( f \" Email: { self . email } \" ) print ( f \" Location: { self . location } \" ) def greet_user ( self ): \"\"\"Display a personalized greeting to the user.\"\"\" print ( f \" \\n Welcome back, { self . username } !\" ) def increment_login_attempts ( self ): \"\"\"Increment the value of login_attempts.\"\"\" self . login_attempts += 1 def reset_login_attempts ( self ): \"\"\"Reset login_attempts to 0.\"\"\" self . login_attempts = 0 class Admin ( User ): \"\"\"A user with administrative privileges.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the admin.\"\"\" super () . __init__ ( first_name , last_name , username , email , location ) # Initialize an empty set of privileges. self . privileges = Privileges () class Privileges : \"\"\"A class to store an admin's privileges.\"\"\" def __init__ ( self , privileges = []): self . privileges = privileges def show_privileges ( self ): print ( \" \\n Privileges:\" ) if self . privileges : for privilege in self . privileges : print ( f \"- { privilege } \" ) else : print ( \"- This user has no privileges.\" ) my_user.py from user import Admin eric = Admin ( 'eric' , 'matthes' , 'e_matthes' , 'e_matthes@example.com' , 'alaska' ) eric . describe_user () eric_privileges = [ 'can reset passwords' , 'can moderate discussions' , 'can suspend accounts' , ] eric . privileges . privileges = eric_privileges print ( f \" \\n The admin { eric . username } has these privileges: \" ) eric . privileges . show_privileges () Output: Eric Matthes Username: e_matthes Email: e_matthes@example.com Location: Alaska The admin e_matthes has these privileges: - can reset passwords - can moderate discussions - can suspend accounts 9-12: Multiple Modules Store the User class in one module, and store the Privileges and Admin classes in a separate module. In a separate file, create an Admin instance and call show_privileges() to show that everything is still working correctly. user.py \"\"\"A class for modeling users.\"\"\" class User : \"\"\"Represent a simple user profile.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the user.\"\"\" self . first_name = first_name . title () self . last_name = last_name . title () self . username = username self . email = email self . location = location . title () self . login_attempts = 0 def describe_user ( self ): \"\"\"Display a summary of the user's information.\"\"\" print ( f \" \\n { self . first_name } { self . last_name } \" ) print ( f \" Username: { self . username } \" ) print ( f \" Email: { self . email } \" ) print ( f \" Location: { self . location } \" ) def greet_user ( self ): \"\"\"Display a personalized greeting to the user.\"\"\" print ( f \" \\n Welcome back, { self . username } !\" ) def increment_login_attempts ( self ): \"\"\"Increment the value of login_attempts.\"\"\" self . login_attempts += 1 def reset_login_attempts ( self ): \"\"\"Reset login_attempts to 0.\"\"\" self . login_attempts = 0 admin.py \"\"\"A collection of classes for modeling an admin user account.\"\"\" from user import User class Admin ( User ): \"\"\"A user with administrative privileges.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the admin.\"\"\" super () . __init__ ( first_name , last_name , username , email , location ) # Initialize an empty set of privileges. self . privileges = Privileges () class Privileges : \"\"\"A class to store an admin's privileges.\"\"\" def __init__ ( self , privileges = []): self . privileges = privileges def show_privileges ( self ): print ( \" \\n Privileges:\" ) if self . privileges : for privilege in self . privileges : print ( f \"- { privilege } \" ) else : print ( \"- This user has no privileges.\" ) my_admin.py from admin import Admin eric = Admin ( 'eric' , 'matthes' , 'e_matthes' , 'e_matthes@example.com' , 'alaska' ) eric . describe_user () eric_privileges = [ 'can reset passwords' , 'can moderate discussions' , 'can suspend accounts' , ] eric . privileges . privileges = eric_privileges print ( f \" \\n The admin { eric . username } has these privileges: \" ) eric . privileges . show_privileges () Output: Eric Matthes Username: e_matthes Email: e_matthes@example.com Location: Alaska The admin e_matthes has these privileges: - can reset passwords - can moderate discussions - can suspend accounts 9-13: Dice Make a class Die with one attribute called sides , which has a default value of 6. Write a method called roll_die() that prints a random number between 1 and the number of sides the die has. Make a 6-sided die and roll it 10 times. Make a 10-sided die and a 20-sided die. Roll each die 10 times. dice.py from random import randint class Die : \"\"\"Represent a die, which can be rolled.\"\"\" def __init__ ( self , sides = 6 ): \"\"\"Initialize the die.\"\"\" self . sides = sides def roll_die ( self ): \"\"\"Return a number between 1 and the number of sides.\"\"\" return randint ( 1 , self . sides ) # Make a 6-sided die, and show the results of 10 rolls. d6 = Die () results = [] for roll_num in range ( 10 ): result = d6 . roll_die () results . append ( result ) print ( \"10 rolls of a 6-sided die:\" ) print ( results ) # Make a 10-sided die, and show the results of 10 rolls. d10 = Die ( sides = 10 ) results = [] for roll_num in range ( 10 ): result = d10 . roll_die () results . append ( result ) print ( \" \\n 10 rolls of a 10-sided die:\" ) print ( results ) # Make a 20-sided die, and show the results of 10 rolls. d20 = Die ( sides = 20 ) results = [] for roll_num in range ( 10 ): result = d20 . roll_die () results . append ( result ) print ( \" \\n 10 rolls of a 20-sided die:\" ) print ( results ) Output: 10 rolls of a 6-sided die: [6, 1, 2, 1, 6, 6, 2, 5, 3, 4] 10 rolls of a 10-sided die: [5, 2, 6, 7, 6, 8, 10, 6, 7, 10] 10 rolls of a 20-sided die: [5, 1, 14, 4, 10, 13, 3, 2, 18, 20] 9-14: Lottery Make a list or tuple containing a series of 10 numbers and 5 letters. Randomly select 4 numbers or letters from the list and print a message saying that any ticket matching these 4 numbers or letters wins a prize. lottery.py from random import choice possibilities = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 'a' , 'b' , 'c' , 'd' , 'e' ] winning_ticket = [] print ( \"Let's see what the winning ticket is...\" ) # We don't want to repeat winning numbers or letters, so we'll use a # while loop. while len ( winning_ticket ) < 4 : pulled_item = choice ( possibilities ) # Only add the pulled item to the winning ticket if it hasn't # already been pulled. if pulled_item not in winning_ticket : print ( f \" We pulled a { pulled_item } !\" ) winning_ticket . append ( pulled_item ) print ( f \" \\n The final winning ticket is: { winning_ticket } \" ) Output: Let's see what the winning ticket is... We pulled a 2! We pulled a 3! We pulled a 5! We pulled a c! The final winning ticket is: [2, 3, 5, 'c'] 9-15: Lottery Analysis You can use a loop to see how hard it might be to win the kind of lottery you just modeled. Make a list or tuple called my_ticket . Write a loop that keeps pulling numbers until your ticket wins. Print a message reporting how many times the loop had to run to give you a winning ticket. from random import choice def get_winning_ticket ( possibilities ): \"\"\"Return a winning ticket from a set of possibilities.\"\"\" winning_ticket = [] # We don't want to repeat winning numbers or letters, so we'll use a # while loop. while len ( winning_ticket ) < 4 : pulled_item = choice ( possibilities ) # Only add the pulled item to the winning ticket if it hasn't # already been pulled. if pulled_item not in winning_ticket : winning_ticket . append ( pulled_item ) return winning_ticket def check_ticket ( played_ticket , winning_ticket ): # Check all elements in the played ticket. If any are not in the # winning ticket, return False. for element in played_ticket : if element not in winning_ticket : return False # We must have a winning ticket! return True def make_random_ticket ( possibilities ): \"\"\"Return a random ticket from a set of possibilities.\"\"\" ticket = [] # We don't want to repeat numbers or letters, so we'll use a while loop. while len ( ticket ) < 4 : pulled_item = choice ( possibilities ) # Only add the pulled item to the ticket if it hasn't already # been pulled. if pulled_item not in ticket : ticket . append ( pulled_item ) return ticket possibilities = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 'a' , 'b' , 'c' , 'd' , 'e' ] winning_ticket = get_winning_ticket ( possibilities ) plays = 0 won = False # Let's set a max number of tries, in case this takes forever! max_tries = 1_000_000 while not won : new_ticket = make_random_ticket ( possibilities ) won = check_ticket ( new_ticket , winning_ticket ) plays += 1 if plays >= max_tries : break if won : print ( \"We have a winning ticket!\" ) print ( f \"Your ticket: { new_ticket } \" ) print ( f \"Winning ticket: { winning_ticket } \" ) print ( f \"It only took { plays } tries to win!\" ) else : print ( f \"Tried { plays } times, without pulling a winner. :(\" ) print ( f \"Your ticket: { new_ticket } \" ) print ( f \"Winning ticket: { winning_ticket } \" ) Output: We have a winning ticket! Your ticket: [1, 4, 'a', 9] Winning ticket: [1, 9, 'a', 4] It only took 731 tries to win!","title":"Chapter 9"},{"location":"solutions/chapter_9/#solutions-chapter-9","text":"","title":"Solutions - Chapter 9"},{"location":"solutions/chapter_9/#9-1-restaurant","text":"Make a class called Restaurant . The __init__() method for Restaurant should store two attributes: a restaurant_name and a cuisine_type . Make a method called describe_restaurant() that prints these two pieces of information, and a method called open_restaurant() that prints a message indicating that the restaurant is open. Make an instance called restaurant from your class. Print the two attributes individually, and then call both methods. restaurant.py class Restaurant : \"\"\"A class representing a restaurant.\"\"\" def __init__ ( self , name , cuisine_type ): \"\"\"Initialize the restaurant.\"\"\" self . name = name . title () self . cuisine_type = cuisine_type def describe_restaurant ( self ): \"\"\"Display a summary of the restaurant.\"\"\" msg = f \" { self . name } serves wonderful { self . cuisine_type } .\" print ( f \" \\n { msg } \" ) def open_restaurant ( self ): \"\"\"Display a message that the restaurant is open.\"\"\" msg = f \" { self . name } is open. Come on in!\" print ( f \" \\n { msg } \" ) restaurant = Restaurant ( 'the mean queen' , 'pizza' ) print ( restaurant . name ) print ( restaurant . cuisine_type ) restaurant . describe_restaurant () restaurant . open_restaurant () Output: The Mean Queen pizza The Mean Queen serves wonderful pizza. The Mean Queen is open. Come on in!","title":"9-1: Restaurant"},{"location":"solutions/chapter_9/#9-2-three-restaurants","text":"Start with your class from Exercise 9-1. Create three different instances from the class, and call describe_restaurant() for each instance. three_restaurants.py class Restaurant : \"\"\"A class representing a restaurant.\"\"\" def __init__ ( self , name , cuisine_type ): \"\"\"Initialize the restaurant.\"\"\" self . name = name . title () self . cuisine_type = cuisine_type def describe_restaurant ( self ): \"\"\"Display a summary of the restaurant.\"\"\" msg = f \" { self . name } serves wonderful { self . cuisine_type } .\" print ( f \" \\n { msg } \" ) def open_restaurant ( self ): \"\"\"Display a message that the restaurant is open.\"\"\" msg = f \" { self . name } is open. Come on in!\" print ( f \" \\n { msg } \" ) mean_queen = Restaurant ( 'the mean queen' , 'pizza' ) mean_queen . describe_restaurant () ludvigs = Restaurant ( \"ludvig's bistro\" , 'seafood' ) ludvigs . describe_restaurant () mango_thai = Restaurant ( 'mango thai' , 'thai food' ) mango_thai . describe_restaurant () Output: The Mean Queen serves wonderful pizza. Ludvig'S Bistro serves wonderful seafood. Mango Thai serves wonderful thai food.","title":"9-2: Three Restaurants"},{"location":"solutions/chapter_9/#9-3-users","text":"Make a class called User . Create two attributes called first_name and last_name , and then create several other attributes that are typically stored in a user profile. Make a method called describe_user() that prints a summary of the user's information. Make another method called greet_user() that prints a personalized greeting to the user. Create several instances representing different users, and call both methods for each user. users.py class User : \"\"\"Represent a simple user profile.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the user.\"\"\" self . first_name = first_name . title () self . last_name = last_name . title () self . username = username self . email = email self . location = location . title () def describe_user ( self ): \"\"\"Display a summary of the user's information.\"\"\" print ( f \" \\n { self . first_name } { self . last_name } \" ) print ( f \" Username: { self . username } \" ) print ( f \" Email: { self . email } \" ) print ( f \" Location: { self . location } \" ) def greet_user ( self ): \"\"\"Display a personalized greeting to the user.\"\"\" print ( f \" \\n Welcome back, { self . username } !\" ) eric = User ( 'eric' , 'matthes' , 'e_matthes' , 'e_matthes@example.com' , 'alaska' ) eric . describe_user () eric . greet_user () willie = User ( 'willie' , 'burger' , 'willieburger' , 'wb@example.com' , 'alaska' ) willie . describe_user () willie . greet_user () Output: Eric Matthes Username: e_matthes Email: e_matthes@example.com Location: Alaska Welcome back, e_matthes! Willie Burger Username: willieburger Email: wb@example.com Location: Alaska Welcome back, willieburger!","title":"9-3: Users"},{"location":"solutions/chapter_9/#9-4-number-served","text":"Start with your program from Exercise 9-1 (page 162). Add an attribute called number_served with a default value of 0. Create an instance called restaurant from this class. Print the number of customers the restaurant has served, and then change this value and print it again. Add a method called set_number_served() that lets you set the number of customers that have been served. Call this method with a new number and print the value again. Add a method called increment_number_served() that lets you increment the number of customers who've been served. Call this method with any number you like that could represent how many customers were served in, say, a day of business. number_served.py class Restaurant : \"\"\"A class representing a restaurant.\"\"\" def __init__ ( self , name , cuisine_type ): \"\"\"Initialize the restaurant.\"\"\" self . name = name . title () self . cuisine_type = cuisine_type self . number_served = 0 def describe_restaurant ( self ): \"\"\"Display a summary of the restaurant.\"\"\" msg = f \" { self . name } serves wonderful { self . cuisine_type } .\" print ( f \" \\n { msg } \" ) def open_restaurant ( self ): \"\"\"Display a message that the restaurant is open.\"\"\" msg = f \" { self . name } is open. Come on in!\" print ( f \" \\n { msg } \" ) def set_number_served ( self , number_served ): \"\"\"Allow user to set the number of customers that have been served.\"\"\" self . number_served = number_served def increment_number_served ( self , additional_served ): \"\"\"Allow user to increment the number of customers served.\"\"\" self . number_served += additional_served restaurant = Restaurant ( 'the mean queen' , 'pizza' ) restaurant . describe_restaurant () print ( f \" \\n Number served: { restaurant . number_served } \" ) restaurant . number_served = 500 print ( f \"Number served: { restaurant . number_served } \" ) restaurant . set_number_served ( 1000 ) print ( f \"Number served: { restaurant . number_served } \" ) restaurant . increment_number_served ( 250 ) print ( f \"Number served: { restaurant . number_served } \" ) Output: The Mean Queen serves wonderful pizza. Number served: 0 Number served: 500 Number served: 1000 Number served: 1250","title":"9-4: Number Served"},{"location":"solutions/chapter_9/#9-5-login-attempts","text":"Add an attribute called login_attempts to your User class from Exercise 9-3 (page 162). Write a method called increment_login_attempts() that increments the value of login_attempts by 1. Write another method called reset_login_attempts() that resets the value of login_attempts to 0. Make an instance of the User class and call increment_login_attempts() several times. Print the value of login_attempts to make sure it was incremented properly, and then call reset_login_attempts() . Print login_attempts again to make sure it was reset to 0. login_attempts.py class User : \"\"\"Represent a simple user profile.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the user.\"\"\" self . first_name = first_name . title () self . last_name = last_name . title () self . username = username self . email = email self . location = location . title () self . login_attempts = 0 def describe_user ( self ): \"\"\"Display a summary of the user's information.\"\"\" print ( f \" \\n { self . first_name } { self . last_name } \" ) print ( f \" Username: { self . username } \" ) print ( f \" Email: { self . email } \" ) print ( f \" Location: { self . location } \" ) def greet_user ( self ): \"\"\"Display a personalized greeting to the user.\"\"\" print ( f \" \\n Welcome back, { self . username } !\" ) def increment_login_attempts ( self ): \"\"\"Increment the value of login_attempts.\"\"\" self . login_attempts += 1 def reset_login_attempts ( self ): \"\"\"Reset login_attempts to 0.\"\"\" self . login_attempts = 0 eric = User ( 'eric' , 'matthes' , 'e_matthes' , 'e_matthes@example.com' , 'alaska' ) eric . describe_user () eric . greet_user () print ( \" \\n Making 3 login attempts...\" ) eric . increment_login_attempts () eric . increment_login_attempts () eric . increment_login_attempts () print ( f \" Login attempts: { eric . login_attempts } \" ) print ( \"Resetting login attempts...\" ) eric . reset_login_attempts () print ( f \" Login attempts: { eric . login_attempts } \" ) Output: Eric Matthes Username: e_matthes Email: e_matthes@example.com Location: Alaska Welcome back, e_matthes! Making 3 login attempts... Login attempts: 3 Resetting login attempts... Login attempts: 0","title":"9-5: Login Attempts"},{"location":"solutions/chapter_9/#9-6-ice-cream-stand","text":"An ice cream stand is a specific kind of restaurant. Write a class called IceCreamStand that inherits from the Restaurant class you wrote in Exercise 9-1 (page 162) or Exercise 9-4 (page 166). Either version of the class will work; just pick the one you like better. Add an attribute called flavors that stores a list of ice cream flavors. Write a method that displays theese flavors. Create an instance of IceCreamStand , and call this method. ice_cream_stand.py class Restaurant : \"\"\"A class representing a restaurant.\"\"\" def __init__ ( self , name , cuisine_type ): \"\"\"Initialize the restaurant.\"\"\" self . name = name . title () self . cuisine_type = cuisine_type self . number_served = 0 def describe_restaurant ( self ): \"\"\"Display a summary of the restaurant.\"\"\" msg = f \" { self . name } serves wonderful { self . cuisine_type } .\" print ( f \" \\n { msg } \" ) def open_restaurant ( self ): \"\"\"Display a message that the restaurant is open.\"\"\" msg = f \" { self . name } is open. Come on in!\" print ( f \" \\n { msg } \" ) def set_number_served ( self , number_served ): \"\"\"Allow user to set the number of customers that have been served.\"\"\" self . number_served = number_served def increment_number_served ( self , additional_served ): \"\"\"Allow user to increment the number of customers served.\"\"\" self . number_served += additional_served class IceCreamStand ( Restaurant ): \"\"\"Represent an ice cream stand.\"\"\" def __init__ ( self , name , cuisine_type = 'ice cream' ): \"\"\"Initialize an ice cream stand.\"\"\" super () . __init__ ( name , cuisine_type ) self . flavors = [] def show_flavors ( self ): \"\"\"Display the flavors available.\"\"\" print ( \" \\n We have the following flavors available:\" ) for flavor in self . flavors : print ( f \"- { flavor . title () } \" ) big_one = IceCreamStand ( 'The Big One' ) big_one . flavors = [ 'vanilla' , 'chocolate' , 'black cherry' ] big_one . describe_restaurant () big_one . show_flavors () Output: The Big One serves wonderful ice cream. We have the following flavors available: - Vanilla - Chocolate - Black Cherry","title":"9-6: Ice Cream Stand"},{"location":"solutions/chapter_9/#9-7-admin","text":"An administrator is a special kind of user. Write a class called Admin that inherits from the User class you wrote in Exercise 9-3 (page 162) or Exercise 9-5 (page 167). Add an attribute, privileges , that stores a list of strings like \"can add post\" , \"can delete post\" , \"can ban user\" , and so on. Write a method called show_privileges() that lists the administrator's set of privileges. Create an instance of Admin , and call your method. admin.py class User : \"\"\"Represent a simple user profile.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the user.\"\"\" self . first_name = first_name . title () self . last_name = last_name . title () self . username = username self . email = email self . location = location . title () self . login_attempts = 0 def describe_user ( self ): \"\"\"Display a summary of the user's information.\"\"\" print ( f \" \\n { self . first_name } { self . last_name } \" ) print ( f \" Username: { self . username } \" ) print ( f \" Email: { self . email } \" ) print ( f \" Location: { self . location } \" ) def greet_user ( self ): \"\"\"Display a personalized greeting to the user.\"\"\" print ( f \" \\n Welcome back, { self . username } !\" ) def increment_login_attempts ( self ): \"\"\"Increment the value of login_attempts.\"\"\" self . login_attempts += 1 def reset_login_attempts ( self ): \"\"\"Reset login_attempts to 0.\"\"\" self . login_attempts = 0 class Admin ( User ): \"\"\"A user with administrative privileges.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the admin.\"\"\" super () . __init__ ( first_name , last_name , username , email , location ) self . privileges = [] def show_privileges ( self ): \"\"\"Display the privileges this administrator has.\"\"\" print ( \" \\n Privileges:\" ) for privilege in self . privileges : print ( f \"- { privilege } \" ) eric = Admin ( 'eric' , 'matthes' , 'e_matthes' , 'e_matthes@example.com' , 'alaska' ) eric . describe_user () eric . privileges = [ 'can reset passwords' , 'can moderate discussions' , 'can suspend accounts' , ] eric . show_privileges () Output: Eric Matthes Username: e_matthes Email: e_matthes@example.com Location: Alaska Privileges: - can reset passwords - can moderate discussions - can suspend accounts","title":"9-7: Admin"},{"location":"solutions/chapter_9/#9-8-privileges","text":"Write a separate Privileges class. The class should have one attribute, privileges , that stores a list of strings as described in Exercise 9-7. Move the show_privileges() method to this class. Make a Privileges instance as an attribute in the Admin class. Create a new instance of Admin and use your method to show its privileges. privileges.py class User : \"\"\"Represent a simple user profile.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the user.\"\"\" self . first_name = first_name . title () self . last_name = last_name . title () self . username = username self . email = email self . location = location . title () self . login_attempts = 0 def describe_user ( self ): \"\"\"Display a summary of the user's information.\"\"\" print ( f \" \\n { self . first_name } { self . last_name } \" ) print ( f \" Username: { self . username } \" ) print ( f \" Email: { self . email } \" ) print ( f \" Location: { self . location } \" ) def greet_user ( self ): \"\"\"Display a personalized greeting to the user.\"\"\" print ( f \" \\n Welcome back, { self . username } !\" ) def increment_login_attempts ( self ): \"\"\"Increment the value of login_attempts.\"\"\" self . login_attempts += 1 def reset_login_attempts ( self ): \"\"\"Reset login_attempts to 0.\"\"\" self . login_attempts = 0 class Admin ( User ): \"\"\"A user with administrative privileges.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the admin.\"\"\" super () . __init__ ( first_name , last_name , username , email , location ) # Initialize an empty set of privileges. self . privileges = Privileges () class Privileges : \"\"\"A class to store an admin's privileges.\"\"\" def __init__ ( self , privileges = []): self . privileges = privileges def show_privileges ( self ): print ( \" \\n Privileges:\" ) if self . privileges : for privilege in self . privileges : print ( f \"- { privilege } \" ) else : print ( \"- This user has no privileges.\" ) eric = Admin ( 'eric' , 'matthes' , 'e_matthes' , 'e_matthes@example.com' , 'alaska' ) eric . describe_user () eric . privileges . show_privileges () print ( \" \\n Adding privileges...\" ) eric_privileges = [ 'can reset passwords' , 'can moderate discussions' , 'can suspend accounts' , ] eric . privileges . privileges = eric_privileges eric . privileges . show_privileges () Output: Eric Matthes Username: e_matthes Email: e_matthes@example.com Location: Alaska Privileges: - This user has no privileges. Adding privileges... Privileges: - can reset passwords - can moderate discussions - can suspend accounts","title":"9-8: Privileges"},{"location":"solutions/chapter_9/#9-9-battery-upgrade","text":"Use the final version of electric_car.py from this section. Add a method to the Battery class called upgrade_battery() . This method should check the battery size and set the capacity to 65 if it isn't already. Make an electric car with a default battery size, call get_range() once, and then call get_range() a second time after upgrading the battery. You should see an increase in the car's range. battery_upgrade.py class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Initialize attributes to describe a car.\"\"\" self . make = make self . model = model self . year = year self . odometer_reading = 0 def get_descriptive_name ( self ): \"\"\"Return a neatly formatted descriptive name.\"\"\" long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () def read_odometer ( self ): \"\"\"Print a statement showing the car's mileage.\"\"\" print ( f \"This car has { self . odometer_reading } miles on it.\" ) def update_odometer ( self , mileage ): \"\"\"Set the odometer reading to the given value.\"\"\" if mileage >= self . odometer_reading : self . odometer_reading = mileage else : print ( \"You can't roll back an odometer!\" ) def increment_odometer ( self , miles ): \"\"\"Add the given amount to the odometer reading.\"\"\" self . odometer_reading += miles class Battery : \"\"\"A simple attempt to model a battery for an electric car.\"\"\" def __init__ ( self , battery_size = 40 ): \"\"\"Initialize the battery's attributes.\"\"\" self . battery_size = battery_size def describe_battery ( self ): \"\"\"Print a statement describing the battery size.\"\"\" print ( f \"This car has a { self . battery_size } -kWh battery.\" ) def get_range ( self ): \"\"\"Print a statement about the range this battery provides.\"\"\" if self . battery_size == 40 : range = 150 elif self . battery_size == 65 : range = 225 print ( f \"This car can go about { range } miles on a full charge.\" ) def upgrade_battery ( self ): \"\"\"Upgrade the battery if possible.\"\"\" if self . battery_size == 40 : self . battery_size = 65 print ( \"Upgraded the battery to 65 kWh.\" ) else : print ( \"The battery is already upgraded.\" ) class ElectricCar ( Car ): \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\" Initialize attributes of the parent class. Then initialize attributes specific to an electric car. \"\"\" super () . __init__ ( make , model , year ) self . battery = Battery () print ( \"Make an electric car, and check the range:\" ) my_leaf = ElectricCar ( 'nissan' , 'leaf' , 2024 ) my_leaf . battery . get_range () print ( \" \\n Upgrade the battery, and check the range again:\" ) my_leaf . battery . upgrade_battery () my_leaf . battery . get_range () Output: Make an electric car, and check the range: This car can go about 150 miles on a full charge. Upgrade the battery, and check the range again: Upgraded the battery to 65 kWh. This car can go about 225 miles on a full charge.","title":"9-9: Battery Upgrade"},{"location":"solutions/chapter_9/#9-10-imported-restaurant","text":"Using your latest Restaurant class, store it in a module. Make a separate file that imports Restaurant . Make a Restaurant instance, and call one of Restaurant 's methods to show that the import statement is working properly. restaurant.py \"\"\"A class representing a restaurant.\"\"\" class Restaurant : \"\"\"A class representing a restaurant.\"\"\" def __init__ ( self , name , cuisine_type ): \"\"\"Initialize the restaurant.\"\"\" self . name = name . title () self . cuisine_type = cuisine_type self . number_served = 0 def describe_restaurant ( self ): \"\"\"Display a summary of the restaurant.\"\"\" msg = f \" { self . name } serves wonderful { self . cuisine_type } .\" print ( f \" \\n { msg } \" ) def open_restaurant ( self ): \"\"\"Display a message that the restaurant is open.\"\"\" msg = f \" { self . name } is open. Come on in!\" print ( f \" \\n { msg } \" ) def set_number_served ( self , number_served ): \"\"\"Allow user to set the number of customers that have been served.\"\"\" self . number_served = number_served def increment_number_served ( self , additional_served ): \"\"\"Allow user to increment the number of customers served.\"\"\" self . number_served += additional_served my_restaurant.py from restaurant import Restaurant channel_club = Restaurant ( 'the channel club' , 'steak and seafood' ) channel_club . describe_restaurant () channel_club . open_restaurant () Output: The Channel Club serves wonderful steak and seafood. The Channel Club is open. Come on in!","title":"9-10: Imported Restaurant"},{"location":"solutions/chapter_9/#9-11-imported-admin","text":"Start with your work from Exercise 9-8 (page 173). Store the classes User , Privileges and Admin in one module. Create a separate file, make an Admin instance, and call show_priveleges() to show that everything is working correctly. user.py \"\"\"A collection of classes for modeling users.\"\"\" class User : \"\"\"Represent a simple user profile.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the user.\"\"\" self . first_name = first_name . title () self . last_name = last_name . title () self . username = username self . email = email self . location = location . title () self . login_attempts = 0 def describe_user ( self ): \"\"\"Display a summary of the user's information.\"\"\" print ( f \" \\n { self . first_name } { self . last_name } \" ) print ( f \" Username: { self . username } \" ) print ( f \" Email: { self . email } \" ) print ( f \" Location: { self . location } \" ) def greet_user ( self ): \"\"\"Display a personalized greeting to the user.\"\"\" print ( f \" \\n Welcome back, { self . username } !\" ) def increment_login_attempts ( self ): \"\"\"Increment the value of login_attempts.\"\"\" self . login_attempts += 1 def reset_login_attempts ( self ): \"\"\"Reset login_attempts to 0.\"\"\" self . login_attempts = 0 class Admin ( User ): \"\"\"A user with administrative privileges.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the admin.\"\"\" super () . __init__ ( first_name , last_name , username , email , location ) # Initialize an empty set of privileges. self . privileges = Privileges () class Privileges : \"\"\"A class to store an admin's privileges.\"\"\" def __init__ ( self , privileges = []): self . privileges = privileges def show_privileges ( self ): print ( \" \\n Privileges:\" ) if self . privileges : for privilege in self . privileges : print ( f \"- { privilege } \" ) else : print ( \"- This user has no privileges.\" ) my_user.py from user import Admin eric = Admin ( 'eric' , 'matthes' , 'e_matthes' , 'e_matthes@example.com' , 'alaska' ) eric . describe_user () eric_privileges = [ 'can reset passwords' , 'can moderate discussions' , 'can suspend accounts' , ] eric . privileges . privileges = eric_privileges print ( f \" \\n The admin { eric . username } has these privileges: \" ) eric . privileges . show_privileges () Output: Eric Matthes Username: e_matthes Email: e_matthes@example.com Location: Alaska The admin e_matthes has these privileges: - can reset passwords - can moderate discussions - can suspend accounts","title":"9-11: Imported Admin"},{"location":"solutions/chapter_9/#9-12-multiple-modules","text":"Store the User class in one module, and store the Privileges and Admin classes in a separate module. In a separate file, create an Admin instance and call show_privileges() to show that everything is still working correctly. user.py \"\"\"A class for modeling users.\"\"\" class User : \"\"\"Represent a simple user profile.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the user.\"\"\" self . first_name = first_name . title () self . last_name = last_name . title () self . username = username self . email = email self . location = location . title () self . login_attempts = 0 def describe_user ( self ): \"\"\"Display a summary of the user's information.\"\"\" print ( f \" \\n { self . first_name } { self . last_name } \" ) print ( f \" Username: { self . username } \" ) print ( f \" Email: { self . email } \" ) print ( f \" Location: { self . location } \" ) def greet_user ( self ): \"\"\"Display a personalized greeting to the user.\"\"\" print ( f \" \\n Welcome back, { self . username } !\" ) def increment_login_attempts ( self ): \"\"\"Increment the value of login_attempts.\"\"\" self . login_attempts += 1 def reset_login_attempts ( self ): \"\"\"Reset login_attempts to 0.\"\"\" self . login_attempts = 0 admin.py \"\"\"A collection of classes for modeling an admin user account.\"\"\" from user import User class Admin ( User ): \"\"\"A user with administrative privileges.\"\"\" def __init__ ( self , first_name , last_name , username , email , location ): \"\"\"Initialize the admin.\"\"\" super () . __init__ ( first_name , last_name , username , email , location ) # Initialize an empty set of privileges. self . privileges = Privileges () class Privileges : \"\"\"A class to store an admin's privileges.\"\"\" def __init__ ( self , privileges = []): self . privileges = privileges def show_privileges ( self ): print ( \" \\n Privileges:\" ) if self . privileges : for privilege in self . privileges : print ( f \"- { privilege } \" ) else : print ( \"- This user has no privileges.\" ) my_admin.py from admin import Admin eric = Admin ( 'eric' , 'matthes' , 'e_matthes' , 'e_matthes@example.com' , 'alaska' ) eric . describe_user () eric_privileges = [ 'can reset passwords' , 'can moderate discussions' , 'can suspend accounts' , ] eric . privileges . privileges = eric_privileges print ( f \" \\n The admin { eric . username } has these privileges: \" ) eric . privileges . show_privileges () Output: Eric Matthes Username: e_matthes Email: e_matthes@example.com Location: Alaska The admin e_matthes has these privileges: - can reset passwords - can moderate discussions - can suspend accounts","title":"9-12: Multiple Modules"},{"location":"solutions/chapter_9/#9-13-dice","text":"Make a class Die with one attribute called sides , which has a default value of 6. Write a method called roll_die() that prints a random number between 1 and the number of sides the die has. Make a 6-sided die and roll it 10 times. Make a 10-sided die and a 20-sided die. Roll each die 10 times. dice.py from random import randint class Die : \"\"\"Represent a die, which can be rolled.\"\"\" def __init__ ( self , sides = 6 ): \"\"\"Initialize the die.\"\"\" self . sides = sides def roll_die ( self ): \"\"\"Return a number between 1 and the number of sides.\"\"\" return randint ( 1 , self . sides ) # Make a 6-sided die, and show the results of 10 rolls. d6 = Die () results = [] for roll_num in range ( 10 ): result = d6 . roll_die () results . append ( result ) print ( \"10 rolls of a 6-sided die:\" ) print ( results ) # Make a 10-sided die, and show the results of 10 rolls. d10 = Die ( sides = 10 ) results = [] for roll_num in range ( 10 ): result = d10 . roll_die () results . append ( result ) print ( \" \\n 10 rolls of a 10-sided die:\" ) print ( results ) # Make a 20-sided die, and show the results of 10 rolls. d20 = Die ( sides = 20 ) results = [] for roll_num in range ( 10 ): result = d20 . roll_die () results . append ( result ) print ( \" \\n 10 rolls of a 20-sided die:\" ) print ( results ) Output: 10 rolls of a 6-sided die: [6, 1, 2, 1, 6, 6, 2, 5, 3, 4] 10 rolls of a 10-sided die: [5, 2, 6, 7, 6, 8, 10, 6, 7, 10] 10 rolls of a 20-sided die: [5, 1, 14, 4, 10, 13, 3, 2, 18, 20]","title":"9-13: Dice"},{"location":"solutions/chapter_9/#9-14-lottery","text":"Make a list or tuple containing a series of 10 numbers and 5 letters. Randomly select 4 numbers or letters from the list and print a message saying that any ticket matching these 4 numbers or letters wins a prize. lottery.py from random import choice possibilities = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 'a' , 'b' , 'c' , 'd' , 'e' ] winning_ticket = [] print ( \"Let's see what the winning ticket is...\" ) # We don't want to repeat winning numbers or letters, so we'll use a # while loop. while len ( winning_ticket ) < 4 : pulled_item = choice ( possibilities ) # Only add the pulled item to the winning ticket if it hasn't # already been pulled. if pulled_item not in winning_ticket : print ( f \" We pulled a { pulled_item } !\" ) winning_ticket . append ( pulled_item ) print ( f \" \\n The final winning ticket is: { winning_ticket } \" ) Output: Let's see what the winning ticket is... We pulled a 2! We pulled a 3! We pulled a 5! We pulled a c! The final winning ticket is: [2, 3, 5, 'c']","title":"9-14: Lottery"},{"location":"solutions/chapter_9/#9-15-lottery-analysis","text":"You can use a loop to see how hard it might be to win the kind of lottery you just modeled. Make a list or tuple called my_ticket . Write a loop that keeps pulling numbers until your ticket wins. Print a message reporting how many times the loop had to run to give you a winning ticket. from random import choice def get_winning_ticket ( possibilities ): \"\"\"Return a winning ticket from a set of possibilities.\"\"\" winning_ticket = [] # We don't want to repeat winning numbers or letters, so we'll use a # while loop. while len ( winning_ticket ) < 4 : pulled_item = choice ( possibilities ) # Only add the pulled item to the winning ticket if it hasn't # already been pulled. if pulled_item not in winning_ticket : winning_ticket . append ( pulled_item ) return winning_ticket def check_ticket ( played_ticket , winning_ticket ): # Check all elements in the played ticket. If any are not in the # winning ticket, return False. for element in played_ticket : if element not in winning_ticket : return False # We must have a winning ticket! return True def make_random_ticket ( possibilities ): \"\"\"Return a random ticket from a set of possibilities.\"\"\" ticket = [] # We don't want to repeat numbers or letters, so we'll use a while loop. while len ( ticket ) < 4 : pulled_item = choice ( possibilities ) # Only add the pulled item to the ticket if it hasn't already # been pulled. if pulled_item not in ticket : ticket . append ( pulled_item ) return ticket possibilities = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 'a' , 'b' , 'c' , 'd' , 'e' ] winning_ticket = get_winning_ticket ( possibilities ) plays = 0 won = False # Let's set a max number of tries, in case this takes forever! max_tries = 1_000_000 while not won : new_ticket = make_random_ticket ( possibilities ) won = check_ticket ( new_ticket , winning_ticket ) plays += 1 if plays >= max_tries : break if won : print ( \"We have a winning ticket!\" ) print ( f \"Your ticket: { new_ticket } \" ) print ( f \"Winning ticket: { winning_ticket } \" ) print ( f \"It only took { plays } tries to win!\" ) else : print ( f \"Tried { plays } times, without pulling a winner. :(\" ) print ( f \"Your ticket: { new_ticket } \" ) print ( f \"Winning ticket: { winning_ticket } \" ) Output: We have a winning ticket! Your ticket: [1, 4, 'a', 9] Winning ticket: [1, 9, 'a', 4] It only took 731 tries to win!","title":"9-15: Lottery Analysis"},{"location":"updates/","text":"Updates When looking for updates it\u2019s helpful to know which printing you\u2019re working from, as minor corrections are made every time the book goes through another print run. Right now, the book is on its second printing. You can see which printing you have by looking on the copyright page, which is on the back of the second page in the physical book . First printing Second printing If you find an error in the book or can\u2019t get something to work, please let me know! You can reach me through email at ehmatthes@gmail.com, on Mastodon at fosstodon.org/@ehmatthes or on Twitter at @ehmatthes .","title":"Updates"},{"location":"updates/#updates","text":"When looking for updates it\u2019s helpful to know which printing you\u2019re working from, as minor corrections are made every time the book goes through another print run. Right now, the book is on its second printing. You can see which printing you have by looking on the copyright page, which is on the back of the second page in the physical book . First printing Second printing If you find an error in the book or can\u2019t get something to work, please let me know! You can reach me through email at ehmatthes@gmail.com, on Mastodon at fosstodon.org/@ehmatthes or on Twitter at @ehmatthes .","title":"Updates"},{"location":"updates/first_printing/","text":"Updates and Errata - First printing This page is broken into two parts, Updates and Errata. Updates address issues that affect whether your code will run or not. Errata refer to minor issues such as typos, and errors in grayed-out code that probably won\u2019t affect the code you\u2019re entering. Code that produces warnings but still runs correctly is noted under Errata, as this is a fairly common occurrence and the code often still works for a long time while producing warnings. If you find an error in the book that's not listed here, or can\u2019t get something to work, please let me know. You can reach me through email at ehmatthes@gmail.com, or on Twitter at @ehmatthes. Updates Errata Chapter 6 Chapter 9 Chapter 10 Chapter 15 Chapter 16 Chapter 18 Chapter 19 Updates There are no updates to note at this time. Errata Chapter 6 The output at the bottom of page 95 should say position , not x-position : Original position: 0 New position: 2 Chapter 9 On page 167, the docstring for the __init__() method in electric_car.py should have triple quotes on both ends: def __init__ ( self , make , model , year ): \"\"\"Initialize attributes to describe a car.\"\"\" ... Chapter 10 On page 200, Exercise 10-7 should read \"Wrap your code from Exercise 10-6 in a while loop...\" Also, Exercise 10-9 should refer to Exercise 10-8. Chapter 15 Matplotlib has a number of predefined styles that you can choose from. The book uses the seaborn style, which was base on a style from the Seaborn plotting library. The default style of the Seaborn library has diverged from Matplotlib's seaborn style, so they are changing the name of this style to make that clear. (If you're curious to read more about this, see \"seaborn styles renamed\" in the Matplotlib documentation page API Changes for 3.6.0 .) If you use seaborn as the book does, you'll see a MatplotlibDeprecationWarning . This won't prevent your code from running, and it won't affect the style of your output. To avoid seeing this warning, use seaborn-v0_8 wherever you see seaborn in the book's code. The code should look like this: plt . style . use ( 'seaborn-v0_8' ) Chapter 16, As noted above for Chapter 15, use seaborn-v0_8 wherever you see seaborn . Chapter 18 On page 399, the listing for topics.html has an extra closing tag </li> . It should look like this: {% for topic in topics %} < li > < a href = \"{% url 'learning_logs:topic' topic.id %}\" > {{ topic.text }} </ a > </ li > ... Chapter 19 On page 425, in the grayed out code for models.py , the text attribute should be lowercase: class Topic ( models . Model ): \"\"\"A topic the user is learning about.\"\"\" text = models . CharField ( max_length = 200 ) ...","title":"First printing"},{"location":"updates/first_printing/#updates-and-errata-first-printing","text":"This page is broken into two parts, Updates and Errata. Updates address issues that affect whether your code will run or not. Errata refer to minor issues such as typos, and errors in grayed-out code that probably won\u2019t affect the code you\u2019re entering. Code that produces warnings but still runs correctly is noted under Errata, as this is a fairly common occurrence and the code often still works for a long time while producing warnings. If you find an error in the book that's not listed here, or can\u2019t get something to work, please let me know. You can reach me through email at ehmatthes@gmail.com, or on Twitter at @ehmatthes. Updates Errata Chapter 6 Chapter 9 Chapter 10 Chapter 15 Chapter 16 Chapter 18 Chapter 19","title":"Updates and Errata - First printing"},{"location":"updates/first_printing/#updates","text":"There are no updates to note at this time.","title":"Updates"},{"location":"updates/first_printing/#errata","text":"","title":"Errata"},{"location":"updates/first_printing/#chapter-6","text":"The output at the bottom of page 95 should say position , not x-position : Original position: 0 New position: 2","title":"Chapter 6"},{"location":"updates/first_printing/#chapter-9","text":"On page 167, the docstring for the __init__() method in electric_car.py should have triple quotes on both ends: def __init__ ( self , make , model , year ): \"\"\"Initialize attributes to describe a car.\"\"\" ...","title":"Chapter 9"},{"location":"updates/first_printing/#chapter-10","text":"On page 200, Exercise 10-7 should read \"Wrap your code from Exercise 10-6 in a while loop...\" Also, Exercise 10-9 should refer to Exercise 10-8.","title":"Chapter 10"},{"location":"updates/first_printing/#chapter-15","text":"Matplotlib has a number of predefined styles that you can choose from. The book uses the seaborn style, which was base on a style from the Seaborn plotting library. The default style of the Seaborn library has diverged from Matplotlib's seaborn style, so they are changing the name of this style to make that clear. (If you're curious to read more about this, see \"seaborn styles renamed\" in the Matplotlib documentation page API Changes for 3.6.0 .) If you use seaborn as the book does, you'll see a MatplotlibDeprecationWarning . This won't prevent your code from running, and it won't affect the style of your output. To avoid seeing this warning, use seaborn-v0_8 wherever you see seaborn in the book's code. The code should look like this: plt . style . use ( 'seaborn-v0_8' )","title":"Chapter 15"},{"location":"updates/first_printing/#chapter-16","text":"As noted above for Chapter 15, use seaborn-v0_8 wherever you see seaborn .","title":"Chapter 16,"},{"location":"updates/first_printing/#chapter-18","text":"On page 399, the listing for topics.html has an extra closing tag </li> . It should look like this: {% for topic in topics %} < li > < a href = \"{% url 'learning_logs:topic' topic.id %}\" > {{ topic.text }} </ a > </ li > ...","title":"Chapter 18"},{"location":"updates/first_printing/#chapter-19","text":"On page 425, in the grayed out code for models.py , the text attribute should be lowercase: class Topic ( models . Model ): \"\"\"A topic the user is learning about.\"\"\" text = models . CharField ( max_length = 200 ) ...","title":"Chapter 19"},{"location":"updates/second_printing/","text":"Updates and Errata - Second printing This page is broken into two parts, Updates and Errata. Updates address issues that affect whether your code will run or not. Errata refer to minor issues such as typos, and errors in grayed-out code that probably won\u2019t affect the code you\u2019re entering. Code that produces warnings but still runs correctly is noted under Errata, as this is a fairly common occurrence and the code often still works for a long time while producing warnings. If you find an error in the book that's not listed here, or can\u2019t get something to work, please let me know. You can reach me through email at ehmatthes@gmail.com, or on Twitter at @ehmatthes. Updates Errata Chapter 6 Chapter 15 Chapter 16 Updates There are no updates to note at this time. Errata Chapter 6 The output at the bottom of page 95 should say position , not x-position : Original position: 0 New position: 2 Chapter 15 Matplotlib has a number of predefined styles that you can choose from. The book uses the seaborn style, which was base on a style from the Seaborn plotting library. The default style of the Seaborn library has diverged from Matplotlib's seaborn style, so they are changing the name of this style to make that clear. (If you're curious to read more about this, see \"seaborn styles renamed\" in the Matplotlib documentation page API Changes for 3.6.0 .) If you use seaborn as the book does, you'll see a MatplotlibDeprecationWarning . This won't prevent your code from running, and it won't affect the style of your output. To avoid seeing this warning, use seaborn-v0_8 wherever you see seaborn in the book's code. The code should look like this: plt . style . use ( 'seaborn-v0_8' ) Chapter 16, As noted above for Chapter 15, use seaborn-v0_8 wherever you see seaborn .","title":"Second printing"},{"location":"updates/second_printing/#updates-and-errata-second-printing","text":"This page is broken into two parts, Updates and Errata. Updates address issues that affect whether your code will run or not. Errata refer to minor issues such as typos, and errors in grayed-out code that probably won\u2019t affect the code you\u2019re entering. Code that produces warnings but still runs correctly is noted under Errata, as this is a fairly common occurrence and the code often still works for a long time while producing warnings. If you find an error in the book that's not listed here, or can\u2019t get something to work, please let me know. You can reach me through email at ehmatthes@gmail.com, or on Twitter at @ehmatthes. Updates Errata Chapter 6 Chapter 15 Chapter 16","title":"Updates and Errata - Second printing"},{"location":"updates/second_printing/#updates","text":"There are no updates to note at this time.","title":"Updates"},{"location":"updates/second_printing/#errata","text":"","title":"Errata"},{"location":"updates/second_printing/#chapter-6","text":"The output at the bottom of page 95 should say position , not x-position : Original position: 0 New position: 2","title":"Chapter 6"},{"location":"updates/second_printing/#chapter-15","text":"Matplotlib has a number of predefined styles that you can choose from. The book uses the seaborn style, which was base on a style from the Seaborn plotting library. The default style of the Seaborn library has diverged from Matplotlib's seaborn style, so they are changing the name of this style to make that clear. (If you're curious to read more about this, see \"seaborn styles renamed\" in the Matplotlib documentation page API Changes for 3.6.0 .) If you use seaborn as the book does, you'll see a MatplotlibDeprecationWarning . This won't prevent your code from running, and it won't affect the style of your output. To avoid seeing this warning, use seaborn-v0_8 wherever you see seaborn in the book's code. The code should look like this: plt . style . use ( 'seaborn-v0_8' )","title":"Chapter 15"},{"location":"updates/second_printing/#chapter-16","text":"As noted above for Chapter 15, use seaborn-v0_8 wherever you see seaborn .","title":"Chapter 16,"},{"location":"updates/which_printing/","text":"Which printing do I have? You can see which printing you have by looking at the copyright page, which is on the back of the second page in the physical book: The image above shows the top of the copyright page, with the printing number outlined in blue.","title":"Which printing do I have?"},{"location":"updates/which_printing/#which-printing-do-i-have","text":"You can see which printing you have by looking at the copyright page, which is on the back of the second page in the physical book: The image above shows the top of the copyright page, with the printing number outlined in blue.","title":"Which printing do I have?"}]}